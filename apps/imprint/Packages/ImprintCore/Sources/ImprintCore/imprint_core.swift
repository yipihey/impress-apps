// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(imprint_coreFFI)
import imprint_coreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_imprint_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_imprint_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


/**
 * Batch import result for multiple publications
 */
public struct BatchImportResult {
    /**
     * Successfully imported content
     */
    public var content: String
    /**
     * Number of annotations imported
     */
    public var annotationCount: UInt32
    /**
     * Number of publications processed
     */
    public var publicationCount: UInt32
    /**
     * Any warnings during import
     */
    public var warnings: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Successfully imported content
         */content: String, 
        /**
         * Number of annotations imported
         */annotationCount: UInt32, 
        /**
         * Number of publications processed
         */publicationCount: UInt32, 
        /**
         * Any warnings during import
         */warnings: [String]) {
        self.content = content
        self.annotationCount = annotationCount
        self.publicationCount = publicationCount
        self.warnings = warnings
    }
}



extension BatchImportResult: Equatable, Hashable {
    public static func ==(lhs: BatchImportResult, rhs: BatchImportResult) -> Bool {
        if lhs.content != rhs.content {
            return false
        }
        if lhs.annotationCount != rhs.annotationCount {
            return false
        }
        if lhs.publicationCount != rhs.publicationCount {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content)
        hasher.combine(annotationCount)
        hasher.combine(publicationCount)
        hasher.combine(warnings)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBatchImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatchImportResult {
        return
            try BatchImportResult(
                content: FfiConverterString.read(from: &buf), 
                annotationCount: FfiConverterUInt32.read(from: &buf), 
                publicationCount: FfiConverterUInt32.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: BatchImportResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterUInt32.write(value.annotationCount, into: &buf)
        FfiConverterUInt32.write(value.publicationCount, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchImportResult_lift(_ buf: RustBuffer) throws -> BatchImportResult {
    return try FfiConverterTypeBatchImportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchImportResult_lower(_ value: BatchImportResult) -> RustBuffer {
    return FfiConverterTypeBatchImportResult.lower(value)
}


/**
 * Compile document to output
 */
public struct CompileCommand {
    /**
     * Document ID to compile
     */
    public var documentId: String
    /**
     * Output format (pdf, svg, png)
     */
    public var format: String?
    /**
     * Destination path
     */
    public var destination: String?
    /**
     * Draft mode (faster, lower quality)
     */
    public var draft: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to compile
         */documentId: String, 
        /**
         * Output format (pdf, svg, png)
         */format: String?, 
        /**
         * Destination path
         */destination: String?, 
        /**
         * Draft mode (faster, lower quality)
         */draft: Bool) {
        self.documentId = documentId
        self.format = format
        self.destination = destination
        self.draft = draft
    }
}



extension CompileCommand: Equatable, Hashable {
    public static func ==(lhs: CompileCommand, rhs: CompileCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.destination != rhs.destination {
            return false
        }
        if lhs.draft != rhs.draft {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(format)
        hasher.combine(destination)
        hasher.combine(draft)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileCommand {
        return
            try CompileCommand(
                documentId: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionString.read(from: &buf), 
                destination: FfiConverterOptionString.read(from: &buf), 
                draft: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CompileCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterOptionString.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.destination, into: &buf)
        FfiConverterBool.write(value.draft, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileCommand_lift(_ buf: RustBuffer) throws -> CompileCommand {
    return try FfiConverterTypeCompileCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileCommand_lower(_ value: CompileCommand) -> RustBuffer {
    return FfiConverterTypeCompileCommand.lower(value)
}


/**
 * Options for compiling Typst to PDF
 */
public struct CompileOptions {
    /**
     * Page size for the output
     */
    public var pageSize: FfiPageSize
    /**
     * Font size in points (default: 11)
     */
    public var fontSize: Double
    /**
     * Page margins in points (top, right, bottom, left)
     */
    public var marginTop: Double
    public var marginRight: Double
    public var marginBottom: Double
    public var marginLeft: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Page size for the output
         */pageSize: FfiPageSize, 
        /**
         * Font size in points (default: 11)
         */fontSize: Double, 
        /**
         * Page margins in points (top, right, bottom, left)
         */marginTop: Double, marginRight: Double, marginBottom: Double, marginLeft: Double) {
        self.pageSize = pageSize
        self.fontSize = fontSize
        self.marginTop = marginTop
        self.marginRight = marginRight
        self.marginBottom = marginBottom
        self.marginLeft = marginLeft
    }
}



extension CompileOptions: Equatable, Hashable {
    public static func ==(lhs: CompileOptions, rhs: CompileOptions) -> Bool {
        if lhs.pageSize != rhs.pageSize {
            return false
        }
        if lhs.fontSize != rhs.fontSize {
            return false
        }
        if lhs.marginTop != rhs.marginTop {
            return false
        }
        if lhs.marginRight != rhs.marginRight {
            return false
        }
        if lhs.marginBottom != rhs.marginBottom {
            return false
        }
        if lhs.marginLeft != rhs.marginLeft {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pageSize)
        hasher.combine(fontSize)
        hasher.combine(marginTop)
        hasher.combine(marginRight)
        hasher.combine(marginBottom)
        hasher.combine(marginLeft)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileOptions {
        return
            try CompileOptions(
                pageSize: FfiConverterTypeFFIPageSize.read(from: &buf), 
                fontSize: FfiConverterDouble.read(from: &buf), 
                marginTop: FfiConverterDouble.read(from: &buf), 
                marginRight: FfiConverterDouble.read(from: &buf), 
                marginBottom: FfiConverterDouble.read(from: &buf), 
                marginLeft: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: CompileOptions, into buf: inout [UInt8]) {
        FfiConverterTypeFFIPageSize.write(value.pageSize, into: &buf)
        FfiConverterDouble.write(value.fontSize, into: &buf)
        FfiConverterDouble.write(value.marginTop, into: &buf)
        FfiConverterDouble.write(value.marginRight, into: &buf)
        FfiConverterDouble.write(value.marginBottom, into: &buf)
        FfiConverterDouble.write(value.marginLeft, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileOptions_lift(_ buf: RustBuffer) throws -> CompileOptions {
    return try FfiConverterTypeCompileOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileOptions_lower(_ value: CompileOptions) -> RustBuffer {
    return FfiConverterTypeCompileOptions.lower(value)
}


/**
 * Result of compiling a Typst document to PDF
 */
public struct CompileResult {
    /**
     * PDF bytes if compilation succeeded
     */
    public var pdfData: Data?
    /**
     * Error message if compilation failed
     */
    public var error: String?
    /**
     * Warning messages from compilation
     */
    public var warnings: [String]
    /**
     * Number of pages in the output
     */
    public var pageCount: UInt32
    /**
     * Source map entries for click-to-edit
     */
    public var sourceMapEntries: [FfiSourceMapEntry]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * PDF bytes if compilation succeeded
         */pdfData: Data?, 
        /**
         * Error message if compilation failed
         */error: String?, 
        /**
         * Warning messages from compilation
         */warnings: [String], 
        /**
         * Number of pages in the output
         */pageCount: UInt32, 
        /**
         * Source map entries for click-to-edit
         */sourceMapEntries: [FfiSourceMapEntry]) {
        self.pdfData = pdfData
        self.error = error
        self.warnings = warnings
        self.pageCount = pageCount
        self.sourceMapEntries = sourceMapEntries
    }
}



extension CompileResult: Equatable, Hashable {
    public static func ==(lhs: CompileResult, rhs: CompileResult) -> Bool {
        if lhs.pdfData != rhs.pdfData {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        if lhs.pageCount != rhs.pageCount {
            return false
        }
        if lhs.sourceMapEntries != rhs.sourceMapEntries {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pdfData)
        hasher.combine(error)
        hasher.combine(warnings)
        hasher.combine(pageCount)
        hasher.combine(sourceMapEntries)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileResult {
        return
            try CompileResult(
                pdfData: FfiConverterOptionData.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf), 
                pageCount: FfiConverterUInt32.read(from: &buf), 
                sourceMapEntries: FfiConverterSequenceTypeFFISourceMapEntry.read(from: &buf)
        )
    }

    public static func write(_ value: CompileResult, into buf: inout [UInt8]) {
        FfiConverterOptionData.write(value.pdfData, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
        FfiConverterUInt32.write(value.pageCount, into: &buf)
        FfiConverterSequenceTypeFFISourceMapEntry.write(value.sourceMapEntries, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileResult_lift(_ buf: RustBuffer) throws -> CompileResult {
    return try FfiConverterTypeCompileResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileResult_lower(_ value: CompileResult) -> RustBuffer {
    return FfiConverterTypeCompileResult.lower(value)
}


/**
 * Export document to a format
 */
public struct ExportCommand {
    /**
     * Document ID to export
     */
    public var documentId: String
    /**
     * Output format (pdf, latex, docx, html, typst)
     */
    public var format: String
    /**
     * Destination path
     */
    public var destination: String?
    /**
     * Include bibliography file
     */
    public var includeBibliography: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to export
         */documentId: String, 
        /**
         * Output format (pdf, latex, docx, html, typst)
         */format: String, 
        /**
         * Destination path
         */destination: String?, 
        /**
         * Include bibliography file
         */includeBibliography: Bool) {
        self.documentId = documentId
        self.format = format
        self.destination = destination
        self.includeBibliography = includeBibliography
    }
}



extension ExportCommand: Equatable, Hashable {
    public static func ==(lhs: ExportCommand, rhs: ExportCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.destination != rhs.destination {
            return false
        }
        if lhs.includeBibliography != rhs.includeBibliography {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(format)
        hasher.combine(destination)
        hasher.combine(includeBibliography)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExportCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportCommand {
        return
            try ExportCommand(
                documentId: FfiConverterString.read(from: &buf), 
                format: FfiConverterString.read(from: &buf), 
                destination: FfiConverterOptionString.read(from: &buf), 
                includeBibliography: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ExportCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.destination, into: &buf)
        FfiConverterBool.write(value.includeBibliography, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lift(_ buf: RustBuffer) throws -> ExportCommand {
    return try FfiConverterTypeExportCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lower(_ value: ExportCommand) -> RustBuffer {
    return FfiConverterTypeExportCommand.lower(value)
}


/**
 * A bounding box in PDF coordinates
 */
public struct FfiBoundingBox {
    /**
     * Left edge x coordinate
     */
    public var x: Double
    /**
     * Top edge y coordinate
     */
    public var y: Double
    /**
     * Width in points
     */
    public var width: Double
    /**
     * Height in points
     */
    public var height: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Left edge x coordinate
         */x: Double, 
        /**
         * Top edge y coordinate
         */y: Double, 
        /**
         * Width in points
         */width: Double, 
        /**
         * Height in points
         */height: Double) {
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    }
}



extension FfiBoundingBox: Equatable, Hashable {
    public static func ==(lhs: FfiBoundingBox, rhs: FfiBoundingBox) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(width)
        hasher.combine(height)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIBoundingBox: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBoundingBox {
        return
            try FfiBoundingBox(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                width: FfiConverterDouble.read(from: &buf), 
                height: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: FfiBoundingBox, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.width, into: &buf)
        FfiConverterDouble.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIBoundingBox_lift(_ buf: RustBuffer) throws -> FfiBoundingBox {
    return try FfiConverterTypeFFIBoundingBox.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIBoundingBox_lower(_ value: FfiBoundingBox) -> RustBuffer {
    return FfiConverterTypeFFIBoundingBox.lower(value)
}


/**
 * CRDT validation result for FFI
 */
public struct FfiCrdtValidation {
    public var isValid: Bool
    public var hasContent: Bool
    public var estimatedTextLength: UInt64
    public var issues: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isValid: Bool, hasContent: Bool, estimatedTextLength: UInt64, issues: [String]) {
        self.isValid = isValid
        self.hasContent = hasContent
        self.estimatedTextLength = estimatedTextLength
        self.issues = issues
    }
}



extension FfiCrdtValidation: Equatable, Hashable {
    public static func ==(lhs: FfiCrdtValidation, rhs: FfiCrdtValidation) -> Bool {
        if lhs.isValid != rhs.isValid {
            return false
        }
        if lhs.hasContent != rhs.hasContent {
            return false
        }
        if lhs.estimatedTextLength != rhs.estimatedTextLength {
            return false
        }
        if lhs.issues != rhs.issues {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isValid)
        hasher.combine(hasContent)
        hasher.combine(estimatedTextLength)
        hasher.combine(issues)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFICrdtValidation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCrdtValidation {
        return
            try FfiCrdtValidation(
                isValid: FfiConverterBool.read(from: &buf), 
                hasContent: FfiConverterBool.read(from: &buf), 
                estimatedTextLength: FfiConverterUInt64.read(from: &buf), 
                issues: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCrdtValidation, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isValid, into: &buf)
        FfiConverterBool.write(value.hasContent, into: &buf)
        FfiConverterUInt64.write(value.estimatedTextLength, into: &buf)
        FfiConverterSequenceString.write(value.issues, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFICrdtValidation_lift(_ buf: RustBuffer) throws -> FfiCrdtValidation {
    return try FfiConverterTypeFFICrdtValidation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFICrdtValidation_lower(_ value: FfiCrdtValidation) -> RustBuffer {
    return FfiConverterTypeFFICrdtValidation.lower(value)
}


/**
 * Result of looking up a click position in the source map
 */
public struct FfiCursorPosition {
    /**
     * Source offset for the cursor
     */
    public var sourceOffset: UInt64
    /**
     * Whether a match was found
     */
    public var found: Bool
    /**
     * Content type at this position
     */
    public var contentType: FfiContentType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Source offset for the cursor
         */sourceOffset: UInt64, 
        /**
         * Whether a match was found
         */found: Bool, 
        /**
         * Content type at this position
         */contentType: FfiContentType) {
        self.sourceOffset = sourceOffset
        self.found = found
        self.contentType = contentType
    }
}



extension FfiCursorPosition: Equatable, Hashable {
    public static func ==(lhs: FfiCursorPosition, rhs: FfiCursorPosition) -> Bool {
        if lhs.sourceOffset != rhs.sourceOffset {
            return false
        }
        if lhs.found != rhs.found {
            return false
        }
        if lhs.contentType != rhs.contentType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sourceOffset)
        hasher.combine(found)
        hasher.combine(contentType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFICursorPosition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCursorPosition {
        return
            try FfiCursorPosition(
                sourceOffset: FfiConverterUInt64.read(from: &buf), 
                found: FfiConverterBool.read(from: &buf), 
                contentType: FfiConverterTypeFFIContentType.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCursorPosition, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.sourceOffset, into: &buf)
        FfiConverterBool.write(value.found, into: &buf)
        FfiConverterTypeFFIContentType.write(value.contentType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFICursorPosition_lift(_ buf: RustBuffer) throws -> FfiCursorPosition {
    return try FfiConverterTypeFFICursorPosition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFICursorPosition_lower(_ value: FfiCursorPosition) -> RustBuffer {
    return FfiConverterTypeFFICursorPosition.lower(value)
}


/**
 * Journal information for FFI
 */
public struct FfiJournalInfo {
    /**
     * Publisher name
     */
    public var publisher: String
    /**
     * Journal URL
     */
    public var url: String?
    /**
     * LaTeX document class
     */
    public var latexClass: String?
    /**
     * ISSN
     */
    public var issn: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Publisher name
         */publisher: String, 
        /**
         * Journal URL
         */url: String?, 
        /**
         * LaTeX document class
         */latexClass: String?, 
        /**
         * ISSN
         */issn: String?) {
        self.publisher = publisher
        self.url = url
        self.latexClass = latexClass
        self.issn = issn
    }
}



extension FfiJournalInfo: Equatable, Hashable {
    public static func ==(lhs: FfiJournalInfo, rhs: FfiJournalInfo) -> Bool {
        if lhs.publisher != rhs.publisher {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.latexClass != rhs.latexClass {
            return false
        }
        if lhs.issn != rhs.issn {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publisher)
        hasher.combine(url)
        hasher.combine(latexClass)
        hasher.combine(issn)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIJournalInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiJournalInfo {
        return
            try FfiJournalInfo(
                publisher: FfiConverterString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                latexClass: FfiConverterOptionString.read(from: &buf), 
                issn: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiJournalInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publisher, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.latexClass, into: &buf)
        FfiConverterOptionString.write(value.issn, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIJournalInfo_lift(_ buf: RustBuffer) throws -> FfiJournalInfo {
    return try FfiConverterTypeFFIJournalInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIJournalInfo_lower(_ value: FfiJournalInfo) -> RustBuffer {
    return FfiConverterTypeFFIJournalInfo.lower(value)
}


/**
 * Page defaults for FFI
 */
public struct FfiPageDefaults {
    /**
     * Paper size (a4, letter, a5)
     */
    public var size: String
    /**
     * Top margin in mm
     */
    public var marginTop: Double
    /**
     * Right margin in mm
     */
    public var marginRight: Double
    /**
     * Bottom margin in mm
     */
    public var marginBottom: Double
    /**
     * Left margin in mm
     */
    public var marginLeft: Double
    /**
     * Number of columns
     */
    public var columns: UInt8
    /**
     * Font size in pt
     */
    public var fontSize: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Paper size (a4, letter, a5)
         */size: String, 
        /**
         * Top margin in mm
         */marginTop: Double, 
        /**
         * Right margin in mm
         */marginRight: Double, 
        /**
         * Bottom margin in mm
         */marginBottom: Double, 
        /**
         * Left margin in mm
         */marginLeft: Double, 
        /**
         * Number of columns
         */columns: UInt8, 
        /**
         * Font size in pt
         */fontSize: Double) {
        self.size = size
        self.marginTop = marginTop
        self.marginRight = marginRight
        self.marginBottom = marginBottom
        self.marginLeft = marginLeft
        self.columns = columns
        self.fontSize = fontSize
    }
}



extension FfiPageDefaults: Equatable, Hashable {
    public static func ==(lhs: FfiPageDefaults, rhs: FfiPageDefaults) -> Bool {
        if lhs.size != rhs.size {
            return false
        }
        if lhs.marginTop != rhs.marginTop {
            return false
        }
        if lhs.marginRight != rhs.marginRight {
            return false
        }
        if lhs.marginBottom != rhs.marginBottom {
            return false
        }
        if lhs.marginLeft != rhs.marginLeft {
            return false
        }
        if lhs.columns != rhs.columns {
            return false
        }
        if lhs.fontSize != rhs.fontSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(size)
        hasher.combine(marginTop)
        hasher.combine(marginRight)
        hasher.combine(marginBottom)
        hasher.combine(marginLeft)
        hasher.combine(columns)
        hasher.combine(fontSize)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIPageDefaults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPageDefaults {
        return
            try FfiPageDefaults(
                size: FfiConverterString.read(from: &buf), 
                marginTop: FfiConverterDouble.read(from: &buf), 
                marginRight: FfiConverterDouble.read(from: &buf), 
                marginBottom: FfiConverterDouble.read(from: &buf), 
                marginLeft: FfiConverterDouble.read(from: &buf), 
                columns: FfiConverterUInt8.read(from: &buf), 
                fontSize: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPageDefaults, into buf: inout [UInt8]) {
        FfiConverterString.write(value.size, into: &buf)
        FfiConverterDouble.write(value.marginTop, into: &buf)
        FfiConverterDouble.write(value.marginRight, into: &buf)
        FfiConverterDouble.write(value.marginBottom, into: &buf)
        FfiConverterDouble.write(value.marginLeft, into: &buf)
        FfiConverterUInt8.write(value.columns, into: &buf)
        FfiConverterDouble.write(value.fontSize, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageDefaults_lift(_ buf: RustBuffer) throws -> FfiPageDefaults {
    return try FfiConverterTypeFFIPageDefaults.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageDefaults_lower(_ value: FfiPageDefaults) -> RustBuffer {
    return FfiConverterTypeFFIPageDefaults.lower(value)
}


/**
 * A position in rendered PDF coordinates
 */
public struct FfiRenderPosition {
    /**
     * Page number (0-indexed)
     */
    public var page: UInt32
    /**
     * X coordinate in points from left edge
     */
    public var x: Double
    /**
     * Y coordinate in points from top edge
     */
    public var y: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Page number (0-indexed)
         */page: UInt32, 
        /**
         * X coordinate in points from left edge
         */x: Double, 
        /**
         * Y coordinate in points from top edge
         */y: Double) {
        self.page = page
        self.x = x
        self.y = y
    }
}



extension FfiRenderPosition: Equatable, Hashable {
    public static func ==(lhs: FfiRenderPosition, rhs: FfiRenderPosition) -> Bool {
        if lhs.page != rhs.page {
            return false
        }
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(page)
        hasher.combine(x)
        hasher.combine(y)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIRenderPosition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRenderPosition {
        return
            try FfiRenderPosition(
                page: FfiConverterUInt32.read(from: &buf), 
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: FfiRenderPosition, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.page, into: &buf)
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIRenderPosition_lift(_ buf: RustBuffer) throws -> FfiRenderPosition {
    return try FfiConverterTypeFFIRenderPosition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIRenderPosition_lower(_ value: FfiRenderPosition) -> RustBuffer {
    return FfiConverterTypeFFIRenderPosition.lower(value)
}


/**
 * Result of a source-to-render lookup
 */
public struct FfiRenderRegion {
    /**
     * Page number (0-indexed)
     */
    public var page: UInt32
    /**
     * Bounding box x coordinate
     */
    public var x: Double
    /**
     * Bounding box y coordinate
     */
    public var y: Double
    /**
     * Bounding box width
     */
    public var width: Double
    /**
     * Bounding box height
     */
    public var height: Double
    /**
     * Whether a match was found
     */
    public var found: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Page number (0-indexed)
         */page: UInt32, 
        /**
         * Bounding box x coordinate
         */x: Double, 
        /**
         * Bounding box y coordinate
         */y: Double, 
        /**
         * Bounding box width
         */width: Double, 
        /**
         * Bounding box height
         */height: Double, 
        /**
         * Whether a match was found
         */found: Bool) {
        self.page = page
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.found = found
    }
}



extension FfiRenderRegion: Equatable, Hashable {
    public static func ==(lhs: FfiRenderRegion, rhs: FfiRenderRegion) -> Bool {
        if lhs.page != rhs.page {
            return false
        }
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.found != rhs.found {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(page)
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(found)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIRenderRegion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRenderRegion {
        return
            try FfiRenderRegion(
                page: FfiConverterUInt32.read(from: &buf), 
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                width: FfiConverterDouble.read(from: &buf), 
                height: FfiConverterDouble.read(from: &buf), 
                found: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiRenderRegion, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.page, into: &buf)
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.width, into: &buf)
        FfiConverterDouble.write(value.height, into: &buf)
        FfiConverterBool.write(value.found, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIRenderRegion_lift(_ buf: RustBuffer) throws -> FfiRenderRegion {
    return try FfiConverterTypeFFIRenderRegion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIRenderRegion_lower(_ value: FfiRenderRegion) -> RustBuffer {
    return FfiConverterTypeFFIRenderRegion.lower(value)
}


/**
 * A source map entry linking source to rendered position
 */
public struct FfiSourceMapEntry {
    /**
     * Source span in the document
     */
    public var source: FfiSourceSpan
    /**
     * Page number where this content appears
     */
    public var page: UInt32
    /**
     * Bounding box on the page
     */
    public var bbox: FfiBoundingBox
    /**
     * Type of content
     */
    public var contentType: FfiContentType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Source span in the document
         */source: FfiSourceSpan, 
        /**
         * Page number where this content appears
         */page: UInt32, 
        /**
         * Bounding box on the page
         */bbox: FfiBoundingBox, 
        /**
         * Type of content
         */contentType: FfiContentType) {
        self.source = source
        self.page = page
        self.bbox = bbox
        self.contentType = contentType
    }
}



extension FfiSourceMapEntry: Equatable, Hashable {
    public static func ==(lhs: FfiSourceMapEntry, rhs: FfiSourceMapEntry) -> Bool {
        if lhs.source != rhs.source {
            return false
        }
        if lhs.page != rhs.page {
            return false
        }
        if lhs.bbox != rhs.bbox {
            return false
        }
        if lhs.contentType != rhs.contentType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(source)
        hasher.combine(page)
        hasher.combine(bbox)
        hasher.combine(contentType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFISourceMapEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSourceMapEntry {
        return
            try FfiSourceMapEntry(
                source: FfiConverterTypeFFISourceSpan.read(from: &buf), 
                page: FfiConverterUInt32.read(from: &buf), 
                bbox: FfiConverterTypeFFIBoundingBox.read(from: &buf), 
                contentType: FfiConverterTypeFFIContentType.read(from: &buf)
        )
    }

    public static func write(_ value: FfiSourceMapEntry, into buf: inout [UInt8]) {
        FfiConverterTypeFFISourceSpan.write(value.source, into: &buf)
        FfiConverterUInt32.write(value.page, into: &buf)
        FfiConverterTypeFFIBoundingBox.write(value.bbox, into: &buf)
        FfiConverterTypeFFIContentType.write(value.contentType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISourceMapEntry_lift(_ buf: RustBuffer) throws -> FfiSourceMapEntry {
    return try FfiConverterTypeFFISourceMapEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISourceMapEntry_lower(_ value: FfiSourceMapEntry) -> RustBuffer {
    return FfiConverterTypeFFISourceMapEntry.lower(value)
}


/**
 * A source span (byte offsets in source code)
 */
public struct FfiSourceSpan {
    /**
     * Start byte offset (inclusive)
     */
    public var start: UInt64
    /**
     * End byte offset (exclusive)
     */
    public var end: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Start byte offset (inclusive)
         */start: UInt64, 
        /**
         * End byte offset (exclusive)
         */end: UInt64) {
        self.start = start
        self.end = end
    }
}



extension FfiSourceSpan: Equatable, Hashable {
    public static func ==(lhs: FfiSourceSpan, rhs: FfiSourceSpan) -> Bool {
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(start)
        hasher.combine(end)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFISourceSpan: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSourceSpan {
        return
            try FfiSourceSpan(
                start: FfiConverterUInt64.read(from: &buf), 
                end: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiSourceSpan, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.start, into: &buf)
        FfiConverterUInt64.write(value.end, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISourceSpan_lift(_ buf: RustBuffer) throws -> FfiSourceSpan {
    return try FfiConverterTypeFFISourceSpan.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISourceSpan_lower(_ value: FfiSourceSpan) -> RustBuffer {
    return FfiConverterTypeFFISourceSpan.lower(value)
}


/**
 * Full template data for FFI
 */
public struct FfiTemplate {
    /**
     * Template metadata
     */
    public var metadata: FfiTemplateMetadata
    /**
     * Typst template source
     */
    public var typstSource: String
    /**
     * Optional LaTeX preamble
     */
    public var latexPreamble: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Template metadata
         */metadata: FfiTemplateMetadata, 
        /**
         * Typst template source
         */typstSource: String, 
        /**
         * Optional LaTeX preamble
         */latexPreamble: String?) {
        self.metadata = metadata
        self.typstSource = typstSource
        self.latexPreamble = latexPreamble
    }
}



extension FfiTemplate: Equatable, Hashable {
    public static func ==(lhs: FfiTemplate, rhs: FfiTemplate) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.typstSource != rhs.typstSource {
            return false
        }
        if lhs.latexPreamble != rhs.latexPreamble {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(typstSource)
        hasher.combine(latexPreamble)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFITemplate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTemplate {
        return
            try FfiTemplate(
                metadata: FfiConverterTypeFFITemplateMetadata.read(from: &buf), 
                typstSource: FfiConverterString.read(from: &buf), 
                latexPreamble: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTemplate, into buf: inout [UInt8]) {
        FfiConverterTypeFFITemplateMetadata.write(value.metadata, into: &buf)
        FfiConverterString.write(value.typstSource, into: &buf)
        FfiConverterOptionString.write(value.latexPreamble, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplate_lift(_ buf: RustBuffer) throws -> FfiTemplate {
    return try FfiConverterTypeFFITemplate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplate_lower(_ value: FfiTemplate) -> RustBuffer {
    return FfiConverterTypeFFITemplate.lower(value)
}


/**
 * Template metadata for FFI
 */
public struct FfiTemplateMetadata {
    /**
     * Unique template ID
     */
    public var id: String
    /**
     * Human-readable name
     */
    public var name: String
    /**
     * Template version
     */
    public var version: String
    /**
     * Description
     */
    public var description: String
    /**
     * Author
     */
    public var author: String
    /**
     * License
     */
    public var license: String
    /**
     * Category
     */
    public var category: FfiTemplateCategory
    /**
     * Searchable tags
     */
    public var tags: [String]
    /**
     * Journal info (for journal templates)
     */
    public var journal: FfiJournalInfo?
    /**
     * Page layout defaults
     */
    public var pageDefaults: FfiPageDefaults
    /**
     * Whether this is a built-in template
     */
    public var isBuiltin: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique template ID
         */id: String, 
        /**
         * Human-readable name
         */name: String, 
        /**
         * Template version
         */version: String, 
        /**
         * Description
         */description: String, 
        /**
         * Author
         */author: String, 
        /**
         * License
         */license: String, 
        /**
         * Category
         */category: FfiTemplateCategory, 
        /**
         * Searchable tags
         */tags: [String], 
        /**
         * Journal info (for journal templates)
         */journal: FfiJournalInfo?, 
        /**
         * Page layout defaults
         */pageDefaults: FfiPageDefaults, 
        /**
         * Whether this is a built-in template
         */isBuiltin: Bool) {
        self.id = id
        self.name = name
        self.version = version
        self.description = description
        self.author = author
        self.license = license
        self.category = category
        self.tags = tags
        self.journal = journal
        self.pageDefaults = pageDefaults
        self.isBuiltin = isBuiltin
    }
}



extension FfiTemplateMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiTemplateMetadata, rhs: FfiTemplateMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.license != rhs.license {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.journal != rhs.journal {
            return false
        }
        if lhs.pageDefaults != rhs.pageDefaults {
            return false
        }
        if lhs.isBuiltin != rhs.isBuiltin {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(description)
        hasher.combine(author)
        hasher.combine(license)
        hasher.combine(category)
        hasher.combine(tags)
        hasher.combine(journal)
        hasher.combine(pageDefaults)
        hasher.combine(isBuiltin)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFITemplateMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTemplateMetadata {
        return
            try FfiTemplateMetadata(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                license: FfiConverterString.read(from: &buf), 
                category: FfiConverterTypeFFITemplateCategory.read(from: &buf), 
                tags: FfiConverterSequenceString.read(from: &buf), 
                journal: FfiConverterOptionTypeFFIJournalInfo.read(from: &buf), 
                pageDefaults: FfiConverterTypeFFIPageDefaults.read(from: &buf), 
                isBuiltin: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTemplateMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.license, into: &buf)
        FfiConverterTypeFFITemplateCategory.write(value.category, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
        FfiConverterOptionTypeFFIJournalInfo.write(value.journal, into: &buf)
        FfiConverterTypeFFIPageDefaults.write(value.pageDefaults, into: &buf)
        FfiConverterBool.write(value.isBuiltin, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplateMetadata_lift(_ buf: RustBuffer) throws -> FfiTemplateMetadata {
    return try FfiConverterTypeFFITemplateMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplateMetadata_lower(_ value: FfiTemplateMetadata) -> RustBuffer {
    return FfiConverterTypeFFITemplateMetadata.lower(value)
}


/**
 * Import notes from imbib PDF annotations
 */
public struct ImportNotesCommand {
    /**
     * Target document ID
     */
    public var documentId: String
    /**
     * Publication ID in imbib to import from
     */
    public var publicationId: String
    /**
     * Import format (quote, margin_note, inline)
     */
    public var format: String?
    /**
     * Position to insert at
     */
    public var position: UInt64?
    /**
     * Filter by annotation type (highlight, note, all)
     */
    public var annotationType: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Target document ID
         */documentId: String, 
        /**
         * Publication ID in imbib to import from
         */publicationId: String, 
        /**
         * Import format (quote, margin_note, inline)
         */format: String?, 
        /**
         * Position to insert at
         */position: UInt64?, 
        /**
         * Filter by annotation type (highlight, note, all)
         */annotationType: String?) {
        self.documentId = documentId
        self.publicationId = publicationId
        self.format = format
        self.position = position
        self.annotationType = annotationType
    }
}



extension ImportNotesCommand: Equatable, Hashable {
    public static func ==(lhs: ImportNotesCommand, rhs: ImportNotesCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.annotationType != rhs.annotationType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(publicationId)
        hasher.combine(format)
        hasher.combine(position)
        hasher.combine(annotationType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportNotesCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportNotesCommand {
        return
            try ImportNotesCommand(
                documentId: FfiConverterString.read(from: &buf), 
                publicationId: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf), 
                annotationType: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImportNotesCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterOptionString.write(value.format, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
        FfiConverterOptionString.write(value.annotationType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportNotesCommand_lift(_ buf: RustBuffer) throws -> ImportNotesCommand {
    return try FfiConverterTypeImportNotesCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportNotesCommand_lower(_ value: ImportNotesCommand) -> RustBuffer {
    return FfiConverterTypeImportNotesCommand.lower(value)
}


/**
 * Insert a citation into the document
 */
public struct InsertCitationCommand {
    /**
     * Citation key to insert
     */
    public var citeKey: String
    /**
     * Target document ID
     */
    public var documentId: String?
    /**
     * Position to insert at (character offset)
     */
    public var position: UInt64?
    /**
     * BibTeX entry to add to bibliography
     */
    public var bibtex: String?
    /**
     * Publication ID in imbib
     */
    public var publicationId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Citation key to insert
         */citeKey: String, 
        /**
         * Target document ID
         */documentId: String?, 
        /**
         * Position to insert at (character offset)
         */position: UInt64?, 
        /**
         * BibTeX entry to add to bibliography
         */bibtex: String?, 
        /**
         * Publication ID in imbib
         */publicationId: String?) {
        self.citeKey = citeKey
        self.documentId = documentId
        self.position = position
        self.bibtex = bibtex
        self.publicationId = publicationId
    }
}



extension InsertCitationCommand: Equatable, Hashable {
    public static func ==(lhs: InsertCitationCommand, rhs: InsertCitationCommand) -> Bool {
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.bibtex != rhs.bibtex {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citeKey)
        hasher.combine(documentId)
        hasher.combine(position)
        hasher.combine(bibtex)
        hasher.combine(publicationId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInsertCitationCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertCitationCommand {
        return
            try InsertCitationCommand(
                citeKey: FfiConverterString.read(from: &buf), 
                documentId: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf), 
                bibtex: FfiConverterOptionString.read(from: &buf), 
                publicationId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: InsertCitationCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
        FfiConverterOptionString.write(value.bibtex, into: &buf)
        FfiConverterOptionString.write(value.publicationId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lift(_ buf: RustBuffer) throws -> InsertCitationCommand {
    return try FfiConverterTypeInsertCitationCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lower(_ value: InsertCitationCommand) -> RustBuffer {
    return FfiConverterTypeInsertCitationCommand.lower(value)
}


/**
 * Navigate to a position in the document
 */
public struct NavigateCommand {
    /**
     * Document ID
     */
    public var documentId: String?
    /**
     * Position type
     */
    public var positionType: NavigationTarget
    /**
     * Position value (line number, character offset, page number, or search term)
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID
         */documentId: String?, 
        /**
         * Position type
         */positionType: NavigationTarget, 
        /**
         * Position value (line number, character offset, page number, or search term)
         */value: String) {
        self.documentId = documentId
        self.positionType = positionType
        self.value = value
    }
}



extension NavigateCommand: Equatable, Hashable {
    public static func ==(lhs: NavigateCommand, rhs: NavigateCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.positionType != rhs.positionType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(positionType)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavigateCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavigateCommand {
        return
            try NavigateCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                positionType: FfiConverterTypeNavigationTarget.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NavigateCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterTypeNavigationTarget.write(value.positionType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigateCommand_lift(_ buf: RustBuffer) throws -> NavigateCommand {
    return try FfiConverterTypeNavigateCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigateCommand_lower(_ value: NavigateCommand) -> RustBuffer {
    return FfiConverterTypeNavigateCommand.lower(value)
}


/**
 * Create a new document
 */
public struct NewDocumentCommand {
    /**
     * Document title
     */
    public var title: String?
    /**
     * Template to use
     */
    public var template: String?
    /**
     * Initial content
     */
    public var content: String?
    /**
     * Associated manuscript ID (in imbib)
     */
    public var manuscriptId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document title
         */title: String?, 
        /**
         * Template to use
         */template: String?, 
        /**
         * Initial content
         */content: String?, 
        /**
         * Associated manuscript ID (in imbib)
         */manuscriptId: String?) {
        self.title = title
        self.template = template
        self.content = content
        self.manuscriptId = manuscriptId
    }
}



extension NewDocumentCommand: Equatable, Hashable {
    public static func ==(lhs: NewDocumentCommand, rhs: NewDocumentCommand) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.manuscriptId != rhs.manuscriptId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(template)
        hasher.combine(content)
        hasher.combine(manuscriptId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewDocumentCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewDocumentCommand {
        return
            try NewDocumentCommand(
                title: FfiConverterOptionString.read(from: &buf), 
                template: FfiConverterOptionString.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                manuscriptId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NewDocumentCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.manuscriptId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewDocumentCommand_lift(_ buf: RustBuffer) throws -> NewDocumentCommand {
    return try FfiConverterTypeNewDocumentCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewDocumentCommand_lower(_ value: NewDocumentCommand) -> RustBuffer {
    return FfiConverterTypeNewDocumentCommand.lower(value)
}


/**
 * Open a document by ID or path
 */
public struct OpenDocumentCommand {
    /**
     * Document ID (UUID)
     */
    public var documentId: String?
    /**
     * File path
     */
    public var path: String?
    /**
     * Open in specific edit mode
     */
    public var editMode: String?
    /**
     * Navigate to position after opening
     */
    public var position: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID (UUID)
         */documentId: String?, 
        /**
         * File path
         */path: String?, 
        /**
         * Open in specific edit mode
         */editMode: String?, 
        /**
         * Navigate to position after opening
         */position: UInt64?) {
        self.documentId = documentId
        self.path = path
        self.editMode = editMode
        self.position = position
    }
}



extension OpenDocumentCommand: Equatable, Hashable {
    public static func ==(lhs: OpenDocumentCommand, rhs: OpenDocumentCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.editMode != rhs.editMode {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(path)
        hasher.combine(editMode)
        hasher.combine(position)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenDocumentCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenDocumentCommand {
        return
            try OpenDocumentCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf), 
                editMode: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: OpenDocumentCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterOptionString.write(value.editMode, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenDocumentCommand_lift(_ buf: RustBuffer) throws -> OpenDocumentCommand {
    return try FfiConverterTypeOpenDocumentCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenDocumentCommand_lower(_ value: OpenDocumentCommand) -> RustBuffer {
    return FfiConverterTypeOpenDocumentCommand.lower(value)
}


/**
 * Parse result with command and any errors
 */
public struct ParseResult {
    /**
     * Parsed command (if successful)
     */
    public var command: ImprintCommand?
    /**
     * Error message (if failed)
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Parsed command (if successful)
         */command: ImprintCommand?, 
        /**
         * Error message (if failed)
         */error: String?) {
        self.command = command
        self.error = error
    }
}



extension ParseResult: Equatable, Hashable {
    public static func ==(lhs: ParseResult, rhs: ParseResult) -> Bool {
        if lhs.command != rhs.command {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(command)
        hasher.combine(error)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseResult {
        return
            try ParseResult(
                command: FfiConverterOptionTypeImprintCommand.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParseResult, into buf: inout [UInt8]) {
        FfiConverterOptionTypeImprintCommand.write(value.command, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lift(_ buf: RustBuffer) throws -> ParseResult {
    return try FfiConverterTypeParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lower(_ value: ParseResult) -> RustBuffer {
    return FfiConverterTypeParseResult.lower(value)
}


/**
 * Set the edit mode
 */
public struct SetEditModeCommand {
    /**
     * Document ID
     */
    public var documentId: String?
    /**
     * Mode (direct_pdf, split_view, text_only)
     */
    public var mode: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID
         */documentId: String?, 
        /**
         * Mode (direct_pdf, split_view, text_only)
         */mode: String) {
        self.documentId = documentId
        self.mode = mode
    }
}



extension SetEditModeCommand: Equatable, Hashable {
    public static func ==(lhs: SetEditModeCommand, rhs: SetEditModeCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.mode != rhs.mode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(mode)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetEditModeCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetEditModeCommand {
        return
            try SetEditModeCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                mode: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SetEditModeCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.mode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetEditModeCommand_lift(_ buf: RustBuffer) throws -> SetEditModeCommand {
    return try FfiConverterTypeSetEditModeCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetEditModeCommand_lower(_ value: SetEditModeCommand) -> RustBuffer {
    return FfiConverterTypeSetEditModeCommand.lower(value)
}


/**
 * Share document with collaborators
 */
public struct ShareCommand {
    /**
     * Document ID to share
     */
    public var documentId: String
    /**
     * Share action (invite, revoke, list)
     */
    public var action: ShareAction
    /**
     * Email of collaborator (for invite/revoke)
     */
    public var email: String?
    /**
     * Permission level (view, comment, edit)
     */
    public var permission: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to share
         */documentId: String, 
        /**
         * Share action (invite, revoke, list)
         */action: ShareAction, 
        /**
         * Email of collaborator (for invite/revoke)
         */email: String?, 
        /**
         * Permission level (view, comment, edit)
         */permission: String?) {
        self.documentId = documentId
        self.action = action
        self.email = email
        self.permission = permission
    }
}



extension ShareCommand: Equatable, Hashable {
    public static func ==(lhs: ShareCommand, rhs: ShareCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.permission != rhs.permission {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(action)
        hasher.combine(email)
        hasher.combine(permission)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShareCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShareCommand {
        return
            try ShareCommand(
                documentId: FfiConverterString.read(from: &buf), 
                action: FfiConverterTypeShareAction.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                permission: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ShareCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterTypeShareAction.write(value.action, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.permission, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareCommand_lift(_ buf: RustBuffer) throws -> ShareCommand {
    return try FfiConverterTypeShareCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareCommand_lower(_ value: ShareCommand) -> RustBuffer {
    return FfiConverterTypeShareCommand.lower(value)
}


/**
 * Sync with collaborators
 */
public struct SyncCommand {
    /**
     * Document ID to sync
     */
    public var documentId: String?
    /**
     * Sync all documents
     */
    public var all: Bool
    /**
     * Force full sync (ignore cache)
     */
    public var force: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to sync
         */documentId: String?, 
        /**
         * Sync all documents
         */all: Bool, 
        /**
         * Force full sync (ignore cache)
         */force: Bool) {
        self.documentId = documentId
        self.all = all
        self.force = force
    }
}



extension SyncCommand: Equatable, Hashable {
    public static func ==(lhs: SyncCommand, rhs: SyncCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.all != rhs.all {
            return false
        }
        if lhs.force != rhs.force {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(all)
        hasher.combine(force)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncCommand {
        return
            try SyncCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                all: FfiConverterBool.read(from: &buf), 
                force: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SyncCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterBool.write(value.all, into: &buf)
        FfiConverterBool.write(value.force, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncCommand_lift(_ buf: RustBuffer) throws -> SyncCommand {
    return try FfiConverterTypeSyncCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncCommand_lower(_ value: SyncCommand) -> RustBuffer {
    return FfiConverterTypeSyncCommand.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Content type for cursor placement hints
 */

public enum FfiContentType {
    
    case text
    case heading
    case math
    case code
    case figure
    case table
    case citation
    case listItem
    case other
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIContentType: FfiConverterRustBuffer {
    typealias SwiftType = FfiContentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiContentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text
        
        case 2: return .heading
        
        case 3: return .math
        
        case 4: return .code
        
        case 5: return .figure
        
        case 6: return .table
        
        case 7: return .citation
        
        case 8: return .listItem
        
        case 9: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiContentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .text:
            writeInt(&buf, Int32(1))
        
        
        case .heading:
            writeInt(&buf, Int32(2))
        
        
        case .math:
            writeInt(&buf, Int32(3))
        
        
        case .code:
            writeInt(&buf, Int32(4))
        
        
        case .figure:
            writeInt(&buf, Int32(5))
        
        
        case .table:
            writeInt(&buf, Int32(6))
        
        
        case .citation:
            writeInt(&buf, Int32(7))
        
        
        case .listItem:
            writeInt(&buf, Int32(8))
        
        
        case .other:
            writeInt(&buf, Int32(9))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIContentType_lift(_ buf: RustBuffer) throws -> FfiContentType {
    return try FfiConverterTypeFFIContentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIContentType_lower(_ value: FfiContentType) -> RustBuffer {
    return FfiConverterTypeFFIContentType.lower(value)
}



extension FfiContentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Page size options for PDF output
 */

public enum FfiPageSize {
    
    /**
     * US Letter (8.5 x 11 inches)
     */
    case letter
    /**
     * A4 (210 x 297 mm)
     */
    case a4
    /**
     * A5 (148 x 210 mm)
     */
    case a5
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIPageSize: FfiConverterRustBuffer {
    typealias SwiftType = FfiPageSize

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPageSize {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .letter
        
        case 2: return .a4
        
        case 3: return .a5
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPageSize, into buf: inout [UInt8]) {
        switch value {
        
        
        case .letter:
            writeInt(&buf, Int32(1))
        
        
        case .a4:
            writeInt(&buf, Int32(2))
        
        
        case .a5:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageSize_lift(_ buf: RustBuffer) throws -> FfiPageSize {
    return try FfiConverterTypeFFIPageSize.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageSize_lower(_ value: FfiPageSize) -> RustBuffer {
    return FfiConverterTypeFFIPageSize.lower(value)
}



extension FfiPageSize: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Schema version for FFI
 */

public enum FfiSchemaVersion {
    
    case v10
    case v11
    case v12
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFISchemaVersion: FfiConverterRustBuffer {
    typealias SwiftType = FfiSchemaVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSchemaVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v10
        
        case 2: return .v11
        
        case 3: return .v12
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSchemaVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v10:
            writeInt(&buf, Int32(1))
        
        
        case .v11:
            writeInt(&buf, Int32(2))
        
        
        case .v12:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISchemaVersion_lift(_ buf: RustBuffer) throws -> FfiSchemaVersion {
    return try FfiConverterTypeFFISchemaVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFISchemaVersion_lower(_ value: FfiSchemaVersion) -> RustBuffer {
    return FfiConverterTypeFFISchemaVersion.lower(value)
}



extension FfiSchemaVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Template category for FFI
 */

public enum FfiTemplateCategory {
    
    case journal
    case conference
    case thesis
    case report
    case custom
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFITemplateCategory: FfiConverterRustBuffer {
    typealias SwiftType = FfiTemplateCategory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTemplateCategory {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .journal
        
        case 2: return .conference
        
        case 3: return .thesis
        
        case 4: return .report
        
        case 5: return .custom
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiTemplateCategory, into buf: inout [UInt8]) {
        switch value {
        
        
        case .journal:
            writeInt(&buf, Int32(1))
        
        
        case .conference:
            writeInt(&buf, Int32(2))
        
        
        case .thesis:
            writeInt(&buf, Int32(3))
        
        
        case .report:
            writeInt(&buf, Int32(4))
        
        
        case .custom:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplateCategory_lift(_ buf: RustBuffer) throws -> FfiTemplateCategory {
    return try FfiConverterTypeFFITemplateCategory.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFITemplateCategory_lower(_ value: FfiTemplateCategory) -> RustBuffer {
    return FfiConverterTypeFFITemplateCategory.lower(value)
}



extension FfiTemplateCategory: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Version check result for FFI
 */

public enum FfiVersionCheckResult {
    
    case current
    case needsMigration(fromVersion: UInt32, toVersion: UInt32
    )
    case newerThanApp(version: UInt32
    )
    case tooOld(version: UInt32
    )
    case unknown(version: UInt32
    )
    case legacy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIVersionCheckResult: FfiConverterRustBuffer {
    typealias SwiftType = FfiVersionCheckResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiVersionCheckResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .current
        
        case 2: return .needsMigration(fromVersion: try FfiConverterUInt32.read(from: &buf), toVersion: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .newerThanApp(version: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 4: return .tooOld(version: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .unknown(version: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 6: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiVersionCheckResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .current:
            writeInt(&buf, Int32(1))
        
        
        case let .needsMigration(fromVersion,toVersion):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(fromVersion, into: &buf)
            FfiConverterUInt32.write(toVersion, into: &buf)
            
        
        case let .newerThanApp(version):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(version, into: &buf)
            
        
        case let .tooOld(version):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(version, into: &buf)
            
        
        case let .unknown(version):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(version, into: &buf)
            
        
        case .legacy:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIVersionCheckResult_lift(_ buf: RustBuffer) throws -> FfiVersionCheckResult {
    return try FfiConverterTypeFFIVersionCheckResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIVersionCheckResult_lower(_ value: FfiVersionCheckResult) -> RustBuffer {
    return FfiConverterTypeFFIVersionCheckResult.lower(value)
}



extension FfiVersionCheckResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported automation commands for imprint
 */

public enum ImprintCommand {
    
    /**
     * Open a document
     */
    case `open`(OpenDocumentCommand
    )
    /**
     * Create a new document
     */
    case new(NewDocumentCommand
    )
    /**
     * Insert a citation
     */
    case insertCitation(InsertCitationCommand
    )
    /**
     * Export document
     */
    case export(ExportCommand
    )
    /**
     * Share document
     */
    case share(ShareCommand
    )
    /**
     * Import notes from imbib
     */
    case importNotes(ImportNotesCommand
    )
    /**
     * Sync with collaborators
     */
    case sync(SyncCommand
    )
    /**
     * Compile document to output format
     */
    case compile(CompileCommand
    )
    /**
     * Set edit mode
     */
    case setEditMode(SetEditModeCommand
    )
    /**
     * Navigate to position
     */
    case navigate(NavigateCommand
    )
    /**
     * Unknown command
     */
    case unknown(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImprintCommand: FfiConverterRustBuffer {
    typealias SwiftType = ImprintCommand

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImprintCommand {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`open`(try FfiConverterTypeOpenDocumentCommand.read(from: &buf)
        )
        
        case 2: return .new(try FfiConverterTypeNewDocumentCommand.read(from: &buf)
        )
        
        case 3: return .insertCitation(try FfiConverterTypeInsertCitationCommand.read(from: &buf)
        )
        
        case 4: return .export(try FfiConverterTypeExportCommand.read(from: &buf)
        )
        
        case 5: return .share(try FfiConverterTypeShareCommand.read(from: &buf)
        )
        
        case 6: return .importNotes(try FfiConverterTypeImportNotesCommand.read(from: &buf)
        )
        
        case 7: return .sync(try FfiConverterTypeSyncCommand.read(from: &buf)
        )
        
        case 8: return .compile(try FfiConverterTypeCompileCommand.read(from: &buf)
        )
        
        case 9: return .setEditMode(try FfiConverterTypeSetEditModeCommand.read(from: &buf)
        )
        
        case 10: return .navigate(try FfiConverterTypeNavigateCommand.read(from: &buf)
        )
        
        case 11: return .unknown(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImprintCommand, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`open`(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOpenDocumentCommand.write(v1, into: &buf)
            
        
        case let .new(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNewDocumentCommand.write(v1, into: &buf)
            
        
        case let .insertCitation(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeInsertCitationCommand.write(v1, into: &buf)
            
        
        case let .export(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExportCommand.write(v1, into: &buf)
            
        
        case let .share(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeShareCommand.write(v1, into: &buf)
            
        
        case let .importNotes(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeImportNotesCommand.write(v1, into: &buf)
            
        
        case let .sync(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSyncCommand.write(v1, into: &buf)
            
        
        case let .compile(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeCompileCommand.write(v1, into: &buf)
            
        
        case let .setEditMode(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeSetEditModeCommand.write(v1, into: &buf)
            
        
        case let .navigate(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeNavigateCommand.write(v1, into: &buf)
            
        
        case let .unknown(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintCommand_lift(_ buf: RustBuffer) throws -> ImprintCommand {
    return try FfiConverterTypeImprintCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintCommand_lower(_ value: ImprintCommand) -> RustBuffer {
    return FfiConverterTypeImprintCommand.lower(value)
}



extension ImprintCommand: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Navigation target types
 */

public enum NavigationTarget {
    
    /**
     * Go to line number
     */
    case line
    /**
     * Go to character offset
     */
    case offset
    /**
     * Go to page (in PDF preview)
     */
    case page
    /**
     * Search for text
     */
    case search
    /**
     * Go to citation
     */
    case citation
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavigationTarget: FfiConverterRustBuffer {
    typealias SwiftType = NavigationTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavigationTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .line
        
        case 2: return .offset
        
        case 3: return .page
        
        case 4: return .search
        
        case 5: return .citation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NavigationTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .line:
            writeInt(&buf, Int32(1))
        
        
        case .offset:
            writeInt(&buf, Int32(2))
        
        
        case .page:
            writeInt(&buf, Int32(3))
        
        
        case .search:
            writeInt(&buf, Int32(4))
        
        
        case .citation:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigationTarget_lift(_ buf: RustBuffer) throws -> NavigationTarget {
    return try FfiConverterTypeNavigationTarget.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigationTarget_lower(_ value: NavigationTarget) -> RustBuffer {
    return FfiConverterTypeNavigationTarget.lower(value)
}



extension NavigationTarget: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Output format for imported notes
 */

public enum NoteOutputFormat {
    
    /**
     * Markdown format (default)
     */
    case markdown
    /**
     * Typst format for direct document insertion
     */
    case typst
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoteOutputFormat: FfiConverterRustBuffer {
    typealias SwiftType = NoteOutputFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoteOutputFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .markdown
        
        case 2: return .typst
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NoteOutputFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .markdown:
            writeInt(&buf, Int32(1))
        
        
        case .typst:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoteOutputFormat_lift(_ buf: RustBuffer) throws -> NoteOutputFormat {
    return try FfiConverterTypeNoteOutputFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoteOutputFormat_lower(_ value: NoteOutputFormat) -> RustBuffer {
    return FfiConverterTypeNoteOutputFormat.lower(value)
}



extension NoteOutputFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Quote style for imported highlights
 */

public enum QuoteStyle {
    
    /**
     * Block quote (> in Markdown, #quote[] in Typst)
     */
    case block
    /**
     * Inline quote
     */
    case inline
    /**
     * Margin note (Typst only, uses #margin-note[])
     */
    case marginNote
    /**
     * Footnote
     */
    case footnote
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQuoteStyle: FfiConverterRustBuffer {
    typealias SwiftType = QuoteStyle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QuoteStyle {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .block
        
        case 2: return .inline
        
        case 3: return .marginNote
        
        case 4: return .footnote
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QuoteStyle, into buf: inout [UInt8]) {
        switch value {
        
        
        case .block:
            writeInt(&buf, Int32(1))
        
        
        case .inline:
            writeInt(&buf, Int32(2))
        
        
        case .marginNote:
            writeInt(&buf, Int32(3))
        
        
        case .footnote:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuoteStyle_lift(_ buf: RustBuffer) throws -> QuoteStyle {
    return try FfiConverterTypeQuoteStyle.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuoteStyle_lower(_ value: QuoteStyle) -> RustBuffer {
    return FfiConverterTypeQuoteStyle.lower(value)
}



extension QuoteStyle: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Share actions
 */

public enum ShareAction {
    
    /**
     * Invite a collaborator
     */
    case invite
    /**
     * Revoke access
     */
    case revoke
    /**
     * List current collaborators
     */
    case list
    /**
     * Generate a shareable link
     */
    case createLink
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShareAction: FfiConverterRustBuffer {
    typealias SwiftType = ShareAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShareAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invite
        
        case 2: return .revoke
        
        case 3: return .list
        
        case 4: return .createLink
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShareAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invite:
            writeInt(&buf, Int32(1))
        
        
        case .revoke:
            writeInt(&buf, Int32(2))
        
        
        case .list:
            writeInt(&buf, Int32(3))
        
        
        case .createLink:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareAction_lift(_ buf: RustBuffer) throws -> ShareAction {
    return try FfiConverterTypeShareAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareAction_lower(_ value: ShareAction) -> RustBuffer {
    return FfiConverterTypeShareAction.lower(value)
}



extension ShareAction: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFFIJournalInfo: FfiConverterRustBuffer {
    typealias SwiftType = FfiJournalInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFFIJournalInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFFIJournalInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFFITemplate: FfiConverterRustBuffer {
    typealias SwiftType = FfiTemplate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFFITemplate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFFITemplate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImprintCommand: FfiConverterRustBuffer {
    typealias SwiftType = ImprintCommand?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImprintCommand.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImprintCommand.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFFISourceMapEntry: FfiConverterRustBuffer {
    typealias SwiftType = [FfiSourceMapEntry]

    public static func write(_ value: [FfiSourceMapEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFISourceMapEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiSourceMapEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiSourceMapEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFFISourceMapEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFFITemplateMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [FfiTemplateMetadata]

    public static func write(_ value: [FfiTemplateMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFFITemplateMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiTemplateMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiTemplateMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFFITemplateMetadata.read(from: &buf))
        }
        return seq
    }
}
public func buildImprintCompileUrl(documentId: String, format: String?, draft: Bool) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_compile_url(
        FfiConverterString.lower(documentId),
        FfiConverterOptionString.lower(format),
        FfiConverterBool.lower(draft),$0
    )
})
}
public func buildImprintExportUrl(documentId: String, format: String, destination: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_export_url(
        FfiConverterString.lower(documentId),
        FfiConverterString.lower(format),
        FfiConverterOptionString.lower(destination),$0
    )
})
}
public func buildImprintImportNotesUrl(documentId: String, publicationId: String, format: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_import_notes_url(
        FfiConverterString.lower(documentId),
        FfiConverterString.lower(publicationId),
        FfiConverterOptionString.lower(format),$0
    )
})
}
public func buildImprintInsertCitationUrl(citeKey: String, documentId: String?, position: UInt64?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_insert_citation_url(
        FfiConverterString.lower(citeKey),
        FfiConverterOptionString.lower(documentId),
        FfiConverterOptionUInt64.lower(position),$0
    )
})
}
public func buildImprintNewUrl(title: String?, template: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_new_url(
        FfiConverterOptionString.lower(title),
        FfiConverterOptionString.lower(template),$0
    )
})
}
public func buildImprintOpenUrl(documentId: String?, path: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_open_url(
        FfiConverterOptionString.lower(documentId),
        FfiConverterOptionString.lower(path),$0
    )
})
}
public func buildImprintShareUrl(documentId: String, action: ShareAction, email: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_share_url(
        FfiConverterString.lower(documentId),
        FfiConverterTypeShareAction.lower(action),
        FfiConverterOptionString.lower(email),$0
    )
})
}
/**
 * Check document version compatibility
 */
public func checkDocumentVersion(rawVersion: UInt32?) -> FfiVersionCheckResult {
    return try!  FfiConverterTypeFFIVersionCheckResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_check_document_version(
        FfiConverterOptionUInt32.lower(rawVersion),$0
    )
})
}
/**
 * Compile Typst source code to PDF
 *
 * This is the main entry point for Swift to compile documents.
 *
 * # Arguments
 * * `source` - Typst source code
 * * `options` - Compilation options (page size, margins, etc.)
 *
 * # Returns
 * A CompileResult containing the PDF data or error information
 */
public func compileTypstToPdf(source: String, options: CompileOptions) -> CompileResult {
    return try!  FfiConverterTypeCompileResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_compile_typst_to_pdf(
        FfiConverterString.lower(source),
        FfiConverterTypeCompileOptions.lower(options),$0
    )
})
}
/**
 * Compile Typst source with default options
 *
 * Convenience function that uses A4 paper with standard margins.
 */
public func compileTypstToPdfDefault(source: String) -> CompileResult {
    return try!  FfiConverterTypeCompileResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_compile_typst_to_pdf_default(
        FfiConverterString.lower(source),$0
    )
})
}
/**
 * Get source map entries for a compiled document
 *
 * This can be called separately if you already have PDF data and just need the source map.
 */
public func generateSourceMap(source: String, options: CompileOptions) -> [FfiSourceMapEntry] {
    return try!  FfiConverterSequenceTypeFFISourceMapEntry.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_generate_source_map(
        FfiConverterString.lower(source),
        FfiConverterTypeCompileOptions.lower(options),$0
    )
})
}
/**
 * Get current schema version
 */
public func getCurrentSchemaVersion() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_current_schema_version($0
    )
})
}
/**
 * Get minimum readable schema version
 */
public func getMinimumSchemaVersion() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_minimum_schema_version($0
    )
})
}
/**
 * Get a template by ID
 */
public func getTemplate(id: String) -> FfiTemplate? {
    return try!  FfiConverterOptionTypeFFITemplate.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_template(
        FfiConverterString.lower(id),$0
    )
})
}
/**
 * Get template source by ID
 */
public func getTemplateSource(id: String) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_template_source(
        FfiConverterString.lower(id),$0
    )
})
}
/**
 * Get the Typst version string
 */
public func getTypstVersion() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_typst_version($0
    )
})
}
/**
 * Hello from imprint-core - verify FFI is working
 */
public func helloFromImprint() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_hello_from_imprint($0
    )
})
}
/**
 * Check if Typst rendering is available
 *
 * Returns true if the library was built with the typst-render feature.
 */
public func isTypstAvailable() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_is_typst_available($0
    )
})
}
/**
 * List all available templates (metadata only)
 */
public func listTemplates() -> [FfiTemplateMetadata] {
    return try!  FfiConverterSequenceTypeFFITemplateMetadata.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_list_templates($0
    )
})
}
/**
 * List templates by category
 */
public func listTemplatesByCategory(category: FfiTemplateCategory) -> [FfiTemplateMetadata] {
    return try!  FfiConverterSequenceTypeFFITemplateMetadata.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_list_templates_by_category(
        FfiConverterTypeFFITemplateCategory.lower(category),$0
    )
})
}
public func parseImprintUrl(urlString: String) -> ParseResult {
    return try!  FfiConverterTypeParseResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_parse_imprint_url(
        FfiConverterString.lower(urlString),$0
    )
})
}
/**
 * Search templates by query string
 */
public func searchTemplates(query: String) -> [FfiTemplateMetadata] {
    return try!  FfiConverterSequenceTypeFFITemplateMetadata.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_search_templates(
        FfiConverterString.lower(query),$0
    )
})
}
/**
 * Look up a click position in the source map to find the corresponding source location
 */
public func sourceMapLookup(entries: [FfiSourceMapEntry], page: UInt32, x: Double, y: Double) -> FfiCursorPosition {
    return try!  FfiConverterTypeFFICursorPosition.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_source_map_lookup(
        FfiConverterSequenceTypeFFISourceMapEntry.lower(entries),
        FfiConverterUInt32.lower(page),
        FfiConverterDouble.lower(x),
        FfiConverterDouble.lower(y),$0
    )
})
}
/**
 * Look up a cursor position in the source to find the corresponding render location
 *
 * This is the reverse of `source_map_lookup` - given a source position, find where
 * it appears in the rendered PDF. Used for cursor synchronization from source to PDF.
 */
public func sourceToRenderLookup(entries: [FfiSourceMapEntry], sourceOffset: UInt64) -> FfiRenderRegion {
    return try!  FfiConverterTypeFFIRenderRegion.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_source_to_render_lookup(
        FfiConverterSequenceTypeFFISourceMapEntry.lower(entries),
        FfiConverterUInt64.lower(sourceOffset),$0
    )
})
}
/**
 * Get the number of available templates
 */
public func templateCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_template_count($0
    )
})
}
/**
 * Validate CRDT data
 */
public func validateCrdtData(data: Data) -> FfiCrdtValidation {
    return try!  FfiConverterTypeFFICrdtValidation.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_validate_crdt_data(
        FfiConverterData.lower(data),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_imprint_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_compile_url() != 25343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_export_url() != 24914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_import_notes_url() != 50902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_insert_citation_url() != 36363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_new_url() != 52823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_open_url() != 41233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_share_url() != 25732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_check_document_version() != 55361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_compile_typst_to_pdf() != 7126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_compile_typst_to_pdf_default() != 53711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_generate_source_map() != 55964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_current_schema_version() != 44451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_minimum_schema_version() != 46146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_template() != 13348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_template_source() != 32300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_typst_version() != 41867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_hello_from_imprint() != 47747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_is_typst_available() != 16186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_list_templates() != 15853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_list_templates_by_category() != 61803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_parse_imprint_url() != 592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_search_templates() != 22769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_source_map_lookup() != 46460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_source_to_render_lookup() != 40270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_template_count() != 14050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_validate_crdt_data() != 34988) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all