// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(imprint_coreFFI)
import imprint_coreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_imprint_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_imprint_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


/**
 * Batch import result for multiple publications
 */
public struct BatchImportResult {
    /**
     * Successfully imported content
     */
    public var content: String
    /**
     * Number of annotations imported
     */
    public var annotationCount: UInt32
    /**
     * Number of publications processed
     */
    public var publicationCount: UInt32
    /**
     * Any warnings during import
     */
    public var warnings: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Successfully imported content
         */content: String, 
        /**
         * Number of annotations imported
         */annotationCount: UInt32, 
        /**
         * Number of publications processed
         */publicationCount: UInt32, 
        /**
         * Any warnings during import
         */warnings: [String]) {
        self.content = content
        self.annotationCount = annotationCount
        self.publicationCount = publicationCount
        self.warnings = warnings
    }
}



extension BatchImportResult: Equatable, Hashable {
    public static func ==(lhs: BatchImportResult, rhs: BatchImportResult) -> Bool {
        if lhs.content != rhs.content {
            return false
        }
        if lhs.annotationCount != rhs.annotationCount {
            return false
        }
        if lhs.publicationCount != rhs.publicationCount {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content)
        hasher.combine(annotationCount)
        hasher.combine(publicationCount)
        hasher.combine(warnings)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBatchImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatchImportResult {
        return
            try BatchImportResult(
                content: FfiConverterString.read(from: &buf), 
                annotationCount: FfiConverterUInt32.read(from: &buf), 
                publicationCount: FfiConverterUInt32.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: BatchImportResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterUInt32.write(value.annotationCount, into: &buf)
        FfiConverterUInt32.write(value.publicationCount, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchImportResult_lift(_ buf: RustBuffer) throws -> BatchImportResult {
    return try FfiConverterTypeBatchImportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchImportResult_lower(_ value: BatchImportResult) -> RustBuffer {
    return FfiConverterTypeBatchImportResult.lower(value)
}


/**
 * Compile document to output
 */
public struct CompileCommand {
    /**
     * Document ID to compile
     */
    public var documentId: String
    /**
     * Output format (pdf, svg, png)
     */
    public var format: String?
    /**
     * Destination path
     */
    public var destination: String?
    /**
     * Draft mode (faster, lower quality)
     */
    public var draft: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to compile
         */documentId: String, 
        /**
         * Output format (pdf, svg, png)
         */format: String?, 
        /**
         * Destination path
         */destination: String?, 
        /**
         * Draft mode (faster, lower quality)
         */draft: Bool) {
        self.documentId = documentId
        self.format = format
        self.destination = destination
        self.draft = draft
    }
}



extension CompileCommand: Equatable, Hashable {
    public static func ==(lhs: CompileCommand, rhs: CompileCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.destination != rhs.destination {
            return false
        }
        if lhs.draft != rhs.draft {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(format)
        hasher.combine(destination)
        hasher.combine(draft)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileCommand {
        return
            try CompileCommand(
                documentId: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionString.read(from: &buf), 
                destination: FfiConverterOptionString.read(from: &buf), 
                draft: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CompileCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterOptionString.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.destination, into: &buf)
        FfiConverterBool.write(value.draft, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileCommand_lift(_ buf: RustBuffer) throws -> CompileCommand {
    return try FfiConverterTypeCompileCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileCommand_lower(_ value: CompileCommand) -> RustBuffer {
    return FfiConverterTypeCompileCommand.lower(value)
}


/**
 * Options for compiling Typst to PDF
 */
public struct CompileOptions {
    /**
     * Page size for the output
     */
    public var pageSize: FfiPageSize
    /**
     * Font size in points (default: 11)
     */
    public var fontSize: Double
    /**
     * Page margins in points (top, right, bottom, left)
     */
    public var marginTop: Double
    public var marginRight: Double
    public var marginBottom: Double
    public var marginLeft: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Page size for the output
         */pageSize: FfiPageSize, 
        /**
         * Font size in points (default: 11)
         */fontSize: Double, 
        /**
         * Page margins in points (top, right, bottom, left)
         */marginTop: Double, marginRight: Double, marginBottom: Double, marginLeft: Double) {
        self.pageSize = pageSize
        self.fontSize = fontSize
        self.marginTop = marginTop
        self.marginRight = marginRight
        self.marginBottom = marginBottom
        self.marginLeft = marginLeft
    }
}



extension CompileOptions: Equatable, Hashable {
    public static func ==(lhs: CompileOptions, rhs: CompileOptions) -> Bool {
        if lhs.pageSize != rhs.pageSize {
            return false
        }
        if lhs.fontSize != rhs.fontSize {
            return false
        }
        if lhs.marginTop != rhs.marginTop {
            return false
        }
        if lhs.marginRight != rhs.marginRight {
            return false
        }
        if lhs.marginBottom != rhs.marginBottom {
            return false
        }
        if lhs.marginLeft != rhs.marginLeft {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pageSize)
        hasher.combine(fontSize)
        hasher.combine(marginTop)
        hasher.combine(marginRight)
        hasher.combine(marginBottom)
        hasher.combine(marginLeft)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileOptions {
        return
            try CompileOptions(
                pageSize: FfiConverterTypeFFIPageSize.read(from: &buf), 
                fontSize: FfiConverterDouble.read(from: &buf), 
                marginTop: FfiConverterDouble.read(from: &buf), 
                marginRight: FfiConverterDouble.read(from: &buf), 
                marginBottom: FfiConverterDouble.read(from: &buf), 
                marginLeft: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: CompileOptions, into buf: inout [UInt8]) {
        FfiConverterTypeFFIPageSize.write(value.pageSize, into: &buf)
        FfiConverterDouble.write(value.fontSize, into: &buf)
        FfiConverterDouble.write(value.marginTop, into: &buf)
        FfiConverterDouble.write(value.marginRight, into: &buf)
        FfiConverterDouble.write(value.marginBottom, into: &buf)
        FfiConverterDouble.write(value.marginLeft, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileOptions_lift(_ buf: RustBuffer) throws -> CompileOptions {
    return try FfiConverterTypeCompileOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileOptions_lower(_ value: CompileOptions) -> RustBuffer {
    return FfiConverterTypeCompileOptions.lower(value)
}


/**
 * Result of compiling a Typst document to PDF
 */
public struct CompileResult {
    /**
     * PDF bytes if compilation succeeded
     */
    public var pdfData: Data?
    /**
     * Error message if compilation failed
     */
    public var error: String?
    /**
     * Warning messages from compilation
     */
    public var warnings: [String]
    /**
     * Number of pages in the output
     */
    public var pageCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * PDF bytes if compilation succeeded
         */pdfData: Data?, 
        /**
         * Error message if compilation failed
         */error: String?, 
        /**
         * Warning messages from compilation
         */warnings: [String], 
        /**
         * Number of pages in the output
         */pageCount: UInt32) {
        self.pdfData = pdfData
        self.error = error
        self.warnings = warnings
        self.pageCount = pageCount
    }
}



extension CompileResult: Equatable, Hashable {
    public static func ==(lhs: CompileResult, rhs: CompileResult) -> Bool {
        if lhs.pdfData != rhs.pdfData {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        if lhs.pageCount != rhs.pageCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pdfData)
        hasher.combine(error)
        hasher.combine(warnings)
        hasher.combine(pageCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompileResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompileResult {
        return
            try CompileResult(
                pdfData: FfiConverterOptionData.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf), 
                pageCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: CompileResult, into buf: inout [UInt8]) {
        FfiConverterOptionData.write(value.pdfData, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
        FfiConverterUInt32.write(value.pageCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileResult_lift(_ buf: RustBuffer) throws -> CompileResult {
    return try FfiConverterTypeCompileResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompileResult_lower(_ value: CompileResult) -> RustBuffer {
    return FfiConverterTypeCompileResult.lower(value)
}


/**
 * Export document to a format
 */
public struct ExportCommand {
    /**
     * Document ID to export
     */
    public var documentId: String
    /**
     * Output format (pdf, latex, docx, html, typst)
     */
    public var format: String
    /**
     * Destination path
     */
    public var destination: String?
    /**
     * Include bibliography file
     */
    public var includeBibliography: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to export
         */documentId: String, 
        /**
         * Output format (pdf, latex, docx, html, typst)
         */format: String, 
        /**
         * Destination path
         */destination: String?, 
        /**
         * Include bibliography file
         */includeBibliography: Bool) {
        self.documentId = documentId
        self.format = format
        self.destination = destination
        self.includeBibliography = includeBibliography
    }
}



extension ExportCommand: Equatable, Hashable {
    public static func ==(lhs: ExportCommand, rhs: ExportCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.destination != rhs.destination {
            return false
        }
        if lhs.includeBibliography != rhs.includeBibliography {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(format)
        hasher.combine(destination)
        hasher.combine(includeBibliography)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExportCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportCommand {
        return
            try ExportCommand(
                documentId: FfiConverterString.read(from: &buf), 
                format: FfiConverterString.read(from: &buf), 
                destination: FfiConverterOptionString.read(from: &buf), 
                includeBibliography: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ExportCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.destination, into: &buf)
        FfiConverterBool.write(value.includeBibliography, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lift(_ buf: RustBuffer) throws -> ExportCommand {
    return try FfiConverterTypeExportCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lower(_ value: ExportCommand) -> RustBuffer {
    return FfiConverterTypeExportCommand.lower(value)
}


/**
 * Import notes from imbib PDF annotations
 */
public struct ImportNotesCommand {
    /**
     * Target document ID
     */
    public var documentId: String
    /**
     * Publication ID in imbib to import from
     */
    public var publicationId: String
    /**
     * Import format (quote, margin_note, inline)
     */
    public var format: String?
    /**
     * Position to insert at
     */
    public var position: UInt64?
    /**
     * Filter by annotation type (highlight, note, all)
     */
    public var annotationType: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Target document ID
         */documentId: String, 
        /**
         * Publication ID in imbib to import from
         */publicationId: String, 
        /**
         * Import format (quote, margin_note, inline)
         */format: String?, 
        /**
         * Position to insert at
         */position: UInt64?, 
        /**
         * Filter by annotation type (highlight, note, all)
         */annotationType: String?) {
        self.documentId = documentId
        self.publicationId = publicationId
        self.format = format
        self.position = position
        self.annotationType = annotationType
    }
}



extension ImportNotesCommand: Equatable, Hashable {
    public static func ==(lhs: ImportNotesCommand, rhs: ImportNotesCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.annotationType != rhs.annotationType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(publicationId)
        hasher.combine(format)
        hasher.combine(position)
        hasher.combine(annotationType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportNotesCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportNotesCommand {
        return
            try ImportNotesCommand(
                documentId: FfiConverterString.read(from: &buf), 
                publicationId: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf), 
                annotationType: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImportNotesCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterOptionString.write(value.format, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
        FfiConverterOptionString.write(value.annotationType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportNotesCommand_lift(_ buf: RustBuffer) throws -> ImportNotesCommand {
    return try FfiConverterTypeImportNotesCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportNotesCommand_lower(_ value: ImportNotesCommand) -> RustBuffer {
    return FfiConverterTypeImportNotesCommand.lower(value)
}


/**
 * Insert a citation into the document
 */
public struct InsertCitationCommand {
    /**
     * Citation key to insert
     */
    public var citeKey: String
    /**
     * Target document ID
     */
    public var documentId: String?
    /**
     * Position to insert at (character offset)
     */
    public var position: UInt64?
    /**
     * BibTeX entry to add to bibliography
     */
    public var bibtex: String?
    /**
     * Publication ID in imbib
     */
    public var publicationId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Citation key to insert
         */citeKey: String, 
        /**
         * Target document ID
         */documentId: String?, 
        /**
         * Position to insert at (character offset)
         */position: UInt64?, 
        /**
         * BibTeX entry to add to bibliography
         */bibtex: String?, 
        /**
         * Publication ID in imbib
         */publicationId: String?) {
        self.citeKey = citeKey
        self.documentId = documentId
        self.position = position
        self.bibtex = bibtex
        self.publicationId = publicationId
    }
}



extension InsertCitationCommand: Equatable, Hashable {
    public static func ==(lhs: InsertCitationCommand, rhs: InsertCitationCommand) -> Bool {
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.bibtex != rhs.bibtex {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citeKey)
        hasher.combine(documentId)
        hasher.combine(position)
        hasher.combine(bibtex)
        hasher.combine(publicationId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInsertCitationCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertCitationCommand {
        return
            try InsertCitationCommand(
                citeKey: FfiConverterString.read(from: &buf), 
                documentId: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf), 
                bibtex: FfiConverterOptionString.read(from: &buf), 
                publicationId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: InsertCitationCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
        FfiConverterOptionString.write(value.bibtex, into: &buf)
        FfiConverterOptionString.write(value.publicationId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lift(_ buf: RustBuffer) throws -> InsertCitationCommand {
    return try FfiConverterTypeInsertCitationCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lower(_ value: InsertCitationCommand) -> RustBuffer {
    return FfiConverterTypeInsertCitationCommand.lower(value)
}


/**
 * Navigate to a position in the document
 */
public struct NavigateCommand {
    /**
     * Document ID
     */
    public var documentId: String?
    /**
     * Position type
     */
    public var positionType: NavigationTarget
    /**
     * Position value (line number, character offset, page number, or search term)
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID
         */documentId: String?, 
        /**
         * Position type
         */positionType: NavigationTarget, 
        /**
         * Position value (line number, character offset, page number, or search term)
         */value: String) {
        self.documentId = documentId
        self.positionType = positionType
        self.value = value
    }
}



extension NavigateCommand: Equatable, Hashable {
    public static func ==(lhs: NavigateCommand, rhs: NavigateCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.positionType != rhs.positionType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(positionType)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavigateCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavigateCommand {
        return
            try NavigateCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                positionType: FfiConverterTypeNavigationTarget.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NavigateCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterTypeNavigationTarget.write(value.positionType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigateCommand_lift(_ buf: RustBuffer) throws -> NavigateCommand {
    return try FfiConverterTypeNavigateCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigateCommand_lower(_ value: NavigateCommand) -> RustBuffer {
    return FfiConverterTypeNavigateCommand.lower(value)
}


/**
 * Create a new document
 */
public struct NewDocumentCommand {
    /**
     * Document title
     */
    public var title: String?
    /**
     * Template to use
     */
    public var template: String?
    /**
     * Initial content
     */
    public var content: String?
    /**
     * Associated manuscript ID (in imbib)
     */
    public var manuscriptId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document title
         */title: String?, 
        /**
         * Template to use
         */template: String?, 
        /**
         * Initial content
         */content: String?, 
        /**
         * Associated manuscript ID (in imbib)
         */manuscriptId: String?) {
        self.title = title
        self.template = template
        self.content = content
        self.manuscriptId = manuscriptId
    }
}



extension NewDocumentCommand: Equatable, Hashable {
    public static func ==(lhs: NewDocumentCommand, rhs: NewDocumentCommand) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.manuscriptId != rhs.manuscriptId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(template)
        hasher.combine(content)
        hasher.combine(manuscriptId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewDocumentCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewDocumentCommand {
        return
            try NewDocumentCommand(
                title: FfiConverterOptionString.read(from: &buf), 
                template: FfiConverterOptionString.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                manuscriptId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NewDocumentCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.manuscriptId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewDocumentCommand_lift(_ buf: RustBuffer) throws -> NewDocumentCommand {
    return try FfiConverterTypeNewDocumentCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewDocumentCommand_lower(_ value: NewDocumentCommand) -> RustBuffer {
    return FfiConverterTypeNewDocumentCommand.lower(value)
}


/**
 * Open a document by ID or path
 */
public struct OpenDocumentCommand {
    /**
     * Document ID (UUID)
     */
    public var documentId: String?
    /**
     * File path
     */
    public var path: String?
    /**
     * Open in specific edit mode
     */
    public var editMode: String?
    /**
     * Navigate to position after opening
     */
    public var position: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID (UUID)
         */documentId: String?, 
        /**
         * File path
         */path: String?, 
        /**
         * Open in specific edit mode
         */editMode: String?, 
        /**
         * Navigate to position after opening
         */position: UInt64?) {
        self.documentId = documentId
        self.path = path
        self.editMode = editMode
        self.position = position
    }
}



extension OpenDocumentCommand: Equatable, Hashable {
    public static func ==(lhs: OpenDocumentCommand, rhs: OpenDocumentCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.editMode != rhs.editMode {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(path)
        hasher.combine(editMode)
        hasher.combine(position)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenDocumentCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenDocumentCommand {
        return
            try OpenDocumentCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf), 
                editMode: FfiConverterOptionString.read(from: &buf), 
                position: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: OpenDocumentCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterOptionString.write(value.editMode, into: &buf)
        FfiConverterOptionUInt64.write(value.position, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenDocumentCommand_lift(_ buf: RustBuffer) throws -> OpenDocumentCommand {
    return try FfiConverterTypeOpenDocumentCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenDocumentCommand_lower(_ value: OpenDocumentCommand) -> RustBuffer {
    return FfiConverterTypeOpenDocumentCommand.lower(value)
}


/**
 * Parse result with command and any errors
 */
public struct ParseResult {
    /**
     * Parsed command (if successful)
     */
    public var command: ImprintCommand?
    /**
     * Error message (if failed)
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Parsed command (if successful)
         */command: ImprintCommand?, 
        /**
         * Error message (if failed)
         */error: String?) {
        self.command = command
        self.error = error
    }
}



extension ParseResult: Equatable, Hashable {
    public static func ==(lhs: ParseResult, rhs: ParseResult) -> Bool {
        if lhs.command != rhs.command {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(command)
        hasher.combine(error)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseResult {
        return
            try ParseResult(
                command: FfiConverterOptionTypeImprintCommand.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParseResult, into buf: inout [UInt8]) {
        FfiConverterOptionTypeImprintCommand.write(value.command, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lift(_ buf: RustBuffer) throws -> ParseResult {
    return try FfiConverterTypeParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lower(_ value: ParseResult) -> RustBuffer {
    return FfiConverterTypeParseResult.lower(value)
}


/**
 * Set the edit mode
 */
public struct SetEditModeCommand {
    /**
     * Document ID
     */
    public var documentId: String?
    /**
     * Mode (direct_pdf, split_view, text_only)
     */
    public var mode: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID
         */documentId: String?, 
        /**
         * Mode (direct_pdf, split_view, text_only)
         */mode: String) {
        self.documentId = documentId
        self.mode = mode
    }
}



extension SetEditModeCommand: Equatable, Hashable {
    public static func ==(lhs: SetEditModeCommand, rhs: SetEditModeCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.mode != rhs.mode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(mode)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetEditModeCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetEditModeCommand {
        return
            try SetEditModeCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                mode: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SetEditModeCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.mode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetEditModeCommand_lift(_ buf: RustBuffer) throws -> SetEditModeCommand {
    return try FfiConverterTypeSetEditModeCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetEditModeCommand_lower(_ value: SetEditModeCommand) -> RustBuffer {
    return FfiConverterTypeSetEditModeCommand.lower(value)
}


/**
 * Share document with collaborators
 */
public struct ShareCommand {
    /**
     * Document ID to share
     */
    public var documentId: String
    /**
     * Share action (invite, revoke, list)
     */
    public var action: ShareAction
    /**
     * Email of collaborator (for invite/revoke)
     */
    public var email: String?
    /**
     * Permission level (view, comment, edit)
     */
    public var permission: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to share
         */documentId: String, 
        /**
         * Share action (invite, revoke, list)
         */action: ShareAction, 
        /**
         * Email of collaborator (for invite/revoke)
         */email: String?, 
        /**
         * Permission level (view, comment, edit)
         */permission: String?) {
        self.documentId = documentId
        self.action = action
        self.email = email
        self.permission = permission
    }
}



extension ShareCommand: Equatable, Hashable {
    public static func ==(lhs: ShareCommand, rhs: ShareCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.permission != rhs.permission {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(action)
        hasher.combine(email)
        hasher.combine(permission)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShareCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShareCommand {
        return
            try ShareCommand(
                documentId: FfiConverterString.read(from: &buf), 
                action: FfiConverterTypeShareAction.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                permission: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ShareCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterTypeShareAction.write(value.action, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.permission, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareCommand_lift(_ buf: RustBuffer) throws -> ShareCommand {
    return try FfiConverterTypeShareCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareCommand_lower(_ value: ShareCommand) -> RustBuffer {
    return FfiConverterTypeShareCommand.lower(value)
}


/**
 * Sync with collaborators
 */
public struct SyncCommand {
    /**
     * Document ID to sync
     */
    public var documentId: String?
    /**
     * Sync all documents
     */
    public var all: Bool
    /**
     * Force full sync (ignore cache)
     */
    public var force: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document ID to sync
         */documentId: String?, 
        /**
         * Sync all documents
         */all: Bool, 
        /**
         * Force full sync (ignore cache)
         */force: Bool) {
        self.documentId = documentId
        self.all = all
        self.force = force
    }
}



extension SyncCommand: Equatable, Hashable {
    public static func ==(lhs: SyncCommand, rhs: SyncCommand) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.all != rhs.all {
            return false
        }
        if lhs.force != rhs.force {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(all)
        hasher.combine(force)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncCommand {
        return
            try SyncCommand(
                documentId: FfiConverterOptionString.read(from: &buf), 
                all: FfiConverterBool.read(from: &buf), 
                force: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SyncCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.documentId, into: &buf)
        FfiConverterBool.write(value.all, into: &buf)
        FfiConverterBool.write(value.force, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncCommand_lift(_ buf: RustBuffer) throws -> SyncCommand {
    return try FfiConverterTypeSyncCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncCommand_lower(_ value: SyncCommand) -> RustBuffer {
    return FfiConverterTypeSyncCommand.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Page size options for PDF output
 */

public enum FfiPageSize {
    
    /**
     * US Letter (8.5 x 11 inches)
     */
    case letter
    /**
     * A4 (210 x 297 mm)
     */
    case a4
    /**
     * A5 (148 x 210 mm)
     */
    case a5
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFFIPageSize: FfiConverterRustBuffer {
    typealias SwiftType = FfiPageSize

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPageSize {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .letter
        
        case 2: return .a4
        
        case 3: return .a5
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPageSize, into buf: inout [UInt8]) {
        switch value {
        
        
        case .letter:
            writeInt(&buf, Int32(1))
        
        
        case .a4:
            writeInt(&buf, Int32(2))
        
        
        case .a5:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageSize_lift(_ buf: RustBuffer) throws -> FfiPageSize {
    return try FfiConverterTypeFFIPageSize.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFFIPageSize_lower(_ value: FfiPageSize) -> RustBuffer {
    return FfiConverterTypeFFIPageSize.lower(value)
}



extension FfiPageSize: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported automation commands for imprint
 */

public enum ImprintCommand {
    
    /**
     * Open a document
     */
    case `open`(OpenDocumentCommand
    )
    /**
     * Create a new document
     */
    case new(NewDocumentCommand
    )
    /**
     * Insert a citation
     */
    case insertCitation(InsertCitationCommand
    )
    /**
     * Export document
     */
    case export(ExportCommand
    )
    /**
     * Share document
     */
    case share(ShareCommand
    )
    /**
     * Import notes from imbib
     */
    case importNotes(ImportNotesCommand
    )
    /**
     * Sync with collaborators
     */
    case sync(SyncCommand
    )
    /**
     * Compile document to output format
     */
    case compile(CompileCommand
    )
    /**
     * Set edit mode
     */
    case setEditMode(SetEditModeCommand
    )
    /**
     * Navigate to position
     */
    case navigate(NavigateCommand
    )
    /**
     * Unknown command
     */
    case unknown(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImprintCommand: FfiConverterRustBuffer {
    typealias SwiftType = ImprintCommand

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImprintCommand {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`open`(try FfiConverterTypeOpenDocumentCommand.read(from: &buf)
        )
        
        case 2: return .new(try FfiConverterTypeNewDocumentCommand.read(from: &buf)
        )
        
        case 3: return .insertCitation(try FfiConverterTypeInsertCitationCommand.read(from: &buf)
        )
        
        case 4: return .export(try FfiConverterTypeExportCommand.read(from: &buf)
        )
        
        case 5: return .share(try FfiConverterTypeShareCommand.read(from: &buf)
        )
        
        case 6: return .importNotes(try FfiConverterTypeImportNotesCommand.read(from: &buf)
        )
        
        case 7: return .sync(try FfiConverterTypeSyncCommand.read(from: &buf)
        )
        
        case 8: return .compile(try FfiConverterTypeCompileCommand.read(from: &buf)
        )
        
        case 9: return .setEditMode(try FfiConverterTypeSetEditModeCommand.read(from: &buf)
        )
        
        case 10: return .navigate(try FfiConverterTypeNavigateCommand.read(from: &buf)
        )
        
        case 11: return .unknown(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImprintCommand, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`open`(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOpenDocumentCommand.write(v1, into: &buf)
            
        
        case let .new(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNewDocumentCommand.write(v1, into: &buf)
            
        
        case let .insertCitation(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeInsertCitationCommand.write(v1, into: &buf)
            
        
        case let .export(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExportCommand.write(v1, into: &buf)
            
        
        case let .share(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeShareCommand.write(v1, into: &buf)
            
        
        case let .importNotes(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeImportNotesCommand.write(v1, into: &buf)
            
        
        case let .sync(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSyncCommand.write(v1, into: &buf)
            
        
        case let .compile(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeCompileCommand.write(v1, into: &buf)
            
        
        case let .setEditMode(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeSetEditModeCommand.write(v1, into: &buf)
            
        
        case let .navigate(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeNavigateCommand.write(v1, into: &buf)
            
        
        case let .unknown(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintCommand_lift(_ buf: RustBuffer) throws -> ImprintCommand {
    return try FfiConverterTypeImprintCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintCommand_lower(_ value: ImprintCommand) -> RustBuffer {
    return FfiConverterTypeImprintCommand.lower(value)
}



extension ImprintCommand: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Navigation target types
 */

public enum NavigationTarget {
    
    /**
     * Go to line number
     */
    case line
    /**
     * Go to character offset
     */
    case offset
    /**
     * Go to page (in PDF preview)
     */
    case page
    /**
     * Search for text
     */
    case search
    /**
     * Go to citation
     */
    case citation
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavigationTarget: FfiConverterRustBuffer {
    typealias SwiftType = NavigationTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavigationTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .line
        
        case 2: return .offset
        
        case 3: return .page
        
        case 4: return .search
        
        case 5: return .citation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NavigationTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .line:
            writeInt(&buf, Int32(1))
        
        
        case .offset:
            writeInt(&buf, Int32(2))
        
        
        case .page:
            writeInt(&buf, Int32(3))
        
        
        case .search:
            writeInt(&buf, Int32(4))
        
        
        case .citation:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigationTarget_lift(_ buf: RustBuffer) throws -> NavigationTarget {
    return try FfiConverterTypeNavigationTarget.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNavigationTarget_lower(_ value: NavigationTarget) -> RustBuffer {
    return FfiConverterTypeNavigationTarget.lower(value)
}



extension NavigationTarget: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Output format for imported notes
 */

public enum NoteOutputFormat {
    
    /**
     * Markdown format (default)
     */
    case markdown
    /**
     * Typst format for direct document insertion
     */
    case typst
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoteOutputFormat: FfiConverterRustBuffer {
    typealias SwiftType = NoteOutputFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoteOutputFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .markdown
        
        case 2: return .typst
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NoteOutputFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .markdown:
            writeInt(&buf, Int32(1))
        
        
        case .typst:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoteOutputFormat_lift(_ buf: RustBuffer) throws -> NoteOutputFormat {
    return try FfiConverterTypeNoteOutputFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoteOutputFormat_lower(_ value: NoteOutputFormat) -> RustBuffer {
    return FfiConverterTypeNoteOutputFormat.lower(value)
}



extension NoteOutputFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Quote style for imported highlights
 */

public enum QuoteStyle {
    
    /**
     * Block quote (> in Markdown, #quote[] in Typst)
     */
    case block
    /**
     * Inline quote
     */
    case inline
    /**
     * Margin note (Typst only, uses #margin-note[])
     */
    case marginNote
    /**
     * Footnote
     */
    case footnote
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQuoteStyle: FfiConverterRustBuffer {
    typealias SwiftType = QuoteStyle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QuoteStyle {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .block
        
        case 2: return .inline
        
        case 3: return .marginNote
        
        case 4: return .footnote
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QuoteStyle, into buf: inout [UInt8]) {
        switch value {
        
        
        case .block:
            writeInt(&buf, Int32(1))
        
        
        case .inline:
            writeInt(&buf, Int32(2))
        
        
        case .marginNote:
            writeInt(&buf, Int32(3))
        
        
        case .footnote:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuoteStyle_lift(_ buf: RustBuffer) throws -> QuoteStyle {
    return try FfiConverterTypeQuoteStyle.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQuoteStyle_lower(_ value: QuoteStyle) -> RustBuffer {
    return FfiConverterTypeQuoteStyle.lower(value)
}



extension QuoteStyle: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Share actions
 */

public enum ShareAction {
    
    /**
     * Invite a collaborator
     */
    case invite
    /**
     * Revoke access
     */
    case revoke
    /**
     * List current collaborators
     */
    case list
    /**
     * Generate a shareable link
     */
    case createLink
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShareAction: FfiConverterRustBuffer {
    typealias SwiftType = ShareAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShareAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invite
        
        case 2: return .revoke
        
        case 3: return .list
        
        case 4: return .createLink
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShareAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invite:
            writeInt(&buf, Int32(1))
        
        
        case .revoke:
            writeInt(&buf, Int32(2))
        
        
        case .list:
            writeInt(&buf, Int32(3))
        
        
        case .createLink:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareAction_lift(_ buf: RustBuffer) throws -> ShareAction {
    return try FfiConverterTypeShareAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShareAction_lower(_ value: ShareAction) -> RustBuffer {
    return FfiConverterTypeShareAction.lower(value)
}



extension ShareAction: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImprintCommand: FfiConverterRustBuffer {
    typealias SwiftType = ImprintCommand?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImprintCommand.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImprintCommand.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}
public func buildImprintCompileUrl(documentId: String, format: String?, draft: Bool) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_compile_url(
        FfiConverterString.lower(documentId),
        FfiConverterOptionString.lower(format),
        FfiConverterBool.lower(draft),$0
    )
})
}
public func buildImprintExportUrl(documentId: String, format: String, destination: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_export_url(
        FfiConverterString.lower(documentId),
        FfiConverterString.lower(format),
        FfiConverterOptionString.lower(destination),$0
    )
})
}
public func buildImprintImportNotesUrl(documentId: String, publicationId: String, format: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_import_notes_url(
        FfiConverterString.lower(documentId),
        FfiConverterString.lower(publicationId),
        FfiConverterOptionString.lower(format),$0
    )
})
}
public func buildImprintInsertCitationUrl(citeKey: String, documentId: String?, position: UInt64?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_insert_citation_url(
        FfiConverterString.lower(citeKey),
        FfiConverterOptionString.lower(documentId),
        FfiConverterOptionUInt64.lower(position),$0
    )
})
}
public func buildImprintNewUrl(title: String?, template: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_new_url(
        FfiConverterOptionString.lower(title),
        FfiConverterOptionString.lower(template),$0
    )
})
}
public func buildImprintOpenUrl(documentId: String?, path: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_open_url(
        FfiConverterOptionString.lower(documentId),
        FfiConverterOptionString.lower(path),$0
    )
})
}
public func buildImprintShareUrl(documentId: String, action: ShareAction, email: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_build_imprint_share_url(
        FfiConverterString.lower(documentId),
        FfiConverterTypeShareAction.lower(action),
        FfiConverterOptionString.lower(email),$0
    )
})
}
/**
 * Compile Typst source code to PDF
 *
 * This is the main entry point for Swift to compile documents.
 *
 * # Arguments
 * * `source` - Typst source code
 * * `options` - Compilation options (page size, margins, etc.)
 *
 * # Returns
 * A CompileResult containing the PDF data or error information
 */
public func compileTypstToPdf(source: String, options: CompileOptions) -> CompileResult {
    return try!  FfiConverterTypeCompileResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_compile_typst_to_pdf(
        FfiConverterString.lower(source),
        FfiConverterTypeCompileOptions.lower(options),$0
    )
})
}
/**
 * Compile Typst source with default options
 *
 * Convenience function that uses A4 paper with standard margins.
 */
public func compileTypstToPdfDefault(source: String) -> CompileResult {
    return try!  FfiConverterTypeCompileResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_compile_typst_to_pdf_default(
        FfiConverterString.lower(source),$0
    )
})
}
/**
 * Get the Typst version string
 */
public func getTypstVersion() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_get_typst_version($0
    )
})
}
/**
 * Hello from imprint-core - verify FFI is working
 */
public func helloFromImprint() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_hello_from_imprint($0
    )
})
}
/**
 * Check if Typst rendering is available
 *
 * Returns true if the library was built with the typst-render feature.
 */
public func isTypstAvailable() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_is_typst_available($0
    )
})
}
public func parseImprintUrl(urlString: String) -> ParseResult {
    return try!  FfiConverterTypeParseResult.lift(try! rustCall() {
    uniffi_imprint_core_fn_func_parse_imprint_url(
        FfiConverterString.lower(urlString),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_imprint_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_compile_url() != 25343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_export_url() != 24914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_import_notes_url() != 50902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_insert_citation_url() != 36363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_new_url() != 52823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_open_url() != 41233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_build_imprint_share_url() != 25732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_compile_typst_to_pdf() != 7126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_compile_typst_to_pdf_default() != 53711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_get_typst_version() != 41867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_hello_from_imprint() != 47747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_is_typst_available() != 16186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imprint_core_checksum_func_parse_imprint_url() != 592) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all