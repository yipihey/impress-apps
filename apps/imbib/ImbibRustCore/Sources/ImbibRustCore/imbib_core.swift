// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(imbib_coreFFI)
import imbib_coreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_imbib_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_imbib_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


/**
 * Item for batch insertion
 */
public struct AnnIndexItem {
    public var publicationId: String
    public var embedding: [Float]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicationId: String, embedding: [Float]) {
        self.publicationId = publicationId
        self.embedding = embedding
    }
}



extension AnnIndexItem: Equatable, Hashable {
    public static func ==(lhs: AnnIndexItem, rhs: AnnIndexItem) -> Bool {
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.embedding != rhs.embedding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicationId)
        hasher.combine(embedding)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnIndexItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnIndexItem {
        return
            try AnnIndexItem(
                publicationId: FfiConverterString.read(from: &buf), 
                embedding: FfiConverterSequenceFloat.read(from: &buf)
        )
    }

    public static func write(_ value: AnnIndexItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterSequenceFloat.write(value.embedding, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnIndexItem_lift(_ buf: RustBuffer) throws -> AnnIndexItem {
    return try FfiConverterTypeAnnIndexItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnIndexItem_lower(_ value: AnnIndexItem) -> RustBuffer {
    return FfiConverterTypeAnnIndexItem.lower(value)
}


/**
 * Result of a similarity search
 */
public struct AnnSimilarityResult {
    public var publicationId: String
    public var similarity: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicationId: String, similarity: Float) {
        self.publicationId = publicationId
        self.similarity = similarity
    }
}



extension AnnSimilarityResult: Equatable, Hashable {
    public static func ==(lhs: AnnSimilarityResult, rhs: AnnSimilarityResult) -> Bool {
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.similarity != rhs.similarity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicationId)
        hasher.combine(similarity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnSimilarityResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnSimilarityResult {
        return
            try AnnSimilarityResult(
                publicationId: FfiConverterString.read(from: &buf), 
                similarity: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: AnnSimilarityResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterFloat.write(value.similarity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnSimilarityResult_lift(_ buf: RustBuffer) throws -> AnnSimilarityResult {
    return try FfiConverterTypeAnnSimilarityResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnSimilarityResult_lower(_ value: AnnSimilarityResult) -> RustBuffer {
    return FfiConverterTypeAnnSimilarityResult.lower(value)
}


/**
 * A single annotation on a PDF page
 */
public struct Annotation {
    public var id: String
    public var publicationId: String
    public var pageNumber: UInt32
    public var annotationType: AnnotationType
    public var rects: [Rect]
    public var color: AnnotationColor
    public var content: String?
    public var selectedText: String?
    public var createdAt: String
    public var modifiedAt: String
    public var author: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, publicationId: String, pageNumber: UInt32, annotationType: AnnotationType, rects: [Rect], color: AnnotationColor, content: String?, selectedText: String?, createdAt: String, modifiedAt: String, author: String?) {
        self.id = id
        self.publicationId = publicationId
        self.pageNumber = pageNumber
        self.annotationType = annotationType
        self.rects = rects
        self.color = color
        self.content = content
        self.selectedText = selectedText
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.author = author
    }
}



extension Annotation: Equatable, Hashable {
    public static func ==(lhs: Annotation, rhs: Annotation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.pageNumber != rhs.pageNumber {
            return false
        }
        if lhs.annotationType != rhs.annotationType {
            return false
        }
        if lhs.rects != rhs.rects {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.selectedText != rhs.selectedText {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(publicationId)
        hasher.combine(pageNumber)
        hasher.combine(annotationType)
        hasher.combine(rects)
        hasher.combine(color)
        hasher.combine(content)
        hasher.combine(selectedText)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
        hasher.combine(author)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Annotation {
        return
            try Annotation(
                id: FfiConverterString.read(from: &buf), 
                publicationId: FfiConverterString.read(from: &buf), 
                pageNumber: FfiConverterUInt32.read(from: &buf), 
                annotationType: FfiConverterTypeAnnotationType.read(from: &buf), 
                rects: FfiConverterSequenceTypeRect.read(from: &buf), 
                color: FfiConverterTypeAnnotationColor.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                selectedText: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                modifiedAt: FfiConverterString.read(from: &buf), 
                author: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Annotation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterUInt32.write(value.pageNumber, into: &buf)
        FfiConverterTypeAnnotationType.write(value.annotationType, into: &buf)
        FfiConverterSequenceTypeRect.write(value.rects, into: &buf)
        FfiConverterTypeAnnotationColor.write(value.color, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.selectedText, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.modifiedAt, into: &buf)
        FfiConverterOptionString.write(value.author, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lift(_ buf: RustBuffer) throws -> Annotation {
    return try FfiConverterTypeAnnotation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotation_lower(_ value: Annotation) -> RustBuffer {
    return FfiConverterTypeAnnotation.lower(value)
}


/**
 * Color in RGBA format
 */
public struct AnnotationColor {
    public var r: UInt8
    public var g: UInt8
    public var b: UInt8
    public var a: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: UInt8, g: UInt8, b: UInt8, a: UInt8) {
        self.r = r
        self.g = g
        self.b = b
        self.a = a
    }
}



extension AnnotationColor: Equatable, Hashable {
    public static func ==(lhs: AnnotationColor, rhs: AnnotationColor) -> Bool {
        if lhs.r != rhs.r {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        if lhs.b != rhs.b {
            return false
        }
        if lhs.a != rhs.a {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(r)
        hasher.combine(g)
        hasher.combine(b)
        hasher.combine(a)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationColor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationColor {
        return
            try AnnotationColor(
                r: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf), 
                b: FfiConverterUInt8.read(from: &buf), 
                a: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: AnnotationColor, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.r, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
        FfiConverterUInt8.write(value.b, into: &buf)
        FfiConverterUInt8.write(value.a, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationColor_lift(_ buf: RustBuffer) throws -> AnnotationColor {
    return try FfiConverterTypeAnnotationColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationColor_lower(_ value: AnnotationColor) -> RustBuffer {
    return FfiConverterTypeAnnotationColor.lower(value)
}


/**
 * Undo/redo stack for annotation operations
 */
public struct AnnotationHistory {
    public var undoStack: [AnnotationOperation]
    public var redoStack: [AnnotationOperation]
    public var maxSize: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(undoStack: [AnnotationOperation], redoStack: [AnnotationOperation], maxSize: UInt32) {
        self.undoStack = undoStack
        self.redoStack = redoStack
        self.maxSize = maxSize
    }
}



extension AnnotationHistory: Equatable, Hashable {
    public static func ==(lhs: AnnotationHistory, rhs: AnnotationHistory) -> Bool {
        if lhs.undoStack != rhs.undoStack {
            return false
        }
        if lhs.redoStack != rhs.redoStack {
            return false
        }
        if lhs.maxSize != rhs.maxSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(undoStack)
        hasher.combine(redoStack)
        hasher.combine(maxSize)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationHistory {
        return
            try AnnotationHistory(
                undoStack: FfiConverterSequenceTypeAnnotationOperation.read(from: &buf), 
                redoStack: FfiConverterSequenceTypeAnnotationOperation.read(from: &buf), 
                maxSize: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: AnnotationHistory, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAnnotationOperation.write(value.undoStack, into: &buf)
        FfiConverterSequenceTypeAnnotationOperation.write(value.redoStack, into: &buf)
        FfiConverterUInt32.write(value.maxSize, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationHistory_lift(_ buf: RustBuffer) throws -> AnnotationHistory {
    return try FfiConverterTypeAnnotationHistory.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationHistory_lower(_ value: AnnotationHistory) -> RustBuffer {
    return FfiConverterTypeAnnotationHistory.lower(value)
}


/**
 * Represents an author of a publication
 */
public struct Author {
    public var id: String
    public var givenName: String?
    public var familyName: String
    public var suffix: String?
    public var orcid: String?
    public var affiliation: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, givenName: String?, familyName: String, suffix: String?, orcid: String?, affiliation: String?) {
        self.id = id
        self.givenName = givenName
        self.familyName = familyName
        self.suffix = suffix
        self.orcid = orcid
        self.affiliation = affiliation
    }
}



extension Author: Equatable, Hashable {
    public static func ==(lhs: Author, rhs: Author) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.givenName != rhs.givenName {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.suffix != rhs.suffix {
            return false
        }
        if lhs.orcid != rhs.orcid {
            return false
        }
        if lhs.affiliation != rhs.affiliation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(givenName)
        hasher.combine(familyName)
        hasher.combine(suffix)
        hasher.combine(orcid)
        hasher.combine(affiliation)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Author {
        return
            try Author(
                id: FfiConverterString.read(from: &buf), 
                givenName: FfiConverterOptionString.read(from: &buf), 
                familyName: FfiConverterString.read(from: &buf), 
                suffix: FfiConverterOptionString.read(from: &buf), 
                orcid: FfiConverterOptionString.read(from: &buf), 
                affiliation: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Author, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.givenName, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterOptionString.write(value.suffix, into: &buf)
        FfiConverterOptionString.write(value.orcid, into: &buf)
        FfiConverterOptionString.write(value.affiliation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthor_lift(_ buf: RustBuffer) throws -> Author {
    return try FfiConverterTypeAuthor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthor_lower(_ value: Author) -> RustBuffer {
    return FfiConverterTypeAuthor.lower(value)
}


/**
 * Author statistics
 */
public struct AuthorStats {
    /**
     * Author ID (source-specific)
     */
    public var authorId: String
    /**
     * Author name
     */
    public var name: String
    /**
     * h-index if available
     */
    public var hIndex: Int32?
    /**
     * Total citation count
     */
    public var citationCount: Int32?
    /**
     * Total paper count
     */
    public var paperCount: Int32?
    /**
     * List of affiliations
     */
    public var affiliations: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Author ID (source-specific)
         */authorId: String, 
        /**
         * Author name
         */name: String, 
        /**
         * h-index if available
         */hIndex: Int32?, 
        /**
         * Total citation count
         */citationCount: Int32?, 
        /**
         * Total paper count
         */paperCount: Int32?, 
        /**
         * List of affiliations
         */affiliations: [String]) {
        self.authorId = authorId
        self.name = name
        self.hIndex = hIndex
        self.citationCount = citationCount
        self.paperCount = paperCount
        self.affiliations = affiliations
    }
}



extension AuthorStats: Equatable, Hashable {
    public static func ==(lhs: AuthorStats, rhs: AuthorStats) -> Bool {
        if lhs.authorId != rhs.authorId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.hIndex != rhs.hIndex {
            return false
        }
        if lhs.citationCount != rhs.citationCount {
            return false
        }
        if lhs.paperCount != rhs.paperCount {
            return false
        }
        if lhs.affiliations != rhs.affiliations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorId)
        hasher.combine(name)
        hasher.combine(hIndex)
        hasher.combine(citationCount)
        hasher.combine(paperCount)
        hasher.combine(affiliations)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorStats {
        return
            try AuthorStats(
                authorId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                hIndex: FfiConverterOptionInt32.read(from: &buf), 
                citationCount: FfiConverterOptionInt32.read(from: &buf), 
                paperCount: FfiConverterOptionInt32.read(from: &buf), 
                affiliations: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorStats, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authorId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionInt32.write(value.hIndex, into: &buf)
        FfiConverterOptionInt32.write(value.citationCount, into: &buf)
        FfiConverterOptionInt32.write(value.paperCount, into: &buf)
        FfiConverterSequenceString.write(value.affiliations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorStats_lift(_ buf: RustBuffer) throws -> AuthorStats {
    return try FfiConverterTypeAuthorStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorStats_lower(_ value: AuthorStats) -> RustBuffer {
    return FfiConverterTypeAuthorStats.lower(value)
}


/**
 * A parsed BibTeX entry
 */
public struct BibTeXEntry {
    public var citeKey: String
    public var entryType: BibTeXEntryType
    public var fields: [BibTeXField]
    public var rawBibtex: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(citeKey: String, entryType: BibTeXEntryType, fields: [BibTeXField], rawBibtex: String?) {
        self.citeKey = citeKey
        self.entryType = entryType
        self.fields = fields
        self.rawBibtex = rawBibtex
    }
}



extension BibTeXEntry: Equatable, Hashable {
    public static func ==(lhs: BibTeXEntry, rhs: BibTeXEntry) -> Bool {
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.entryType != rhs.entryType {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.rawBibtex != rhs.rawBibtex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citeKey)
        hasher.combine(entryType)
        hasher.combine(fields)
        hasher.combine(rawBibtex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXEntry {
        return
            try BibTeXEntry(
                citeKey: FfiConverterString.read(from: &buf), 
                entryType: FfiConverterTypeBibTeXEntryType.read(from: &buf), 
                fields: FfiConverterSequenceTypeBibTeXField.read(from: &buf), 
                rawBibtex: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterTypeBibTeXEntryType.write(value.entryType, into: &buf)
        FfiConverterSequenceTypeBibTeXField.write(value.fields, into: &buf)
        FfiConverterOptionString.write(value.rawBibtex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntry_lift(_ buf: RustBuffer) throws -> BibTeXEntry {
    return try FfiConverterTypeBibTeXEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntry_lower(_ value: BibTeXEntry) -> RustBuffer {
    return FfiConverterTypeBibTeXEntry.lower(value)
}


/**
 * A single BibTeX field (key-value pair)
 */
public struct BibTeXField {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension BibTeXField: Equatable, Hashable {
    public static func ==(lhs: BibTeXField, rhs: BibTeXField) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXField {
        return
            try BibTeXField(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXField, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXField_lift(_ buf: RustBuffer) throws -> BibTeXField {
    return try FfiConverterTypeBibTeXField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXField_lower(_ value: BibTeXField) -> RustBuffer {
    return FfiConverterTypeBibTeXField.lower(value)
}


/**
 * Parse error information
 */
public struct BibTeXParseError {
    public var line: UInt32
    public var column: UInt32
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: UInt32, column: UInt32, message: String) {
        self.line = line
        self.column = column
        self.message = message
    }
}



extension BibTeXParseError: Equatable, Hashable {
    public static func ==(lhs: BibTeXParseError, rhs: BibTeXParseError) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.column != rhs.column {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(column)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXParseError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXParseError {
        return
            try BibTeXParseError(
                line: FfiConverterUInt32.read(from: &buf), 
                column: FfiConverterUInt32.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXParseError, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.line, into: &buf)
        FfiConverterUInt32.write(value.column, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseError_lift(_ buf: RustBuffer) throws -> BibTeXParseError {
    return try FfiConverterTypeBibTeXParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseError_lower(_ value: BibTeXParseError) -> RustBuffer {
    return FfiConverterTypeBibTeXParseError.lower(value)
}


/**
 * Result of parsing a BibTeX file
 */
public struct BibTeXParseResult {
    public var entries: [BibTeXEntry]
    public var preambles: [String]
    public var strings: [String: String]
    public var errors: [BibTeXParseError]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entries: [BibTeXEntry], preambles: [String], strings: [String: String], errors: [BibTeXParseError]) {
        self.entries = entries
        self.preambles = preambles
        self.strings = strings
        self.errors = errors
    }
}



extension BibTeXParseResult: Equatable, Hashable {
    public static func ==(lhs: BibTeXParseResult, rhs: BibTeXParseResult) -> Bool {
        if lhs.entries != rhs.entries {
            return false
        }
        if lhs.preambles != rhs.preambles {
            return false
        }
        if lhs.strings != rhs.strings {
            return false
        }
        if lhs.errors != rhs.errors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entries)
        hasher.combine(preambles)
        hasher.combine(strings)
        hasher.combine(errors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXParseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXParseResult {
        return
            try BibTeXParseResult(
                entries: FfiConverterSequenceTypeBibTeXEntry.read(from: &buf), 
                preambles: FfiConverterSequenceString.read(from: &buf), 
                strings: FfiConverterDictionaryStringString.read(from: &buf), 
                errors: FfiConverterSequenceTypeBibTeXParseError.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXParseResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBibTeXEntry.write(value.entries, into: &buf)
        FfiConverterSequenceString.write(value.preambles, into: &buf)
        FfiConverterDictionaryStringString.write(value.strings, into: &buf)
        FfiConverterSequenceTypeBibTeXParseError.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseResult_lift(_ buf: RustBuffer) throws -> BibTeXParseResult {
    return try FfiConverterTypeBibTeXParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseResult_lower(_ value: BibTeXParseResult) -> RustBuffer {
    return FfiConverterTypeBibTeXParseResult.lower(value)
}


/**
 * Result of validating a format string
 */
public struct CiteKeyFormatValidation {
    /**
     * Whether the format is valid
     */
    public var isValid: Bool
    /**
     * Error message if invalid, empty if valid
     */
    public var errorMessage: String
    /**
     * List of warnings (valid but potentially problematic)
     */
    public var warnings: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the format is valid
         */isValid: Bool, 
        /**
         * Error message if invalid, empty if valid
         */errorMessage: String, 
        /**
         * List of warnings (valid but potentially problematic)
         */warnings: [String]) {
        self.isValid = isValid
        self.errorMessage = errorMessage
        self.warnings = warnings
    }
}



extension CiteKeyFormatValidation: Equatable, Hashable {
    public static func ==(lhs: CiteKeyFormatValidation, rhs: CiteKeyFormatValidation) -> Bool {
        if lhs.isValid != rhs.isValid {
            return false
        }
        if lhs.errorMessage != rhs.errorMessage {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isValid)
        hasher.combine(errorMessage)
        hasher.combine(warnings)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCiteKeyFormatValidation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CiteKeyFormatValidation {
        return
            try CiteKeyFormatValidation(
                isValid: FfiConverterBool.read(from: &buf), 
                errorMessage: FfiConverterString.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: CiteKeyFormatValidation, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isValid, into: &buf)
        FfiConverterString.write(value.errorMessage, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCiteKeyFormatValidation_lift(_ buf: RustBuffer) throws -> CiteKeyFormatValidation {
    return try FfiConverterTypeCiteKeyFormatValidation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCiteKeyFormatValidation_lower(_ value: CiteKeyFormatValidation) -> RustBuffer {
    return FfiConverterTypeCiteKeyFormatValidation.lower(value)
}


/**
 * A collection (folder) for organizing publications
 */
public struct Collection {
    public var id: String
    public var name: String
    public var parentId: String?
    public var isSmart: Bool
    public var smartQuery: String?
    public var createdAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, parentId: String?, isSmart: Bool, smartQuery: String?, createdAt: String?) {
        self.id = id
        self.name = name
        self.parentId = parentId
        self.isSmart = isSmart
        self.smartQuery = smartQuery
        self.createdAt = createdAt
    }
}



extension Collection: Equatable, Hashable {
    public static func ==(lhs: Collection, rhs: Collection) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.parentId != rhs.parentId {
            return false
        }
        if lhs.isSmart != rhs.isSmart {
            return false
        }
        if lhs.smartQuery != rhs.smartQuery {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(parentId)
        hasher.combine(isSmart)
        hasher.combine(smartQuery)
        hasher.combine(createdAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Collection {
        return
            try Collection(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                parentId: FfiConverterOptionString.read(from: &buf), 
                isSmart: FfiConverterBool.read(from: &buf), 
                smartQuery: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Collection, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.parentId, into: &buf)
        FfiConverterBool.write(value.isSmart, into: &buf)
        FfiConverterOptionString.write(value.smartQuery, into: &buf)
        FfiConverterOptionString.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollection_lift(_ buf: RustBuffer) throws -> Collection {
    return try FfiConverterTypeCollection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollection_lower(_ value: Collection) -> RustBuffer {
    return FfiConverterTypeCollection.lower(value)
}


public struct Conflict {
    public var id: String
    public var local: Publication
    public var remote: Publication
    public var base: Publication?
    public var conflictingFields: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, local: Publication, remote: Publication, base: Publication?, conflictingFields: [String]) {
        self.id = id
        self.local = local
        self.remote = remote
        self.base = base
        self.conflictingFields = conflictingFields
    }
}



extension Conflict: Equatable, Hashable {
    public static func ==(lhs: Conflict, rhs: Conflict) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.local != rhs.local {
            return false
        }
        if lhs.remote != rhs.remote {
            return false
        }
        if lhs.base != rhs.base {
            return false
        }
        if lhs.conflictingFields != rhs.conflictingFields {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(local)
        hasher.combine(remote)
        hasher.combine(base)
        hasher.combine(conflictingFields)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConflict: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Conflict {
        return
            try Conflict(
                id: FfiConverterString.read(from: &buf), 
                local: FfiConverterTypePublication.read(from: &buf), 
                remote: FfiConverterTypePublication.read(from: &buf), 
                base: FfiConverterOptionTypePublication.read(from: &buf), 
                conflictingFields: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Conflict, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePublication.write(value.local, into: &buf)
        FfiConverterTypePublication.write(value.remote, into: &buf)
        FfiConverterOptionTypePublication.write(value.base, into: &buf)
        FfiConverterSequenceString.write(value.conflictingFields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConflict_lift(_ buf: RustBuffer) throws -> Conflict {
    return try FfiConverterTypeConflict.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConflict_lower(_ value: Conflict) -> RustBuffer {
    return FfiConverterTypeConflict.lower(value)
}


/**
 * A group of deduplicated search results
 */
public struct DeduplicatedGroup {
    /**
     * Index of the primary result in the original list (highest priority source)
     */
    public var primaryIndex: UInt32
    /**
     * Indices of alternate results (same paper from other sources)
     */
    public var alternateIndices: [UInt32]
    /**
     * Combined identifiers from all results in the group (key: type, value: id)
     */
    public var identifiers: [String: String]
    /**
     * Confidence score for the grouping (1.0 = exact identifier match)
     */
    public var confidence: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Index of the primary result in the original list (highest priority source)
         */primaryIndex: UInt32, 
        /**
         * Indices of alternate results (same paper from other sources)
         */alternateIndices: [UInt32], 
        /**
         * Combined identifiers from all results in the group (key: type, value: id)
         */identifiers: [String: String], 
        /**
         * Confidence score for the grouping (1.0 = exact identifier match)
         */confidence: Double) {
        self.primaryIndex = primaryIndex
        self.alternateIndices = alternateIndices
        self.identifiers = identifiers
        self.confidence = confidence
    }
}



extension DeduplicatedGroup: Equatable, Hashable {
    public static func ==(lhs: DeduplicatedGroup, rhs: DeduplicatedGroup) -> Bool {
        if lhs.primaryIndex != rhs.primaryIndex {
            return false
        }
        if lhs.alternateIndices != rhs.alternateIndices {
            return false
        }
        if lhs.identifiers != rhs.identifiers {
            return false
        }
        if lhs.confidence != rhs.confidence {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryIndex)
        hasher.combine(alternateIndices)
        hasher.combine(identifiers)
        hasher.combine(confidence)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeduplicatedGroup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeduplicatedGroup {
        return
            try DeduplicatedGroup(
                primaryIndex: FfiConverterUInt32.read(from: &buf), 
                alternateIndices: FfiConverterSequenceUInt32.read(from: &buf), 
                identifiers: FfiConverterDictionaryStringString.read(from: &buf), 
                confidence: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: DeduplicatedGroup, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.primaryIndex, into: &buf)
        FfiConverterSequenceUInt32.write(value.alternateIndices, into: &buf)
        FfiConverterDictionaryStringString.write(value.identifiers, into: &buf)
        FfiConverterDouble.write(value.confidence, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicatedGroup_lift(_ buf: RustBuffer) throws -> DeduplicatedGroup {
    return try FfiConverterTypeDeduplicatedGroup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicatedGroup_lower(_ value: DeduplicatedGroup) -> RustBuffer {
    return FfiConverterTypeDeduplicatedGroup.lower(value)
}


/**
 * Configuration for deduplication
 */
public struct DeduplicationConfig {
    /**
     * Minimum title similarity threshold (0.0 - 1.0)
     */
    public var titleThreshold: Double
    /**
     * Whether to use fuzzy matching when no identifier match
     */
    public var useFuzzyMatching: Bool
    /**
     * Source priority order (lower index = higher priority)
     */
    public var sourcePriority: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Minimum title similarity threshold (0.0 - 1.0)
         */titleThreshold: Double, 
        /**
         * Whether to use fuzzy matching when no identifier match
         */useFuzzyMatching: Bool, 
        /**
         * Source priority order (lower index = higher priority)
         */sourcePriority: [String]) {
        self.titleThreshold = titleThreshold
        self.useFuzzyMatching = useFuzzyMatching
        self.sourcePriority = sourcePriority
    }
}



extension DeduplicationConfig: Equatable, Hashable {
    public static func ==(lhs: DeduplicationConfig, rhs: DeduplicationConfig) -> Bool {
        if lhs.titleThreshold != rhs.titleThreshold {
            return false
        }
        if lhs.useFuzzyMatching != rhs.useFuzzyMatching {
            return false
        }
        if lhs.sourcePriority != rhs.sourcePriority {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(titleThreshold)
        hasher.combine(useFuzzyMatching)
        hasher.combine(sourcePriority)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeduplicationConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeduplicationConfig {
        return
            try DeduplicationConfig(
                titleThreshold: FfiConverterDouble.read(from: &buf), 
                useFuzzyMatching: FfiConverterBool.read(from: &buf), 
                sourcePriority: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: DeduplicationConfig, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.titleThreshold, into: &buf)
        FfiConverterBool.write(value.useFuzzyMatching, into: &buf)
        FfiConverterSequenceString.write(value.sourcePriority, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationConfig_lift(_ buf: RustBuffer) throws -> DeduplicationConfig {
    return try FfiConverterTypeDeduplicationConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationConfig_lower(_ value: DeduplicationConfig) -> RustBuffer {
    return FfiConverterTypeDeduplicationConfig.lower(value)
}


/**
 * A simplified search result for deduplication
 * (avoids importing the full SearchResult type)
 */
public struct DeduplicationInput {
    /**
     * Unique identifier for this result
     */
    public var id: String
    /**
     * Source ID (e.g., "arxiv", "crossref")
     */
    public var sourceId: String
    /**
     * Paper title
     */
    public var title: String
    /**
     * First author's last name (for fuzzy matching)
     */
    public var firstAuthorLastName: String?
    /**
     * Publication year
     */
    public var year: Int32?
    /**
     * DOI if available
     */
    public var doi: String?
    /**
     * arXiv ID if available
     */
    public var arxivId: String?
    /**
     * PubMed ID if available
     */
    public var pmid: String?
    /**
     * ADS bibcode if available
     */
    public var bibcode: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for this result
         */id: String, 
        /**
         * Source ID (e.g., "arxiv", "crossref")
         */sourceId: String, 
        /**
         * Paper title
         */title: String, 
        /**
         * First author's last name (for fuzzy matching)
         */firstAuthorLastName: String?, 
        /**
         * Publication year
         */year: Int32?, 
        /**
         * DOI if available
         */doi: String?, 
        /**
         * arXiv ID if available
         */arxivId: String?, 
        /**
         * PubMed ID if available
         */pmid: String?, 
        /**
         * ADS bibcode if available
         */bibcode: String?) {
        self.id = id
        self.sourceId = sourceId
        self.title = title
        self.firstAuthorLastName = firstAuthorLastName
        self.year = year
        self.doi = doi
        self.arxivId = arxivId
        self.pmid = pmid
        self.bibcode = bibcode
    }
}



extension DeduplicationInput: Equatable, Hashable {
    public static func ==(lhs: DeduplicationInput, rhs: DeduplicationInput) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sourceId != rhs.sourceId {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.firstAuthorLastName != rhs.firstAuthorLastName {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        if lhs.pmid != rhs.pmid {
            return false
        }
        if lhs.bibcode != rhs.bibcode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sourceId)
        hasher.combine(title)
        hasher.combine(firstAuthorLastName)
        hasher.combine(year)
        hasher.combine(doi)
        hasher.combine(arxivId)
        hasher.combine(pmid)
        hasher.combine(bibcode)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeduplicationInput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeduplicationInput {
        return
            try DeduplicationInput(
                id: FfiConverterString.read(from: &buf), 
                sourceId: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                firstAuthorLastName: FfiConverterOptionString.read(from: &buf), 
                year: FfiConverterOptionInt32.read(from: &buf), 
                doi: FfiConverterOptionString.read(from: &buf), 
                arxivId: FfiConverterOptionString.read(from: &buf), 
                pmid: FfiConverterOptionString.read(from: &buf), 
                bibcode: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DeduplicationInput, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.sourceId, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.firstAuthorLastName, into: &buf)
        FfiConverterOptionInt32.write(value.year, into: &buf)
        FfiConverterOptionString.write(value.doi, into: &buf)
        FfiConverterOptionString.write(value.arxivId, into: &buf)
        FfiConverterOptionString.write(value.pmid, into: &buf)
        FfiConverterOptionString.write(value.bibcode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationInput_lift(_ buf: RustBuffer) throws -> DeduplicationInput {
    return try FfiConverterTypeDeduplicationInput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationInput_lower(_ value: DeduplicationInput) -> RustBuffer {
    return FfiConverterTypeDeduplicationInput.lower(value)
}


/**
 * Result of a deduplication comparison
 */
public struct DeduplicationMatch {
    /**
     * Overall similarity score (0.0 to 1.0)
     */
    public var score: Double
    /**
     * Human-readable explanation of why entries match
     */
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Overall similarity score (0.0 to 1.0)
         */score: Double, 
        /**
         * Human-readable explanation of why entries match
         */reason: String) {
        self.score = score
        self.reason = reason
    }
}



extension DeduplicationMatch: Equatable, Hashable {
    public static func ==(lhs: DeduplicationMatch, rhs: DeduplicationMatch) -> Bool {
        if lhs.score != rhs.score {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(score)
        hasher.combine(reason)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeduplicationMatch: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeduplicationMatch {
        return
            try DeduplicationMatch(
                score: FfiConverterDouble.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeduplicationMatch, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.score, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationMatch_lift(_ buf: RustBuffer) throws -> DeduplicationMatch {
    return try FfiConverterTypeDeduplicationMatch.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationMatch_lower(_ value: DeduplicationMatch) -> RustBuffer {
    return FfiConverterTypeDeduplicationMatch.lower(value)
}


/**
 * Drawing annotation (multiple strokes)
 */
public struct DrawingAnnotation {
    public var id: String
    public var publicationId: String
    public var pageNumber: UInt32
    public var strokes: [DrawingStroke]
    public var createdAt: String
    public var modifiedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, publicationId: String, pageNumber: UInt32, strokes: [DrawingStroke], createdAt: String, modifiedAt: String) {
        self.id = id
        self.publicationId = publicationId
        self.pageNumber = pageNumber
        self.strokes = strokes
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }
}



extension DrawingAnnotation: Equatable, Hashable {
    public static func ==(lhs: DrawingAnnotation, rhs: DrawingAnnotation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.pageNumber != rhs.pageNumber {
            return false
        }
        if lhs.strokes != rhs.strokes {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(publicationId)
        hasher.combine(pageNumber)
        hasher.combine(strokes)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDrawingAnnotation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DrawingAnnotation {
        return
            try DrawingAnnotation(
                id: FfiConverterString.read(from: &buf), 
                publicationId: FfiConverterString.read(from: &buf), 
                pageNumber: FfiConverterUInt32.read(from: &buf), 
                strokes: FfiConverterSequenceTypeDrawingStroke.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                modifiedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DrawingAnnotation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterUInt32.write(value.pageNumber, into: &buf)
        FfiConverterSequenceTypeDrawingStroke.write(value.strokes, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrawingAnnotation_lift(_ buf: RustBuffer) throws -> DrawingAnnotation {
    return try FfiConverterTypeDrawingAnnotation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrawingAnnotation_lower(_ value: DrawingAnnotation) -> RustBuffer {
    return FfiConverterTypeDrawingAnnotation.lower(value)
}


/**
 * Drawing stroke for freehand annotations
 */
public struct DrawingStroke {
    public var points: [Point]
    public var color: AnnotationColor
    public var width: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(points: [Point], color: AnnotationColor, width: Float) {
        self.points = points
        self.color = color
        self.width = width
    }
}



extension DrawingStroke: Equatable, Hashable {
    public static func ==(lhs: DrawingStroke, rhs: DrawingStroke) -> Bool {
        if lhs.points != rhs.points {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(points)
        hasher.combine(color)
        hasher.combine(width)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDrawingStroke: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DrawingStroke {
        return
            try DrawingStroke(
                points: FfiConverterSequenceTypePoint.read(from: &buf), 
                color: FfiConverterTypeAnnotationColor.read(from: &buf), 
                width: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: DrawingStroke, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePoint.write(value.points, into: &buf)
        FfiConverterTypeAnnotationColor.write(value.color, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrawingStroke_lift(_ buf: RustBuffer) throws -> DrawingStroke {
    return try FfiConverterTypeDrawingStroke.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrawingStroke_lower(_ value: DrawingStroke) -> RustBuffer {
    return FfiConverterTypeDrawingStroke.lower(value)
}


/**
 * A group of duplicate publications
 */
public struct DuplicateGroup {
    public var publicationIds: [String]
    public var confidence: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicationIds: [String], confidence: Double) {
        self.publicationIds = publicationIds
        self.confidence = confidence
    }
}



extension DuplicateGroup: Equatable, Hashable {
    public static func ==(lhs: DuplicateGroup, rhs: DuplicateGroup) -> Bool {
        if lhs.publicationIds != rhs.publicationIds {
            return false
        }
        if lhs.confidence != rhs.confidence {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicationIds)
        hasher.combine(confidence)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDuplicateGroup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DuplicateGroup {
        return
            try DuplicateGroup(
                publicationIds: FfiConverterSequenceString.read(from: &buf), 
                confidence: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: DuplicateGroup, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.publicationIds, into: &buf)
        FfiConverterDouble.write(value.confidence, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDuplicateGroup_lift(_ buf: RustBuffer) throws -> DuplicateGroup {
    return try FfiConverterTypeDuplicateGroup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDuplicateGroup_lower(_ value: DuplicateGroup) -> RustBuffer {
    return FfiConverterTypeDuplicateGroup.lower(value)
}


/**
 * Enrichment data for a publication
 */
public struct EnrichmentData {
    /**
     * Citation count
     */
    public var citationCount: Int32?
    /**
     * Reference count
     */
    public var referenceCount: Int32?
    /**
     * Abstract text
     */
    public var abstractText: String?
    /**
     * PDF download URLs
     */
    public var pdfUrls: [String]
    /**
     * Open access status
     */
    public var openAccessStatus: OpenAccessStatus
    /**
     * Venue (journal/conference)
     */
    public var venue: String?
    /**
     * Source that provided this data
     */
    public var source: String
    /**
     * Unix timestamp when data was fetched
     */
    public var fetchedAtUnix: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Citation count
         */citationCount: Int32?, 
        /**
         * Reference count
         */referenceCount: Int32?, 
        /**
         * Abstract text
         */abstractText: String?, 
        /**
         * PDF download URLs
         */pdfUrls: [String], 
        /**
         * Open access status
         */openAccessStatus: OpenAccessStatus, 
        /**
         * Venue (journal/conference)
         */venue: String?, 
        /**
         * Source that provided this data
         */source: String, 
        /**
         * Unix timestamp when data was fetched
         */fetchedAtUnix: Int64) {
        self.citationCount = citationCount
        self.referenceCount = referenceCount
        self.abstractText = abstractText
        self.pdfUrls = pdfUrls
        self.openAccessStatus = openAccessStatus
        self.venue = venue
        self.source = source
        self.fetchedAtUnix = fetchedAtUnix
    }
}



extension EnrichmentData: Equatable, Hashable {
    public static func ==(lhs: EnrichmentData, rhs: EnrichmentData) -> Bool {
        if lhs.citationCount != rhs.citationCount {
            return false
        }
        if lhs.referenceCount != rhs.referenceCount {
            return false
        }
        if lhs.abstractText != rhs.abstractText {
            return false
        }
        if lhs.pdfUrls != rhs.pdfUrls {
            return false
        }
        if lhs.openAccessStatus != rhs.openAccessStatus {
            return false
        }
        if lhs.venue != rhs.venue {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.fetchedAtUnix != rhs.fetchedAtUnix {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citationCount)
        hasher.combine(referenceCount)
        hasher.combine(abstractText)
        hasher.combine(pdfUrls)
        hasher.combine(openAccessStatus)
        hasher.combine(venue)
        hasher.combine(source)
        hasher.combine(fetchedAtUnix)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnrichmentData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnrichmentData {
        return
            try EnrichmentData(
                citationCount: FfiConverterOptionInt32.read(from: &buf), 
                referenceCount: FfiConverterOptionInt32.read(from: &buf), 
                abstractText: FfiConverterOptionString.read(from: &buf), 
                pdfUrls: FfiConverterSequenceString.read(from: &buf), 
                openAccessStatus: FfiConverterTypeOpenAccessStatus.read(from: &buf), 
                venue: FfiConverterOptionString.read(from: &buf), 
                source: FfiConverterString.read(from: &buf), 
                fetchedAtUnix: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: EnrichmentData, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.citationCount, into: &buf)
        FfiConverterOptionInt32.write(value.referenceCount, into: &buf)
        FfiConverterOptionString.write(value.abstractText, into: &buf)
        FfiConverterSequenceString.write(value.pdfUrls, into: &buf)
        FfiConverterTypeOpenAccessStatus.write(value.openAccessStatus, into: &buf)
        FfiConverterOptionString.write(value.venue, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterInt64.write(value.fetchedAtUnix, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentData_lift(_ buf: RustBuffer) throws -> EnrichmentData {
    return try FfiConverterTypeEnrichmentData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentData_lower(_ value: EnrichmentData) -> RustBuffer {
    return FfiConverterTypeEnrichmentData.lower(value)
}


public struct ExportCommand {
    public var format: String
    public var citeKeys: [String]
    public var library: String?
    public var destination: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: String, citeKeys: [String], library: String?, destination: String?) {
        self.format = format
        self.citeKeys = citeKeys
        self.library = library
        self.destination = destination
    }
}



extension ExportCommand: Equatable, Hashable {
    public static func ==(lhs: ExportCommand, rhs: ExportCommand) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.citeKeys != rhs.citeKeys {
            return false
        }
        if lhs.library != rhs.library {
            return false
        }
        if lhs.destination != rhs.destination {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(citeKeys)
        hasher.combine(library)
        hasher.combine(destination)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExportCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportCommand {
        return
            try ExportCommand(
                format: FfiConverterString.read(from: &buf), 
                citeKeys: FfiConverterSequenceString.read(from: &buf), 
                library: FfiConverterOptionString.read(from: &buf), 
                destination: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ExportCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.format, into: &buf)
        FfiConverterSequenceString.write(value.citeKeys, into: &buf)
        FfiConverterOptionString.write(value.library, into: &buf)
        FfiConverterOptionString.write(value.destination, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lift(_ buf: RustBuffer) throws -> ExportCommand {
    return try FfiConverterTypeExportCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportCommand_lower(_ value: ExportCommand) -> RustBuffer {
    return FfiConverterTypeExportCommand.lower(value)
}


/**
 * Options for export
 */
public struct ExportOptions {
    public var includeAbstract: Bool
    public var includeKeywords: Bool
    public var includeExtraFields: Bool
    public var sortFields: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(includeAbstract: Bool, includeKeywords: Bool, includeExtraFields: Bool, sortFields: Bool) {
        self.includeAbstract = includeAbstract
        self.includeKeywords = includeKeywords
        self.includeExtraFields = includeExtraFields
        self.sortFields = sortFields
    }
}



extension ExportOptions: Equatable, Hashable {
    public static func ==(lhs: ExportOptions, rhs: ExportOptions) -> Bool {
        if lhs.includeAbstract != rhs.includeAbstract {
            return false
        }
        if lhs.includeKeywords != rhs.includeKeywords {
            return false
        }
        if lhs.includeExtraFields != rhs.includeExtraFields {
            return false
        }
        if lhs.sortFields != rhs.sortFields {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(includeAbstract)
        hasher.combine(includeKeywords)
        hasher.combine(includeExtraFields)
        hasher.combine(sortFields)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExportOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportOptions {
        return
            try ExportOptions(
                includeAbstract: FfiConverterBool.read(from: &buf), 
                includeKeywords: FfiConverterBool.read(from: &buf), 
                includeExtraFields: FfiConverterBool.read(from: &buf), 
                sortFields: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ExportOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.includeAbstract, into: &buf)
        FfiConverterBool.write(value.includeKeywords, into: &buf)
        FfiConverterBool.write(value.includeExtraFields, into: &buf)
        FfiConverterBool.write(value.sortFields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportOptions_lift(_ buf: RustBuffer) throws -> ExportOptions {
    return try FfiConverterTypeExportOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportOptions_lower(_ value: ExportOptions) -> RustBuffer {
    return FfiConverterTypeExportOptions.lower(value)
}


/**
 * Extracted identifier with position information
 */
public struct ExtractedIdentifier {
    public var identifierType: String
    public var value: String
    public var startIndex: UInt32
    public var endIndex: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifierType: String, value: String, startIndex: UInt32, endIndex: UInt32) {
        self.identifierType = identifierType
        self.value = value
        self.startIndex = startIndex
        self.endIndex = endIndex
    }
}



extension ExtractedIdentifier: Equatable, Hashable {
    public static func ==(lhs: ExtractedIdentifier, rhs: ExtractedIdentifier) -> Bool {
        if lhs.identifierType != rhs.identifierType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.startIndex != rhs.startIndex {
            return false
        }
        if lhs.endIndex != rhs.endIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifierType)
        hasher.combine(value)
        hasher.combine(startIndex)
        hasher.combine(endIndex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtractedIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtractedIdentifier {
        return
            try ExtractedIdentifier(
                identifierType: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                startIndex: FfiConverterUInt32.read(from: &buf), 
                endIndex: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ExtractedIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifierType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterUInt32.write(value.startIndex, into: &buf)
        FfiConverterUInt32.write(value.endIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractedIdentifier_lift(_ buf: RustBuffer) throws -> ExtractedIdentifier {
    return try FfiConverterTypeExtractedIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractedIdentifier_lower(_ value: ExtractedIdentifier) -> RustBuffer {
    return FfiConverterTypeExtractedIdentifier.lower(value)
}


/**
 * Options for filename generation
 */
public struct FilenameOptions {
    public var maxLength: UInt32
    public var includeYear: Bool
    public var titleWords: UInt32
    public var separator: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxLength: UInt32, includeYear: Bool, titleWords: UInt32, separator: String) {
        self.maxLength = maxLength
        self.includeYear = includeYear
        self.titleWords = titleWords
        self.separator = separator
    }
}



extension FilenameOptions: Equatable, Hashable {
    public static func ==(lhs: FilenameOptions, rhs: FilenameOptions) -> Bool {
        if lhs.maxLength != rhs.maxLength {
            return false
        }
        if lhs.includeYear != rhs.includeYear {
            return false
        }
        if lhs.titleWords != rhs.titleWords {
            return false
        }
        if lhs.separator != rhs.separator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxLength)
        hasher.combine(includeYear)
        hasher.combine(titleWords)
        hasher.combine(separator)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFilenameOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilenameOptions {
        return
            try FilenameOptions(
                maxLength: FfiConverterUInt32.read(from: &buf), 
                includeYear: FfiConverterBool.read(from: &buf), 
                titleWords: FfiConverterUInt32.read(from: &buf), 
                separator: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FilenameOptions, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.maxLength, into: &buf)
        FfiConverterBool.write(value.includeYear, into: &buf)
        FfiConverterUInt32.write(value.titleWords, into: &buf)
        FfiConverterString.write(value.separator, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilenameOptions_lift(_ buf: RustBuffer) throws -> FilenameOptions {
    return try FfiConverterTypeFilenameOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilenameOptions_lower(_ value: FilenameOptions) -> RustBuffer {
    return FfiConverterTypeFilenameOptions.lower(value)
}


/**
 * A help document to be indexed
 */
public struct HelpDocument {
    /**
     * Unique document identifier (e.g., "features/siri-shortcuts")
     */
    public var id: String
    /**
     * Document title
     */
    public var title: String
    /**
     * Document body/content (markdown)
     */
    public var body: String
    /**
     * Search keywords
     */
    public var keywords: [String]
    /**
     * Target platform
     */
    public var platform: HelpPlatform
    /**
     * Category for grouping
     */
    public var category: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique document identifier (e.g., "features/siri-shortcuts")
         */id: String, 
        /**
         * Document title
         */title: String, 
        /**
         * Document body/content (markdown)
         */body: String, 
        /**
         * Search keywords
         */keywords: [String], 
        /**
         * Target platform
         */platform: HelpPlatform, 
        /**
         * Category for grouping
         */category: String) {
        self.id = id
        self.title = title
        self.body = body
        self.keywords = keywords
        self.platform = platform
        self.category = category
    }
}



extension HelpDocument: Equatable, Hashable {
    public static func ==(lhs: HelpDocument, rhs: HelpDocument) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        if lhs.keywords != rhs.keywords {
            return false
        }
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(body)
        hasher.combine(keywords)
        hasher.combine(platform)
        hasher.combine(category)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHelpDocument: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HelpDocument {
        return
            try HelpDocument(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                body: FfiConverterString.read(from: &buf), 
                keywords: FfiConverterSequenceString.read(from: &buf), 
                platform: FfiConverterTypeHelpPlatform.read(from: &buf), 
                category: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: HelpDocument, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterSequenceString.write(value.keywords, into: &buf)
        FfiConverterTypeHelpPlatform.write(value.platform, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpDocument_lift(_ buf: RustBuffer) throws -> HelpDocument {
    return try FfiConverterTypeHelpDocument.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpDocument_lower(_ value: HelpDocument) -> RustBuffer {
    return FfiConverterTypeHelpDocument.lower(value)
}


/**
 * A search result from the help index
 */
public struct HelpSearchResult {
    /**
     * Document identifier
     */
    public var id: String
    /**
     * Document title
     */
    public var title: String
    /**
     * Snippet with highlighted terms (using <mark> tags)
     */
    public var snippet: String
    /**
     * Relevance score (0.0 to 1.0)
     */
    public var relevanceScore: Float
    /**
     * Target platform
     */
    public var platform: HelpPlatform
    /**
     * Category
     */
    public var category: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Document identifier
         */id: String, 
        /**
         * Document title
         */title: String, 
        /**
         * Snippet with highlighted terms (using <mark> tags)
         */snippet: String, 
        /**
         * Relevance score (0.0 to 1.0)
         */relevanceScore: Float, 
        /**
         * Target platform
         */platform: HelpPlatform, 
        /**
         * Category
         */category: String) {
        self.id = id
        self.title = title
        self.snippet = snippet
        self.relevanceScore = relevanceScore
        self.platform = platform
        self.category = category
    }
}



extension HelpSearchResult: Equatable, Hashable {
    public static func ==(lhs: HelpSearchResult, rhs: HelpSearchResult) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.snippet != rhs.snippet {
            return false
        }
        if lhs.relevanceScore != rhs.relevanceScore {
            return false
        }
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(snippet)
        hasher.combine(relevanceScore)
        hasher.combine(platform)
        hasher.combine(category)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHelpSearchResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HelpSearchResult {
        return
            try HelpSearchResult(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                snippet: FfiConverterString.read(from: &buf), 
                relevanceScore: FfiConverterFloat.read(from: &buf), 
                platform: FfiConverterTypeHelpPlatform.read(from: &buf), 
                category: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: HelpSearchResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.snippet, into: &buf)
        FfiConverterFloat.write(value.relevanceScore, into: &buf)
        FfiConverterTypeHelpPlatform.write(value.platform, into: &buf)
        FfiConverterString.write(value.category, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpSearchResult_lift(_ buf: RustBuffer) throws -> HelpSearchResult {
    return try FfiConverterTypeHelpSearchResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpSearchResult_lower(_ value: HelpSearchResult) -> RustBuffer {
    return FfiConverterTypeHelpSearchResult.lower(value)
}


/**
 * Collection of publication identifiers
 */
public struct Identifiers {
    public var doi: String?
    public var arxivId: String?
    public var pmid: String?
    public var pmcid: String?
    public var bibcode: String?
    public var isbn: String?
    public var issn: String?
    public var orcid: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(doi: String?, arxivId: String?, pmid: String?, pmcid: String?, bibcode: String?, isbn: String?, issn: String?, orcid: String?) {
        self.doi = doi
        self.arxivId = arxivId
        self.pmid = pmid
        self.pmcid = pmcid
        self.bibcode = bibcode
        self.isbn = isbn
        self.issn = issn
        self.orcid = orcid
    }
}



extension Identifiers: Equatable, Hashable {
    public static func ==(lhs: Identifiers, rhs: Identifiers) -> Bool {
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        if lhs.pmid != rhs.pmid {
            return false
        }
        if lhs.pmcid != rhs.pmcid {
            return false
        }
        if lhs.bibcode != rhs.bibcode {
            return false
        }
        if lhs.isbn != rhs.isbn {
            return false
        }
        if lhs.issn != rhs.issn {
            return false
        }
        if lhs.orcid != rhs.orcid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(doi)
        hasher.combine(arxivId)
        hasher.combine(pmid)
        hasher.combine(pmcid)
        hasher.combine(bibcode)
        hasher.combine(isbn)
        hasher.combine(issn)
        hasher.combine(orcid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identifiers {
        return
            try Identifiers(
                doi: FfiConverterOptionString.read(from: &buf), 
                arxivId: FfiConverterOptionString.read(from: &buf), 
                pmid: FfiConverterOptionString.read(from: &buf), 
                pmcid: FfiConverterOptionString.read(from: &buf), 
                bibcode: FfiConverterOptionString.read(from: &buf), 
                isbn: FfiConverterOptionString.read(from: &buf), 
                issn: FfiConverterOptionString.read(from: &buf), 
                orcid: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Identifiers, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.doi, into: &buf)
        FfiConverterOptionString.write(value.arxivId, into: &buf)
        FfiConverterOptionString.write(value.pmid, into: &buf)
        FfiConverterOptionString.write(value.pmcid, into: &buf)
        FfiConverterOptionString.write(value.bibcode, into: &buf)
        FfiConverterOptionString.write(value.isbn, into: &buf)
        FfiConverterOptionString.write(value.issn, into: &buf)
        FfiConverterOptionString.write(value.orcid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifiers_lift(_ buf: RustBuffer) throws -> Identifiers {
    return try FfiConverterTypeIdentifiers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifiers_lower(_ value: Identifiers) -> RustBuffer {
    return FfiConverterTypeIdentifiers.lower(value)
}


public struct ImportCommand {
    public var url: String?
    public var content: String?
    public var format: String?
    public var library: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String?, content: String?, format: String?, library: String?) {
        self.url = url
        self.content = content
        self.format = format
        self.library = library
    }
}



extension ImportCommand: Equatable, Hashable {
    public static func ==(lhs: ImportCommand, rhs: ImportCommand) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.library != rhs.library {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(content)
        hasher.combine(format)
        hasher.combine(library)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportCommand {
        return
            try ImportCommand(
                url: FfiConverterOptionString.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                format: FfiConverterOptionString.read(from: &buf), 
                library: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImportCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.library, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportCommand_lift(_ buf: RustBuffer) throws -> ImportCommand {
    return try FfiConverterTypeImportCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportCommand_lower(_ value: ImportCommand) -> RustBuffer {
    return FfiConverterTypeImportCommand.lower(value)
}


/**
 * Result of an import operation
 */
public struct ImportResult {
    public var publications: [Publication]
    public var warnings: [String]
    public var errors: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publications: [Publication], warnings: [String], errors: [String]) {
        self.publications = publications
        self.warnings = warnings
        self.errors = errors
    }
}



extension ImportResult: Equatable, Hashable {
    public static func ==(lhs: ImportResult, rhs: ImportResult) -> Bool {
        if lhs.publications != rhs.publications {
            return false
        }
        if lhs.warnings != rhs.warnings {
            return false
        }
        if lhs.errors != rhs.errors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publications)
        hasher.combine(warnings)
        hasher.combine(errors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportResult {
        return
            try ImportResult(
                publications: FfiConverterSequenceTypePublication.read(from: &buf), 
                warnings: FfiConverterSequenceString.read(from: &buf), 
                errors: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ImportResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublication.write(value.publications, into: &buf)
        FfiConverterSequenceString.write(value.warnings, into: &buf)
        FfiConverterSequenceString.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportResult_lift(_ buf: RustBuffer) throws -> ImportResult {
    return try FfiConverterTypeImportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportResult_lower(_ value: ImportResult) -> RustBuffer {
    return FfiConverterTypeImportResult.lower(value)
}


public struct InsertCitationCommand {
    public var citeKey: String
    public var imprintDocumentId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(citeKey: String, imprintDocumentId: String?) {
        self.citeKey = citeKey
        self.imprintDocumentId = imprintDocumentId
    }
}



extension InsertCitationCommand: Equatable, Hashable {
    public static func ==(lhs: InsertCitationCommand, rhs: InsertCitationCommand) -> Bool {
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.imprintDocumentId != rhs.imprintDocumentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citeKey)
        hasher.combine(imprintDocumentId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInsertCitationCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertCitationCommand {
        return
            try InsertCitationCommand(
                citeKey: FfiConverterString.read(from: &buf), 
                imprintDocumentId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: InsertCitationCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterOptionString.write(value.imprintDocumentId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lift(_ buf: RustBuffer) throws -> InsertCitationCommand {
    return try FfiConverterTypeInsertCitationCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertCitationCommand_lower(_ value: InsertCitationCommand) -> RustBuffer {
    return FfiConverterTypeInsertCitationCommand.lower(value)
}


/**
 * A library (collection of publications, typically from a .bib file)
 */
public struct Library {
    public var id: String
    public var name: String
    public var filePath: String?
    public var isDefault: Bool
    public var createdAt: String?
    public var modifiedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, filePath: String?, isDefault: Bool, createdAt: String?, modifiedAt: String?) {
        self.id = id
        self.name = name
        self.filePath = filePath
        self.isDefault = isDefault
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }
}



extension Library: Equatable, Hashable {
    public static func ==(lhs: Library, rhs: Library) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.filePath != rhs.filePath {
            return false
        }
        if lhs.isDefault != rhs.isDefault {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(filePath)
        hasher.combine(isDefault)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLibrary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Library {
        return
            try Library(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                filePath: FfiConverterOptionString.read(from: &buf), 
                isDefault: FfiConverterBool.read(from: &buf), 
                createdAt: FfiConverterOptionString.read(from: &buf), 
                modifiedAt: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Library, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.filePath, into: &buf)
        FfiConverterBool.write(value.isDefault, into: &buf)
        FfiConverterOptionString.write(value.createdAt, into: &buf)
        FfiConverterOptionString.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibrary_lift(_ buf: RustBuffer) throws -> Library {
    return try FfiConverterTypeLibrary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibrary_lower(_ value: Library) -> RustBuffer {
    return FfiConverterTypeLibrary.lower(value)
}


public struct LibraryCommand {
    public var action: String
    public var name: String?
    public var path: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(action: String, name: String?, path: String?) {
        self.action = action
        self.name = name
        self.path = path
    }
}



extension LibraryCommand: Equatable, Hashable {
    public static func ==(lhs: LibraryCommand, rhs: LibraryCommand) -> Bool {
        if lhs.action != rhs.action {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(action)
        hasher.combine(name)
        hasher.combine(path)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLibraryCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LibraryCommand {
        return
            try LibraryCommand(
                action: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LibraryCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.action, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibraryCommand_lift(_ buf: RustBuffer) throws -> LibraryCommand {
    return try FfiConverterTypeLibraryCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibraryCommand_lower(_ value: LibraryCommand) -> RustBuffer {
    return FfiConverterTypeLibraryCommand.lower(value)
}


/**
 * A file linked to a publication (PDF, supplementary material, etc.)
 */
public struct LinkedFile {
    public var id: String
    public var filename: String
    public var relativePath: String?
    public var absoluteUrl: String?
    public var storageType: FileStorageType
    public var mimeType: String?
    public var fileSize: Int64?
    public var checksum: String?
    public var addedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, filename: String, relativePath: String?, absoluteUrl: String?, storageType: FileStorageType, mimeType: String?, fileSize: Int64?, checksum: String?, addedAt: String?) {
        self.id = id
        self.filename = filename
        self.relativePath = relativePath
        self.absoluteUrl = absoluteUrl
        self.storageType = storageType
        self.mimeType = mimeType
        self.fileSize = fileSize
        self.checksum = checksum
        self.addedAt = addedAt
    }
}



extension LinkedFile: Equatable, Hashable {
    public static func ==(lhs: LinkedFile, rhs: LinkedFile) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.relativePath != rhs.relativePath {
            return false
        }
        if lhs.absoluteUrl != rhs.absoluteUrl {
            return false
        }
        if lhs.storageType != rhs.storageType {
            return false
        }
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.fileSize != rhs.fileSize {
            return false
        }
        if lhs.checksum != rhs.checksum {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(filename)
        hasher.combine(relativePath)
        hasher.combine(absoluteUrl)
        hasher.combine(storageType)
        hasher.combine(mimeType)
        hasher.combine(fileSize)
        hasher.combine(checksum)
        hasher.combine(addedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLinkedFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkedFile {
        return
            try LinkedFile(
                id: FfiConverterString.read(from: &buf), 
                filename: FfiConverterString.read(from: &buf), 
                relativePath: FfiConverterOptionString.read(from: &buf), 
                absoluteUrl: FfiConverterOptionString.read(from: &buf), 
                storageType: FfiConverterTypeFileStorageType.read(from: &buf), 
                mimeType: FfiConverterOptionString.read(from: &buf), 
                fileSize: FfiConverterOptionInt64.read(from: &buf), 
                checksum: FfiConverterOptionString.read(from: &buf), 
                addedAt: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LinkedFile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.relativePath, into: &buf)
        FfiConverterOptionString.write(value.absoluteUrl, into: &buf)
        FfiConverterTypeFileStorageType.write(value.storageType, into: &buf)
        FfiConverterOptionString.write(value.mimeType, into: &buf)
        FfiConverterOptionInt64.write(value.fileSize, into: &buf)
        FfiConverterOptionString.write(value.checksum, into: &buf)
        FfiConverterOptionString.write(value.addedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkedFile_lift(_ buf: RustBuffer) throws -> LinkedFile {
    return try FfiConverterTypeLinkedFile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkedFile_lower(_ value: LinkedFile) -> RustBuffer {
    return FfiConverterTypeLinkedFile.lower(value)
}


public struct LookupCommand {
    public var doi: String?
    public var arxivId: String?
    public var bibcode: String?
    public var title: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(doi: String?, arxivId: String?, bibcode: String?, title: String?) {
        self.doi = doi
        self.arxivId = arxivId
        self.bibcode = bibcode
        self.title = title
    }
}



extension LookupCommand: Equatable, Hashable {
    public static func ==(lhs: LookupCommand, rhs: LookupCommand) -> Bool {
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        if lhs.bibcode != rhs.bibcode {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(doi)
        hasher.combine(arxivId)
        hasher.combine(bibcode)
        hasher.combine(title)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLookupCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupCommand {
        return
            try LookupCommand(
                doi: FfiConverterOptionString.read(from: &buf), 
                arxivId: FfiConverterOptionString.read(from: &buf), 
                bibcode: FfiConverterOptionString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.doi, into: &buf)
        FfiConverterOptionString.write(value.arxivId, into: &buf)
        FfiConverterOptionString.write(value.bibcode, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupCommand_lift(_ buf: RustBuffer) throws -> LookupCommand {
    return try FfiConverterTypeLookupCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupCommand_lower(_ value: LookupCommand) -> RustBuffer {
    return FfiConverterTypeLookupCommand.lower(value)
}


public struct MergeResult {
    public var merged: Publication
    public var strategyUsed: MergeStrategy
    public var fieldsFromLocal: [String]
    public var fieldsFromRemote: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(merged: Publication, strategyUsed: MergeStrategy, fieldsFromLocal: [String], fieldsFromRemote: [String]) {
        self.merged = merged
        self.strategyUsed = strategyUsed
        self.fieldsFromLocal = fieldsFromLocal
        self.fieldsFromRemote = fieldsFromRemote
    }
}



extension MergeResult: Equatable, Hashable {
    public static func ==(lhs: MergeResult, rhs: MergeResult) -> Bool {
        if lhs.merged != rhs.merged {
            return false
        }
        if lhs.strategyUsed != rhs.strategyUsed {
            return false
        }
        if lhs.fieldsFromLocal != rhs.fieldsFromLocal {
            return false
        }
        if lhs.fieldsFromRemote != rhs.fieldsFromRemote {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(merged)
        hasher.combine(strategyUsed)
        hasher.combine(fieldsFromLocal)
        hasher.combine(fieldsFromRemote)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMergeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MergeResult {
        return
            try MergeResult(
                merged: FfiConverterTypePublication.read(from: &buf), 
                strategyUsed: FfiConverterTypeMergeStrategy.read(from: &buf), 
                fieldsFromLocal: FfiConverterSequenceString.read(from: &buf), 
                fieldsFromRemote: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MergeResult, into buf: inout [UInt8]) {
        FfiConverterTypePublication.write(value.merged, into: &buf)
        FfiConverterTypeMergeStrategy.write(value.strategyUsed, into: &buf)
        FfiConverterSequenceString.write(value.fieldsFromLocal, into: &buf)
        FfiConverterSequenceString.write(value.fieldsFromRemote, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMergeResult_lift(_ buf: RustBuffer) throws -> MergeResult {
    return try FfiConverterTypeMergeResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMergeResult_lower(_ value: MergeResult) -> RustBuffer {
    return FfiConverterTypeMergeResult.lower(value)
}


public struct OpenCommand {
    public var doi: String?
    public var arxivId: String?
    public var bibcode: String?
    public var citeKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(doi: String?, arxivId: String?, bibcode: String?, citeKey: String?) {
        self.doi = doi
        self.arxivId = arxivId
        self.bibcode = bibcode
        self.citeKey = citeKey
    }
}



extension OpenCommand: Equatable, Hashable {
    public static func ==(lhs: OpenCommand, rhs: OpenCommand) -> Bool {
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        if lhs.bibcode != rhs.bibcode {
            return false
        }
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(doi)
        hasher.combine(arxivId)
        hasher.combine(bibcode)
        hasher.combine(citeKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenCommand {
        return
            try OpenCommand(
                doi: FfiConverterOptionString.read(from: &buf), 
                arxivId: FfiConverterOptionString.read(from: &buf), 
                bibcode: FfiConverterOptionString.read(from: &buf), 
                citeKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: OpenCommand, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.doi, into: &buf)
        FfiConverterOptionString.write(value.arxivId, into: &buf)
        FfiConverterOptionString.write(value.bibcode, into: &buf)
        FfiConverterOptionString.write(value.citeKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenCommand_lift(_ buf: RustBuffer) throws -> OpenCommand {
    return try FfiConverterTypeOpenCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenCommand_lower(_ value: OpenCommand) -> RustBuffer {
    return FfiConverterTypeOpenCommand.lower(value)
}


public struct OpenManuscriptCommand {
    public var manuscriptId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manuscriptId: String) {
        self.manuscriptId = manuscriptId
    }
}



extension OpenManuscriptCommand: Equatable, Hashable {
    public static func ==(lhs: OpenManuscriptCommand, rhs: OpenManuscriptCommand) -> Bool {
        if lhs.manuscriptId != rhs.manuscriptId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manuscriptId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenManuscriptCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenManuscriptCommand {
        return
            try OpenManuscriptCommand(
                manuscriptId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OpenManuscriptCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.manuscriptId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenManuscriptCommand_lift(_ buf: RustBuffer) throws -> OpenManuscriptCommand {
    return try FfiConverterTypeOpenManuscriptCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenManuscriptCommand_lower(_ value: OpenManuscriptCommand) -> RustBuffer {
    return FfiConverterTypeOpenManuscriptCommand.lower(value)
}


/**
 * Get page dimensions
 */
public struct PageDimensions {
    public var width: Float
    public var height: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(width: Float, height: Float) {
        self.width = width
        self.height = height
    }
}



extension PageDimensions: Equatable, Hashable {
    public static func ==(lhs: PageDimensions, rhs: PageDimensions) -> Bool {
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(width)
        hasher.combine(height)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageDimensions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageDimensions {
        return
            try PageDimensions(
                width: FfiConverterFloat.read(from: &buf), 
                height: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: PageDimensions, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageDimensions_lift(_ buf: RustBuffer) throws -> PageDimensions {
    return try FfiConverterTypePageDimensions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageDimensions_lower(_ value: PageDimensions) -> RustBuffer {
    return FfiConverterTypePageDimensions.lower(value)
}


public struct PageText {
    public var pageNumber: UInt32
    public var text: String
    public var charCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pageNumber: UInt32, text: String, charCount: UInt32) {
        self.pageNumber = pageNumber
        self.text = text
        self.charCount = charCount
    }
}



extension PageText: Equatable, Hashable {
    public static func ==(lhs: PageText, rhs: PageText) -> Bool {
        if lhs.pageNumber != rhs.pageNumber {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.charCount != rhs.charCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pageNumber)
        hasher.combine(text)
        hasher.combine(charCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePageText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PageText {
        return
            try PageText(
                pageNumber: FfiConverterUInt32.read(from: &buf), 
                text: FfiConverterString.read(from: &buf), 
                charCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PageText, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.pageNumber, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterUInt32.write(value.charCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageText_lift(_ buf: RustBuffer) throws -> PageText {
    return try FfiConverterTypePageText.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePageText_lower(_ value: PageText) -> RustBuffer {
    return FfiConverterTypePageText.lower(value)
}


/**
 * Paper stub for references/citations
 */
public struct PaperStub {
    public var id: String
    public var title: String
    public var authors: [String]
    public var year: Int32?
    public var venue: String?
    public var doi: String?
    public var arxivId: String?
    public var citationCount: Int32?
    public var referenceCount: Int32?
    public var isOpenAccess: Bool
    public var abstractText: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, title: String, authors: [String], year: Int32?, venue: String?, doi: String?, arxivId: String?, citationCount: Int32?, referenceCount: Int32?, isOpenAccess: Bool, abstractText: String?) {
        self.id = id
        self.title = title
        self.authors = authors
        self.year = year
        self.venue = venue
        self.doi = doi
        self.arxivId = arxivId
        self.citationCount = citationCount
        self.referenceCount = referenceCount
        self.isOpenAccess = isOpenAccess
        self.abstractText = abstractText
    }
}



extension PaperStub: Equatable, Hashable {
    public static func ==(lhs: PaperStub, rhs: PaperStub) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.authors != rhs.authors {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        if lhs.venue != rhs.venue {
            return false
        }
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        if lhs.citationCount != rhs.citationCount {
            return false
        }
        if lhs.referenceCount != rhs.referenceCount {
            return false
        }
        if lhs.isOpenAccess != rhs.isOpenAccess {
            return false
        }
        if lhs.abstractText != rhs.abstractText {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(authors)
        hasher.combine(year)
        hasher.combine(venue)
        hasher.combine(doi)
        hasher.combine(arxivId)
        hasher.combine(citationCount)
        hasher.combine(referenceCount)
        hasher.combine(isOpenAccess)
        hasher.combine(abstractText)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaperStub: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaperStub {
        return
            try PaperStub(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                authors: FfiConverterSequenceString.read(from: &buf), 
                year: FfiConverterOptionInt32.read(from: &buf), 
                venue: FfiConverterOptionString.read(from: &buf), 
                doi: FfiConverterOptionString.read(from: &buf), 
                arxivId: FfiConverterOptionString.read(from: &buf), 
                citationCount: FfiConverterOptionInt32.read(from: &buf), 
                referenceCount: FfiConverterOptionInt32.read(from: &buf), 
                isOpenAccess: FfiConverterBool.read(from: &buf), 
                abstractText: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaperStub, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterSequenceString.write(value.authors, into: &buf)
        FfiConverterOptionInt32.write(value.year, into: &buf)
        FfiConverterOptionString.write(value.venue, into: &buf)
        FfiConverterOptionString.write(value.doi, into: &buf)
        FfiConverterOptionString.write(value.arxivId, into: &buf)
        FfiConverterOptionInt32.write(value.citationCount, into: &buf)
        FfiConverterOptionInt32.write(value.referenceCount, into: &buf)
        FfiConverterBool.write(value.isOpenAccess, into: &buf)
        FfiConverterOptionString.write(value.abstractText, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaperStub_lift(_ buf: RustBuffer) throws -> PaperStub {
    return try FfiConverterTypePaperStub.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaperStub_lower(_ value: PaperStub) -> RustBuffer {
    return FfiConverterTypePaperStub.lower(value)
}


/**
 * Parse result with command and any errors
 */
public struct ParseResult {
    public var command: AutomationCommand?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(command: AutomationCommand?, error: String?) {
        self.command = command
        self.error = error
    }
}



extension ParseResult: Equatable, Hashable {
    public static func ==(lhs: ParseResult, rhs: ParseResult) -> Bool {
        if lhs.command != rhs.command {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(command)
        hasher.combine(error)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseResult {
        return
            try ParseResult(
                command: FfiConverterOptionTypeAutomationCommand.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParseResult, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAutomationCommand.write(value.command, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lift(_ buf: RustBuffer) throws -> ParseResult {
    return try FfiConverterTypeParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lower(_ value: ParseResult) -> RustBuffer {
    return FfiConverterTypeParseResult.lower(value)
}


/**
 * Parsed arXiv form state
 */
public struct ParsedArXivForm {
    public var searchTerms: [ParsedArXivTerm]
    public var categories: [String]
    public var dateFrom: String?
    public var dateTo: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(searchTerms: [ParsedArXivTerm], categories: [String], dateFrom: String?, dateTo: String?) {
        self.searchTerms = searchTerms
        self.categories = categories
        self.dateFrom = dateFrom
        self.dateTo = dateTo
    }
}



extension ParsedArXivForm: Equatable, Hashable {
    public static func ==(lhs: ParsedArXivForm, rhs: ParsedArXivForm) -> Bool {
        if lhs.searchTerms != rhs.searchTerms {
            return false
        }
        if lhs.categories != rhs.categories {
            return false
        }
        if lhs.dateFrom != rhs.dateFrom {
            return false
        }
        if lhs.dateTo != rhs.dateTo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(searchTerms)
        hasher.combine(categories)
        hasher.combine(dateFrom)
        hasher.combine(dateTo)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedArXivForm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedArXivForm {
        return
            try ParsedArXivForm(
                searchTerms: FfiConverterSequenceTypeParsedArXivTerm.read(from: &buf), 
                categories: FfiConverterSequenceString.read(from: &buf), 
                dateFrom: FfiConverterOptionString.read(from: &buf), 
                dateTo: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParsedArXivForm, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeParsedArXivTerm.write(value.searchTerms, into: &buf)
        FfiConverterSequenceString.write(value.categories, into: &buf)
        FfiConverterOptionString.write(value.dateFrom, into: &buf)
        FfiConverterOptionString.write(value.dateTo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedArXivForm_lift(_ buf: RustBuffer) throws -> ParsedArXivForm {
    return try FfiConverterTypeParsedArXivForm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedArXivForm_lower(_ value: ParsedArXivForm) -> RustBuffer {
    return FfiConverterTypeParsedArXivForm.lower(value)
}


public struct ParsedArXivTerm {
    public var term: String
    public var field: String
    public var logic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(term: String, field: String, logic: String) {
        self.term = term
        self.field = field
        self.logic = logic
    }
}



extension ParsedArXivTerm: Equatable, Hashable {
    public static func ==(lhs: ParsedArXivTerm, rhs: ParsedArXivTerm) -> Bool {
        if lhs.term != rhs.term {
            return false
        }
        if lhs.field != rhs.field {
            return false
        }
        if lhs.logic != rhs.logic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(term)
        hasher.combine(field)
        hasher.combine(logic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedArXivTerm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedArXivTerm {
        return
            try ParsedArXivTerm(
                term: FfiConverterString.read(from: &buf), 
                field: FfiConverterString.read(from: &buf), 
                logic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ParsedArXivTerm, into buf: inout [UInt8]) {
        FfiConverterString.write(value.term, into: &buf)
        FfiConverterString.write(value.field, into: &buf)
        FfiConverterString.write(value.logic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedArXivTerm_lift(_ buf: RustBuffer) throws -> ParsedArXivTerm {
    return try FfiConverterTypeParsedArXivTerm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedArXivTerm_lower(_ value: ParsedArXivTerm) -> RustBuffer {
    return FfiConverterTypeParsedArXivTerm.lower(value)
}


/**
 * Parsed ADS Classic form state
 */
public struct ParsedClassicForm {
    public var authors: String
    public var objects: String
    public var titleWords: String
    public var titleLogic: QueryLogic
    public var abstractWords: String
    public var abstractLogic: QueryLogic
    public var yearFrom: Int32?
    public var yearTo: Int32?
    public var database: AdsDatabase
    public var refereedOnly: Bool
    public var articlesOnly: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authors: String, objects: String, titleWords: String, titleLogic: QueryLogic, abstractWords: String, abstractLogic: QueryLogic, yearFrom: Int32?, yearTo: Int32?, database: AdsDatabase, refereedOnly: Bool, articlesOnly: Bool) {
        self.authors = authors
        self.objects = objects
        self.titleWords = titleWords
        self.titleLogic = titleLogic
        self.abstractWords = abstractWords
        self.abstractLogic = abstractLogic
        self.yearFrom = yearFrom
        self.yearTo = yearTo
        self.database = database
        self.refereedOnly = refereedOnly
        self.articlesOnly = articlesOnly
    }
}



extension ParsedClassicForm: Equatable, Hashable {
    public static func ==(lhs: ParsedClassicForm, rhs: ParsedClassicForm) -> Bool {
        if lhs.authors != rhs.authors {
            return false
        }
        if lhs.objects != rhs.objects {
            return false
        }
        if lhs.titleWords != rhs.titleWords {
            return false
        }
        if lhs.titleLogic != rhs.titleLogic {
            return false
        }
        if lhs.abstractWords != rhs.abstractWords {
            return false
        }
        if lhs.abstractLogic != rhs.abstractLogic {
            return false
        }
        if lhs.yearFrom != rhs.yearFrom {
            return false
        }
        if lhs.yearTo != rhs.yearTo {
            return false
        }
        if lhs.database != rhs.database {
            return false
        }
        if lhs.refereedOnly != rhs.refereedOnly {
            return false
        }
        if lhs.articlesOnly != rhs.articlesOnly {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authors)
        hasher.combine(objects)
        hasher.combine(titleWords)
        hasher.combine(titleLogic)
        hasher.combine(abstractWords)
        hasher.combine(abstractLogic)
        hasher.combine(yearFrom)
        hasher.combine(yearTo)
        hasher.combine(database)
        hasher.combine(refereedOnly)
        hasher.combine(articlesOnly)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedClassicForm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedClassicForm {
        return
            try ParsedClassicForm(
                authors: FfiConverterString.read(from: &buf), 
                objects: FfiConverterString.read(from: &buf), 
                titleWords: FfiConverterString.read(from: &buf), 
                titleLogic: FfiConverterTypeQueryLogic.read(from: &buf), 
                abstractWords: FfiConverterString.read(from: &buf), 
                abstractLogic: FfiConverterTypeQueryLogic.read(from: &buf), 
                yearFrom: FfiConverterOptionInt32.read(from: &buf), 
                yearTo: FfiConverterOptionInt32.read(from: &buf), 
                database: FfiConverterTypeADSDatabase.read(from: &buf), 
                refereedOnly: FfiConverterBool.read(from: &buf), 
                articlesOnly: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ParsedClassicForm, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authors, into: &buf)
        FfiConverterString.write(value.objects, into: &buf)
        FfiConverterString.write(value.titleWords, into: &buf)
        FfiConverterTypeQueryLogic.write(value.titleLogic, into: &buf)
        FfiConverterString.write(value.abstractWords, into: &buf)
        FfiConverterTypeQueryLogic.write(value.abstractLogic, into: &buf)
        FfiConverterOptionInt32.write(value.yearFrom, into: &buf)
        FfiConverterOptionInt32.write(value.yearTo, into: &buf)
        FfiConverterTypeADSDatabase.write(value.database, into: &buf)
        FfiConverterBool.write(value.refereedOnly, into: &buf)
        FfiConverterBool.write(value.articlesOnly, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedClassicForm_lift(_ buf: RustBuffer) throws -> ParsedClassicForm {
    return try FfiConverterTypeParsedClassicForm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedClassicForm_lower(_ value: ParsedClassicForm) -> RustBuffer {
    return FfiConverterTypeParsedClassicForm.lower(value)
}


/**
 * Parsed ADS Paper form state
 */
public struct ParsedPaperForm {
    public var bibcode: String
    public var doi: String
    public var arxivId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bibcode: String, doi: String, arxivId: String) {
        self.bibcode = bibcode
        self.doi = doi
        self.arxivId = arxivId
    }
}



extension ParsedPaperForm: Equatable, Hashable {
    public static func ==(lhs: ParsedPaperForm, rhs: ParsedPaperForm) -> Bool {
        if lhs.bibcode != rhs.bibcode {
            return false
        }
        if lhs.doi != rhs.doi {
            return false
        }
        if lhs.arxivId != rhs.arxivId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bibcode)
        hasher.combine(doi)
        hasher.combine(arxivId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedPaperForm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedPaperForm {
        return
            try ParsedPaperForm(
                bibcode: FfiConverterString.read(from: &buf), 
                doi: FfiConverterString.read(from: &buf), 
                arxivId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ParsedPaperForm, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bibcode, into: &buf)
        FfiConverterString.write(value.doi, into: &buf)
        FfiConverterString.write(value.arxivId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedPaperForm_lift(_ buf: RustBuffer) throws -> ParsedPaperForm {
    return try FfiConverterTypeParsedPaperForm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedPaperForm_lower(_ value: ParsedPaperForm) -> RustBuffer {
    return FfiConverterTypeParsedPaperForm.lower(value)
}


/**
 * A link to a PDF
 */
public struct PdfLink {
    public var url: String
    public var linkType: PdfLinkType
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, linkType: PdfLinkType, description: String?) {
        self.url = url
        self.linkType = linkType
        self.description = description
    }
}



extension PdfLink: Equatable, Hashable {
    public static func ==(lhs: PdfLink, rhs: PdfLink) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.linkType != rhs.linkType {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(linkType)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfLink {
        return
            try PdfLink(
                url: FfiConverterString.read(from: &buf), 
                linkType: FfiConverterTypePdfLinkType.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PdfLink, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypePdfLinkType.write(value.linkType, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfLink_lift(_ buf: RustBuffer) throws -> PdfLink {
    return try FfiConverterTypePdfLink.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfLink_lower(_ value: PdfLink) -> RustBuffer {
    return FfiConverterTypePdfLink.lower(value)
}


/**
 * PDF document metadata
 */
public struct PdfMetadata {
    public var pageCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pageCount: UInt32) {
        self.pageCount = pageCount
    }
}



extension PdfMetadata: Equatable, Hashable {
    public static func ==(lhs: PdfMetadata, rhs: PdfMetadata) -> Bool {
        if lhs.pageCount != rhs.pageCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pageCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfMetadata {
        return
            try PdfMetadata(
                pageCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PdfMetadata, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.pageCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfMetadata_lift(_ buf: RustBuffer) throws -> PdfMetadata {
    return try FfiConverterTypePdfMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfMetadata_lower(_ value: PdfMetadata) -> RustBuffer {
    return FfiConverterTypePdfMetadata.lower(value)
}


/**
 * Result of PDF text extraction
 */
public struct PdfTextResult {
    public var fullText: String
    public var pageCount: UInt32
    public var pages: [PageText]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fullText: String, pageCount: UInt32, pages: [PageText]) {
        self.fullText = fullText
        self.pageCount = pageCount
        self.pages = pages
    }
}



extension PdfTextResult: Equatable, Hashable {
    public static func ==(lhs: PdfTextResult, rhs: PdfTextResult) -> Bool {
        if lhs.fullText != rhs.fullText {
            return false
        }
        if lhs.pageCount != rhs.pageCount {
            return false
        }
        if lhs.pages != rhs.pages {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fullText)
        hasher.combine(pageCount)
        hasher.combine(pages)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfTextResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfTextResult {
        return
            try PdfTextResult(
                fullText: FfiConverterString.read(from: &buf), 
                pageCount: FfiConverterUInt32.read(from: &buf), 
                pages: FfiConverterSequenceTypePageText.read(from: &buf)
        )
    }

    public static func write(_ value: PdfTextResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fullText, into: &buf)
        FfiConverterUInt32.write(value.pageCount, into: &buf)
        FfiConverterSequenceTypePageText.write(value.pages, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfTextResult_lift(_ buf: RustBuffer) throws -> PdfTextResult {
    return try FfiConverterTypePdfTextResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfTextResult_lower(_ value: PdfTextResult) -> RustBuffer {
    return FfiConverterTypePdfTextResult.lower(value)
}


/**
 * PDF thumbnail result with RGBA pixel data and dimensions.
 */
public struct PdfThumbnail {
    /**
     * Raw RGBA pixel data (4 bytes per pixel: R, G, B, A)
     */
    public var rgbaBytes: Data
    /**
     * Actual rendered width in pixels
     */
    public var width: UInt32
    /**
     * Actual rendered height in pixels
     */
    public var height: UInt32
    /**
     * Total page count in the PDF
     */
    public var pageCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Raw RGBA pixel data (4 bytes per pixel: R, G, B, A)
         */rgbaBytes: Data, 
        /**
         * Actual rendered width in pixels
         */width: UInt32, 
        /**
         * Actual rendered height in pixels
         */height: UInt32, 
        /**
         * Total page count in the PDF
         */pageCount: UInt32) {
        self.rgbaBytes = rgbaBytes
        self.width = width
        self.height = height
        self.pageCount = pageCount
    }
}



extension PdfThumbnail: Equatable, Hashable {
    public static func ==(lhs: PdfThumbnail, rhs: PdfThumbnail) -> Bool {
        if lhs.rgbaBytes != rhs.rgbaBytes {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.pageCount != rhs.pageCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rgbaBytes)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(pageCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfThumbnail: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfThumbnail {
        return
            try PdfThumbnail(
                rgbaBytes: FfiConverterData.read(from: &buf), 
                width: FfiConverterUInt32.read(from: &buf), 
                height: FfiConverterUInt32.read(from: &buf), 
                pageCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PdfThumbnail, into buf: inout [UInt8]) {
        FfiConverterData.write(value.rgbaBytes, into: &buf)
        FfiConverterUInt32.write(value.width, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterUInt32.write(value.pageCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfThumbnail_lift(_ buf: RustBuffer) throws -> PdfThumbnail {
    return try FfiConverterTypePdfThumbnail.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfThumbnail_lower(_ value: PdfThumbnail) -> RustBuffer {
    return FfiConverterTypePdfThumbnail.lower(value)
}


/**
 * Point on a page
 */
public struct Point {
    public var x: Float
    public var y: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float) {
        self.x = x
        self.y = y
    }
}



extension Point: Equatable, Hashable {
    public static func ==(lhs: Point, rhs: Point) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Point {
        return
            try Point(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Point, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint_lift(_ buf: RustBuffer) throws -> Point {
    return try FfiConverterTypePoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint_lower(_ value: Point) -> RustBuffer {
    return FfiConverterTypePoint.lower(value)
}


/**
 * Preferred identifier result containing type and value
 */
public struct PreferredIdentifier {
    /**
     * The identifier type (as string, e.g., "doi", "arxiv")
     */
    public var idType: String
    /**
     * The identifier value
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identifier type (as string, e.g., "doi", "arxiv")
         */idType: String, 
        /**
         * The identifier value
         */value: String) {
        self.idType = idType
        self.value = value
    }
}



extension PreferredIdentifier: Equatable, Hashable {
    public static func ==(lhs: PreferredIdentifier, rhs: PreferredIdentifier) -> Bool {
        if lhs.idType != rhs.idType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(idType)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreferredIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreferredIdentifier {
        return
            try PreferredIdentifier(
                idType: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PreferredIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.idType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreferredIdentifier_lift(_ buf: RustBuffer) throws -> PreferredIdentifier {
    return try FfiConverterTypePreferredIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreferredIdentifier_lower(_ value: PreferredIdentifier) -> RustBuffer {
    return FfiConverterTypePreferredIdentifier.lower(value)
}


/**
 * A publication (paper, book, thesis, etc.)
 */
public struct Publication {
    public var id: String
    public var citeKey: String
    public var entryType: String
    public var title: String
    public var year: Int32?
    public var month: String?
    public var authors: [Author]
    public var editors: [Author]
    public var journal: String?
    public var booktitle: String?
    public var publisher: String?
    public var volume: String?
    public var number: String?
    public var pages: String?
    public var edition: String?
    public var series: String?
    public var address: String?
    public var chapter: String?
    public var howpublished: String?
    public var institution: String?
    public var organization: String?
    public var school: String?
    public var note: String?
    public var abstractText: String?
    public var keywords: [String]
    public var url: String?
    public var eprint: String?
    public var primaryClass: String?
    public var archivePrefix: String?
    public var identifiers: Identifiers
    public var extraFields: [String: String]
    public var linkedFiles: [LinkedFile]
    public var tags: [String]
    public var collections: [String]
    public var libraryId: String?
    public var createdAt: String?
    public var modifiedAt: String?
    public var sourceId: String?
    public var citationCount: Int32?
    public var referenceCount: Int32?
    public var enrichmentSource: String?
    public var enrichmentDate: String?
    public var rawBibtex: String?
    public var rawRis: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, citeKey: String, entryType: String, title: String, year: Int32?, month: String?, authors: [Author], editors: [Author], journal: String?, booktitle: String?, publisher: String?, volume: String?, number: String?, pages: String?, edition: String?, series: String?, address: String?, chapter: String?, howpublished: String?, institution: String?, organization: String?, school: String?, note: String?, abstractText: String?, keywords: [String], url: String?, eprint: String?, primaryClass: String?, archivePrefix: String?, identifiers: Identifiers, extraFields: [String: String], linkedFiles: [LinkedFile], tags: [String], collections: [String], libraryId: String?, createdAt: String?, modifiedAt: String?, sourceId: String?, citationCount: Int32?, referenceCount: Int32?, enrichmentSource: String?, enrichmentDate: String?, rawBibtex: String?, rawRis: String?) {
        self.id = id
        self.citeKey = citeKey
        self.entryType = entryType
        self.title = title
        self.year = year
        self.month = month
        self.authors = authors
        self.editors = editors
        self.journal = journal
        self.booktitle = booktitle
        self.publisher = publisher
        self.volume = volume
        self.number = number
        self.pages = pages
        self.edition = edition
        self.series = series
        self.address = address
        self.chapter = chapter
        self.howpublished = howpublished
        self.institution = institution
        self.organization = organization
        self.school = school
        self.note = note
        self.abstractText = abstractText
        self.keywords = keywords
        self.url = url
        self.eprint = eprint
        self.primaryClass = primaryClass
        self.archivePrefix = archivePrefix
        self.identifiers = identifiers
        self.extraFields = extraFields
        self.linkedFiles = linkedFiles
        self.tags = tags
        self.collections = collections
        self.libraryId = libraryId
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.sourceId = sourceId
        self.citationCount = citationCount
        self.referenceCount = referenceCount
        self.enrichmentSource = enrichmentSource
        self.enrichmentDate = enrichmentDate
        self.rawBibtex = rawBibtex
        self.rawRis = rawRis
    }
}



extension Publication: Equatable, Hashable {
    public static func ==(lhs: Publication, rhs: Publication) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.entryType != rhs.entryType {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        if lhs.month != rhs.month {
            return false
        }
        if lhs.authors != rhs.authors {
            return false
        }
        if lhs.editors != rhs.editors {
            return false
        }
        if lhs.journal != rhs.journal {
            return false
        }
        if lhs.booktitle != rhs.booktitle {
            return false
        }
        if lhs.publisher != rhs.publisher {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.number != rhs.number {
            return false
        }
        if lhs.pages != rhs.pages {
            return false
        }
        if lhs.edition != rhs.edition {
            return false
        }
        if lhs.series != rhs.series {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.chapter != rhs.chapter {
            return false
        }
        if lhs.howpublished != rhs.howpublished {
            return false
        }
        if lhs.institution != rhs.institution {
            return false
        }
        if lhs.organization != rhs.organization {
            return false
        }
        if lhs.school != rhs.school {
            return false
        }
        if lhs.note != rhs.note {
            return false
        }
        if lhs.abstractText != rhs.abstractText {
            return false
        }
        if lhs.keywords != rhs.keywords {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.eprint != rhs.eprint {
            return false
        }
        if lhs.primaryClass != rhs.primaryClass {
            return false
        }
        if lhs.archivePrefix != rhs.archivePrefix {
            return false
        }
        if lhs.identifiers != rhs.identifiers {
            return false
        }
        if lhs.extraFields != rhs.extraFields {
            return false
        }
        if lhs.linkedFiles != rhs.linkedFiles {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.collections != rhs.collections {
            return false
        }
        if lhs.libraryId != rhs.libraryId {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        if lhs.sourceId != rhs.sourceId {
            return false
        }
        if lhs.citationCount != rhs.citationCount {
            return false
        }
        if lhs.referenceCount != rhs.referenceCount {
            return false
        }
        if lhs.enrichmentSource != rhs.enrichmentSource {
            return false
        }
        if lhs.enrichmentDate != rhs.enrichmentDate {
            return false
        }
        if lhs.rawBibtex != rhs.rawBibtex {
            return false
        }
        if lhs.rawRis != rhs.rawRis {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(citeKey)
        hasher.combine(entryType)
        hasher.combine(title)
        hasher.combine(year)
        hasher.combine(month)
        hasher.combine(authors)
        hasher.combine(editors)
        hasher.combine(journal)
        hasher.combine(booktitle)
        hasher.combine(publisher)
        hasher.combine(volume)
        hasher.combine(number)
        hasher.combine(pages)
        hasher.combine(edition)
        hasher.combine(series)
        hasher.combine(address)
        hasher.combine(chapter)
        hasher.combine(howpublished)
        hasher.combine(institution)
        hasher.combine(organization)
        hasher.combine(school)
        hasher.combine(note)
        hasher.combine(abstractText)
        hasher.combine(keywords)
        hasher.combine(url)
        hasher.combine(eprint)
        hasher.combine(primaryClass)
        hasher.combine(archivePrefix)
        hasher.combine(identifiers)
        hasher.combine(extraFields)
        hasher.combine(linkedFiles)
        hasher.combine(tags)
        hasher.combine(collections)
        hasher.combine(libraryId)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
        hasher.combine(sourceId)
        hasher.combine(citationCount)
        hasher.combine(referenceCount)
        hasher.combine(enrichmentSource)
        hasher.combine(enrichmentDate)
        hasher.combine(rawBibtex)
        hasher.combine(rawRis)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublication: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Publication {
        return
            try Publication(
                id: FfiConverterString.read(from: &buf), 
                citeKey: FfiConverterString.read(from: &buf), 
                entryType: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                year: FfiConverterOptionInt32.read(from: &buf), 
                month: FfiConverterOptionString.read(from: &buf), 
                authors: FfiConverterSequenceTypeAuthor.read(from: &buf), 
                editors: FfiConverterSequenceTypeAuthor.read(from: &buf), 
                journal: FfiConverterOptionString.read(from: &buf), 
                booktitle: FfiConverterOptionString.read(from: &buf), 
                publisher: FfiConverterOptionString.read(from: &buf), 
                volume: FfiConverterOptionString.read(from: &buf), 
                number: FfiConverterOptionString.read(from: &buf), 
                pages: FfiConverterOptionString.read(from: &buf), 
                edition: FfiConverterOptionString.read(from: &buf), 
                series: FfiConverterOptionString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                chapter: FfiConverterOptionString.read(from: &buf), 
                howpublished: FfiConverterOptionString.read(from: &buf), 
                institution: FfiConverterOptionString.read(from: &buf), 
                organization: FfiConverterOptionString.read(from: &buf), 
                school: FfiConverterOptionString.read(from: &buf), 
                note: FfiConverterOptionString.read(from: &buf), 
                abstractText: FfiConverterOptionString.read(from: &buf), 
                keywords: FfiConverterSequenceString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                eprint: FfiConverterOptionString.read(from: &buf), 
                primaryClass: FfiConverterOptionString.read(from: &buf), 
                archivePrefix: FfiConverterOptionString.read(from: &buf), 
                identifiers: FfiConverterTypeIdentifiers.read(from: &buf), 
                extraFields: FfiConverterDictionaryStringString.read(from: &buf), 
                linkedFiles: FfiConverterSequenceTypeLinkedFile.read(from: &buf), 
                tags: FfiConverterSequenceString.read(from: &buf), 
                collections: FfiConverterSequenceString.read(from: &buf), 
                libraryId: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterOptionString.read(from: &buf), 
                modifiedAt: FfiConverterOptionString.read(from: &buf), 
                sourceId: FfiConverterOptionString.read(from: &buf), 
                citationCount: FfiConverterOptionInt32.read(from: &buf), 
                referenceCount: FfiConverterOptionInt32.read(from: &buf), 
                enrichmentSource: FfiConverterOptionString.read(from: &buf), 
                enrichmentDate: FfiConverterOptionString.read(from: &buf), 
                rawBibtex: FfiConverterOptionString.read(from: &buf), 
                rawRis: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Publication, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterString.write(value.entryType, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterOptionInt32.write(value.year, into: &buf)
        FfiConverterOptionString.write(value.month, into: &buf)
        FfiConverterSequenceTypeAuthor.write(value.authors, into: &buf)
        FfiConverterSequenceTypeAuthor.write(value.editors, into: &buf)
        FfiConverterOptionString.write(value.journal, into: &buf)
        FfiConverterOptionString.write(value.booktitle, into: &buf)
        FfiConverterOptionString.write(value.publisher, into: &buf)
        FfiConverterOptionString.write(value.volume, into: &buf)
        FfiConverterOptionString.write(value.number, into: &buf)
        FfiConverterOptionString.write(value.pages, into: &buf)
        FfiConverterOptionString.write(value.edition, into: &buf)
        FfiConverterOptionString.write(value.series, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterOptionString.write(value.chapter, into: &buf)
        FfiConverterOptionString.write(value.howpublished, into: &buf)
        FfiConverterOptionString.write(value.institution, into: &buf)
        FfiConverterOptionString.write(value.organization, into: &buf)
        FfiConverterOptionString.write(value.school, into: &buf)
        FfiConverterOptionString.write(value.note, into: &buf)
        FfiConverterOptionString.write(value.abstractText, into: &buf)
        FfiConverterSequenceString.write(value.keywords, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.eprint, into: &buf)
        FfiConverterOptionString.write(value.primaryClass, into: &buf)
        FfiConverterOptionString.write(value.archivePrefix, into: &buf)
        FfiConverterTypeIdentifiers.write(value.identifiers, into: &buf)
        FfiConverterDictionaryStringString.write(value.extraFields, into: &buf)
        FfiConverterSequenceTypeLinkedFile.write(value.linkedFiles, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
        FfiConverterSequenceString.write(value.collections, into: &buf)
        FfiConverterOptionString.write(value.libraryId, into: &buf)
        FfiConverterOptionString.write(value.createdAt, into: &buf)
        FfiConverterOptionString.write(value.modifiedAt, into: &buf)
        FfiConverterOptionString.write(value.sourceId, into: &buf)
        FfiConverterOptionInt32.write(value.citationCount, into: &buf)
        FfiConverterOptionInt32.write(value.referenceCount, into: &buf)
        FfiConverterOptionString.write(value.enrichmentSource, into: &buf)
        FfiConverterOptionString.write(value.enrichmentDate, into: &buf)
        FfiConverterOptionString.write(value.rawBibtex, into: &buf)
        FfiConverterOptionString.write(value.rawRis, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublication_lift(_ buf: RustBuffer) throws -> Publication {
    return try FfiConverterTypePublication.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublication_lower(_ value: Publication) -> RustBuffer {
    return FfiConverterTypePublication.lower(value)
}


/**
 * All annotations for a publication
 */
public struct PublicationAnnotations {
    public var publicationId: String
    public var annotations: [Annotation]
    public var drawings: [DrawingAnnotation]
    public var version: UInt32
    public var modifiedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicationId: String, annotations: [Annotation], drawings: [DrawingAnnotation], version: UInt32, modifiedAt: String) {
        self.publicationId = publicationId
        self.annotations = annotations
        self.drawings = drawings
        self.version = version
        self.modifiedAt = modifiedAt
    }
}



extension PublicationAnnotations: Equatable, Hashable {
    public static func ==(lhs: PublicationAnnotations, rhs: PublicationAnnotations) -> Bool {
        if lhs.publicationId != rhs.publicationId {
            return false
        }
        if lhs.annotations != rhs.annotations {
            return false
        }
        if lhs.drawings != rhs.drawings {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicationId)
        hasher.combine(annotations)
        hasher.combine(drawings)
        hasher.combine(version)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicationAnnotations: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicationAnnotations {
        return
            try PublicationAnnotations(
                publicationId: FfiConverterString.read(from: &buf), 
                annotations: FfiConverterSequenceTypeAnnotation.read(from: &buf), 
                drawings: FfiConverterSequenceTypeDrawingAnnotation.read(from: &buf), 
                version: FfiConverterUInt32.read(from: &buf), 
                modifiedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PublicationAnnotations, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicationId, into: &buf)
        FfiConverterSequenceTypeAnnotation.write(value.annotations, into: &buf)
        FfiConverterSequenceTypeDrawingAnnotation.write(value.drawings, into: &buf)
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterString.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicationAnnotations_lift(_ buf: RustBuffer) throws -> PublicationAnnotations {
    return try FfiConverterTypePublicationAnnotations.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicationAnnotations_lower(_ value: PublicationAnnotations) -> RustBuffer {
    return FfiConverterTypePublicationAnnotations.lower(value)
}


/**
 * A parsed RIS entry
 */
public struct RisEntry {
    public var entryType: RisType
    public var tags: [RisTag]
    public var rawRis: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entryType: RisType, tags: [RisTag], rawRis: String?) {
        self.entryType = entryType
        self.tags = tags
        self.rawRis = rawRis
    }
}



extension RisEntry: Equatable, Hashable {
    public static func ==(lhs: RisEntry, rhs: RisEntry) -> Bool {
        if lhs.entryType != rhs.entryType {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.rawRis != rhs.rawRis {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entryType)
        hasher.combine(tags)
        hasher.combine(rawRis)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisEntry {
        return
            try RisEntry(
                entryType: FfiConverterTypeRISType.read(from: &buf), 
                tags: FfiConverterSequenceTypeRISTag.read(from: &buf), 
                rawRis: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RisEntry, into buf: inout [UInt8]) {
        FfiConverterTypeRISType.write(value.entryType, into: &buf)
        FfiConverterSequenceTypeRISTag.write(value.tags, into: &buf)
        FfiConverterOptionString.write(value.rawRis, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISEntry_lift(_ buf: RustBuffer) throws -> RisEntry {
    return try FfiConverterTypeRISEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISEntry_lower(_ value: RisEntry) -> RustBuffer {
    return FfiConverterTypeRISEntry.lower(value)
}


/**
 * A single RIS tag (key-value pair)
 */
public struct RisTag {
    public var tag: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tag: String, value: String) {
        self.tag = tag
        self.value = value
    }
}



extension RisTag: Equatable, Hashable {
    public static func ==(lhs: RisTag, rhs: RisTag) -> Bool {
        if lhs.tag != rhs.tag {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tag)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisTag {
        return
            try RisTag(
                tag: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RisTag, into buf: inout [UInt8]) {
        FfiConverterString.write(value.tag, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISTag_lift(_ buf: RustBuffer) throws -> RisTag {
    return try FfiConverterTypeRISTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISTag_lower(_ value: RisTag) -> RustBuffer {
    return FfiConverterTypeRISTag.lower(value)
}


/**
 * A rectangle on a PDF page (in PDF coordinates)
 */
public struct Rect {
    public var x: Float
    public var y: Float
    public var width: Float
    public var height: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float, width: Float, height: Float) {
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    }
}



extension Rect: Equatable, Hashable {
    public static func ==(lhs: Rect, rhs: Rect) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(width)
        hasher.combine(height)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRect: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rect {
        return
            try Rect(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf), 
                width: FfiConverterFloat.read(from: &buf), 
                height: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Rect, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRect_lift(_ buf: RustBuffer) throws -> Rect {
    return try FfiConverterTypeRect.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRect_lower(_ value: Rect) -> RustBuffer {
    return FfiConverterTypeRect.lower(value)
}


public struct SearchCommand {
    public var query: String
    public var source: String?
    public var maxResults: Int32?
    public var autoImport: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(query: String, source: String?, maxResults: Int32?, autoImport: Bool) {
        self.query = query
        self.source = source
        self.maxResults = maxResults
        self.autoImport = autoImport
    }
}



extension SearchCommand: Equatable, Hashable {
    public static func ==(lhs: SearchCommand, rhs: SearchCommand) -> Bool {
        if lhs.query != rhs.query {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.maxResults != rhs.maxResults {
            return false
        }
        if lhs.autoImport != rhs.autoImport {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(query)
        hasher.combine(source)
        hasher.combine(maxResults)
        hasher.combine(autoImport)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSearchCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchCommand {
        return
            try SearchCommand(
                query: FfiConverterString.read(from: &buf), 
                source: FfiConverterOptionString.read(from: &buf), 
                maxResults: FfiConverterOptionInt32.read(from: &buf), 
                autoImport: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.query, into: &buf)
        FfiConverterOptionString.write(value.source, into: &buf)
        FfiConverterOptionInt32.write(value.maxResults, into: &buf)
        FfiConverterBool.write(value.autoImport, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchCommand_lift(_ buf: RustBuffer) throws -> SearchCommand {
    return try FfiConverterTypeSearchCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchCommand_lower(_ value: SearchCommand) -> RustBuffer {
    return FfiConverterTypeSearchCommand.lower(value)
}


/**
 * A search result hit
 */
public struct SearchHit {
    public var id: String
    public var citeKey: String
    public var title: String
    public var score: Float
    public var snippet: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, citeKey: String, title: String, score: Float, snippet: String?) {
        self.id = id
        self.citeKey = citeKey
        self.title = title
        self.score = score
        self.snippet = snippet
    }
}



extension SearchHit: Equatable, Hashable {
    public static func ==(lhs: SearchHit, rhs: SearchHit) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.score != rhs.score {
            return false
        }
        if lhs.snippet != rhs.snippet {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(citeKey)
        hasher.combine(title)
        hasher.combine(score)
        hasher.combine(snippet)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSearchHit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchHit {
        return
            try SearchHit(
                id: FfiConverterString.read(from: &buf), 
                citeKey: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                score: FfiConverterFloat.read(from: &buf), 
                snippet: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SearchHit, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterFloat.write(value.score, into: &buf)
        FfiConverterOptionString.write(value.snippet, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchHit_lift(_ buf: RustBuffer) throws -> SearchHit {
    return try FfiConverterTypeSearchHit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchHit_lower(_ value: SearchHit) -> RustBuffer {
    return FfiConverterTypeSearchHit.lower(value)
}


/**
 * A search result from an online source
 */
public struct SearchResult {
    public var sourceId: String
    public var source: Source
    public var title: String
    public var authors: [Author]
    public var year: Int32?
    public var identifiers: Identifiers
    public var abstractText: String?
    public var journal: String?
    public var volume: String?
    public var pages: String?
    public var pdfLinks: [PdfLink]
    public var bibtex: String?
    public var url: String?
    public var citationCount: Int32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sourceId: String, source: Source, title: String, authors: [Author], year: Int32?, identifiers: Identifiers, abstractText: String?, journal: String?, volume: String?, pages: String?, pdfLinks: [PdfLink], bibtex: String?, url: String?, citationCount: Int32?) {
        self.sourceId = sourceId
        self.source = source
        self.title = title
        self.authors = authors
        self.year = year
        self.identifiers = identifiers
        self.abstractText = abstractText
        self.journal = journal
        self.volume = volume
        self.pages = pages
        self.pdfLinks = pdfLinks
        self.bibtex = bibtex
        self.url = url
        self.citationCount = citationCount
    }
}



extension SearchResult: Equatable, Hashable {
    public static func ==(lhs: SearchResult, rhs: SearchResult) -> Bool {
        if lhs.sourceId != rhs.sourceId {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.authors != rhs.authors {
            return false
        }
        if lhs.year != rhs.year {
            return false
        }
        if lhs.identifiers != rhs.identifiers {
            return false
        }
        if lhs.abstractText != rhs.abstractText {
            return false
        }
        if lhs.journal != rhs.journal {
            return false
        }
        if lhs.volume != rhs.volume {
            return false
        }
        if lhs.pages != rhs.pages {
            return false
        }
        if lhs.pdfLinks != rhs.pdfLinks {
            return false
        }
        if lhs.bibtex != rhs.bibtex {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.citationCount != rhs.citationCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sourceId)
        hasher.combine(source)
        hasher.combine(title)
        hasher.combine(authors)
        hasher.combine(year)
        hasher.combine(identifiers)
        hasher.combine(abstractText)
        hasher.combine(journal)
        hasher.combine(volume)
        hasher.combine(pages)
        hasher.combine(pdfLinks)
        hasher.combine(bibtex)
        hasher.combine(url)
        hasher.combine(citationCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSearchResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchResult {
        return
            try SearchResult(
                sourceId: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypeSource.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                authors: FfiConverterSequenceTypeAuthor.read(from: &buf), 
                year: FfiConverterOptionInt32.read(from: &buf), 
                identifiers: FfiConverterTypeIdentifiers.read(from: &buf), 
                abstractText: FfiConverterOptionString.read(from: &buf), 
                journal: FfiConverterOptionString.read(from: &buf), 
                volume: FfiConverterOptionString.read(from: &buf), 
                pages: FfiConverterOptionString.read(from: &buf), 
                pdfLinks: FfiConverterSequenceTypePdfLink.read(from: &buf), 
                bibtex: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                citationCount: FfiConverterOptionInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SearchResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sourceId, into: &buf)
        FfiConverterTypeSource.write(value.source, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterSequenceTypeAuthor.write(value.authors, into: &buf)
        FfiConverterOptionInt32.write(value.year, into: &buf)
        FfiConverterTypeIdentifiers.write(value.identifiers, into: &buf)
        FfiConverterOptionString.write(value.abstractText, into: &buf)
        FfiConverterOptionString.write(value.journal, into: &buf)
        FfiConverterOptionString.write(value.volume, into: &buf)
        FfiConverterOptionString.write(value.pages, into: &buf)
        FfiConverterSequenceTypePdfLink.write(value.pdfLinks, into: &buf)
        FfiConverterOptionString.write(value.bibtex, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionInt32.write(value.citationCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchResult_lift(_ buf: RustBuffer) throws -> SearchResult {
    return try FfiConverterTypeSearchResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchResult_lower(_ value: SearchResult) -> RustBuffer {
    return FfiConverterTypeSearchResult.lower(value)
}


public struct SyncBibliographyCommand {
    public var imprintDocumentId: String
    public var action: BibSyncAction

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(imprintDocumentId: String, action: BibSyncAction) {
        self.imprintDocumentId = imprintDocumentId
        self.action = action
    }
}



extension SyncBibliographyCommand: Equatable, Hashable {
    public static func ==(lhs: SyncBibliographyCommand, rhs: SyncBibliographyCommand) -> Bool {
        if lhs.imprintDocumentId != rhs.imprintDocumentId {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(imprintDocumentId)
        hasher.combine(action)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncBibliographyCommand: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncBibliographyCommand {
        return
            try SyncBibliographyCommand(
                imprintDocumentId: FfiConverterString.read(from: &buf), 
                action: FfiConverterTypeBibSyncAction.read(from: &buf)
        )
    }

    public static func write(_ value: SyncBibliographyCommand, into buf: inout [UInt8]) {
        FfiConverterString.write(value.imprintDocumentId, into: &buf)
        FfiConverterTypeBibSyncAction.write(value.action, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncBibliographyCommand_lift(_ buf: RustBuffer) throws -> SyncBibliographyCommand {
    return try FfiConverterTypeSyncBibliographyCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncBibliographyCommand_lower(_ value: SyncBibliographyCommand) -> RustBuffer {
    return FfiConverterTypeSyncBibliographyCommand.lower(value)
}


/**
 * A tag for organizing publications
 */
public struct Tag {
    public var id: String
    public var name: String
    public var color: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, color: String?) {
        self.id = id
        self.name = name
        self.color = color
    }
}



extension Tag: Equatable, Hashable {
    public static func ==(lhs: Tag, rhs: Tag) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(color)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        return
            try Tag(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                color: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.color, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lift(_ buf: RustBuffer) throws -> Tag {
    return try FfiConverterTypeTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lower(_ value: Tag) -> RustBuffer {
    return FfiConverterTypeTag.lower(value)
}


/**
 * Search for text within a PDF and return positions
 */
public struct TextMatch {
    public var pageNumber: UInt32
    public var text: String
    public var charIndex: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pageNumber: UInt32, text: String, charIndex: UInt32) {
        self.pageNumber = pageNumber
        self.text = text
        self.charIndex = charIndex
    }
}



extension TextMatch: Equatable, Hashable {
    public static func ==(lhs: TextMatch, rhs: TextMatch) -> Bool {
        if lhs.pageNumber != rhs.pageNumber {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.charIndex != rhs.charIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pageNumber)
        hasher.combine(text)
        hasher.combine(charIndex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTextMatch: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMatch {
        return
            try TextMatch(
                pageNumber: FfiConverterUInt32.read(from: &buf), 
                text: FfiConverterString.read(from: &buf), 
                charIndex: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TextMatch, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.pageNumber, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterUInt32.write(value.charIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextMatch_lift(_ buf: RustBuffer) throws -> TextMatch {
    return try FfiConverterTypeTextMatch.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextMatch_lower(_ value: TextMatch) -> RustBuffer {
    return FfiConverterTypeTextMatch.lower(value)
}


/**
 * Thumbnail configuration
 */
public struct ThumbnailConfig {
    public var width: UInt32
    public var height: UInt32
    public var pageNumber: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(width: UInt32, height: UInt32, pageNumber: UInt32) {
        self.width = width
        self.height = height
        self.pageNumber = pageNumber
    }
}



extension ThumbnailConfig: Equatable, Hashable {
    public static func ==(lhs: ThumbnailConfig, rhs: ThumbnailConfig) -> Bool {
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.pageNumber != rhs.pageNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(pageNumber)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThumbnailConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailConfig {
        return
            try ThumbnailConfig(
                width: FfiConverterUInt32.read(from: &buf), 
                height: FfiConverterUInt32.read(from: &buf), 
                pageNumber: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.width, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterUInt32.write(value.pageNumber, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnailConfig_lift(_ buf: RustBuffer) throws -> ThumbnailConfig {
    return try FfiConverterTypeThumbnailConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnailConfig_lower(_ value: ThumbnailConfig) -> RustBuffer {
    return FfiConverterTypeThumbnailConfig.lower(value)
}


/**
 * A validation error or warning
 */
public struct ValidationError {
    public var field: String
    public var message: String
    public var severity: ValidationSeverity

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(field: String, message: String, severity: ValidationSeverity) {
        self.field = field
        self.message = message
        self.severity = severity
    }
}



extension ValidationError: Equatable, Hashable {
    public static func ==(lhs: ValidationError, rhs: ValidationError) -> Bool {
        if lhs.field != rhs.field {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.severity != rhs.severity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(field)
        hasher.combine(message)
        hasher.combine(severity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationError {
        return
            try ValidationError(
                field: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf), 
                severity: FfiConverterTypeValidationSeverity.read(from: &buf)
        )
    }

    public static func write(_ value: ValidationError, into buf: inout [UInt8]) {
        FfiConverterString.write(value.field, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterTypeValidationSeverity.write(value.severity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationError_lift(_ buf: RustBuffer) throws -> ValidationError {
    return try FfiConverterTypeValidationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationError_lower(_ value: ValidationError) -> RustBuffer {
    return FfiConverterTypeValidationError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * ADS database/collection selector
 */

public enum AdsDatabase {
    
    case astronomy
    case physics
    case arxiv
    case all
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeADSDatabase: FfiConverterRustBuffer {
    typealias SwiftType = AdsDatabase

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AdsDatabase {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .astronomy
        
        case 2: return .physics
        
        case 3: return .arxiv
        
        case 4: return .all
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AdsDatabase, into buf: inout [UInt8]) {
        switch value {
        
        
        case .astronomy:
            writeInt(&buf, Int32(1))
        
        
        case .physics:
            writeInt(&buf, Int32(2))
        
        
        case .arxiv:
            writeInt(&buf, Int32(3))
        
        
        case .all:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeADSDatabase_lift(_ buf: RustBuffer) throws -> AdsDatabase {
    return try FfiConverterTypeADSDatabase.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeADSDatabase_lower(_ value: AdsDatabase) -> RustBuffer {
    return FfiConverterTypeADSDatabase.lower(value)
}



extension AdsDatabase: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An operation that can be undone/redone
 */

public enum AnnotationOperation {
    
    case add(annotation: Annotation
    )
    case remove(annotation: Annotation
    )
    case updateContent(annotationId: String, oldContent: String?, newContent: String?
    )
    case updateColor(annotationId: String, oldColor: AnnotationColor, newColor: AnnotationColor
    )
    case move(annotationId: String, oldRects: [Rect], newRects: [Rect]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationOperation: FfiConverterRustBuffer {
    typealias SwiftType = AnnotationOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .add(annotation: try FfiConverterTypeAnnotation.read(from: &buf)
        )
        
        case 2: return .remove(annotation: try FfiConverterTypeAnnotation.read(from: &buf)
        )
        
        case 3: return .updateContent(annotationId: try FfiConverterString.read(from: &buf), oldContent: try FfiConverterOptionString.read(from: &buf), newContent: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .updateColor(annotationId: try FfiConverterString.read(from: &buf), oldColor: try FfiConverterTypeAnnotationColor.read(from: &buf), newColor: try FfiConverterTypeAnnotationColor.read(from: &buf)
        )
        
        case 5: return .move(annotationId: try FfiConverterString.read(from: &buf), oldRects: try FfiConverterSequenceTypeRect.read(from: &buf), newRects: try FfiConverterSequenceTypeRect.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AnnotationOperation, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .add(annotation):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAnnotation.write(annotation, into: &buf)
            
        
        case let .remove(annotation):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAnnotation.write(annotation, into: &buf)
            
        
        case let .updateContent(annotationId,oldContent,newContent):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(annotationId, into: &buf)
            FfiConverterOptionString.write(oldContent, into: &buf)
            FfiConverterOptionString.write(newContent, into: &buf)
            
        
        case let .updateColor(annotationId,oldColor,newColor):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(annotationId, into: &buf)
            FfiConverterTypeAnnotationColor.write(oldColor, into: &buf)
            FfiConverterTypeAnnotationColor.write(newColor, into: &buf)
            
        
        case let .move(annotationId,oldRects,newRects):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(annotationId, into: &buf)
            FfiConverterSequenceTypeRect.write(oldRects, into: &buf)
            FfiConverterSequenceTypeRect.write(newRects, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationOperation_lift(_ buf: RustBuffer) throws -> AnnotationOperation {
    return try FfiConverterTypeAnnotationOperation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationOperation_lower(_ value: AnnotationOperation) -> RustBuffer {
    return FfiConverterTypeAnnotationOperation.lower(value)
}



extension AnnotationOperation: Equatable, Hashable {}




public enum AnnotationStorageError {

    
    
    case SerializationError(String
    )
    case NotFound(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationStorageError: FfiConverterRustBuffer {
    typealias SwiftType = AnnotationStorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationStorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .NotFound(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AnnotationStorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SerializationError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NotFound(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension AnnotationStorageError: Equatable, Hashable {}

extension AnnotationStorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Annotation type
 */

public enum AnnotationType {
    
    case highlight
    case underline
    case strikeOut
    case squiggly
    case note
    case freeText
    case drawing
    case link
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnnotationType: FfiConverterRustBuffer {
    typealias SwiftType = AnnotationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnnotationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .highlight
        
        case 2: return .underline
        
        case 3: return .strikeOut
        
        case 4: return .squiggly
        
        case 5: return .note
        
        case 6: return .freeText
        
        case 7: return .drawing
        
        case 8: return .link
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AnnotationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .highlight:
            writeInt(&buf, Int32(1))
        
        
        case .underline:
            writeInt(&buf, Int32(2))
        
        
        case .strikeOut:
            writeInt(&buf, Int32(3))
        
        
        case .squiggly:
            writeInt(&buf, Int32(4))
        
        
        case .note:
            writeInt(&buf, Int32(5))
        
        
        case .freeText:
            writeInt(&buf, Int32(6))
        
        
        case .drawing:
            writeInt(&buf, Int32(7))
        
        
        case .link:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lift(_ buf: RustBuffer) throws -> AnnotationType {
    return try FfiConverterTypeAnnotationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnnotationType_lower(_ value: AnnotationType) -> RustBuffer {
    return FfiConverterTypeAnnotationType.lower(value)
}



extension AnnotationType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported automation commands
 */

public enum AutomationCommand {
    
    /**
     * Search across all configured sources
     */
    case search(SearchCommand
    )
    /**
     * Import publications from URL or content
     */
    case `import`(ImportCommand
    )
    /**
     * Open a publication by identifier
     */
    case `open`(OpenCommand
    )
    /**
     * Lookup and enrich a publication
     */
    case lookup(LookupCommand
    )
    /**
     * Export publications
     */
    case export(ExportCommand
    )
    /**
     * Library management
     */
    case library(LibraryCommand
    )
    /**
     * Insert a citation into an imprint document
     */
    case insertCitation(InsertCitationCommand
    )
    /**
     * Open a manuscript in imprint
     */
    case openManuscript(OpenManuscriptCommand
    )
    /**
     * Synchronize bibliography between apps
     */
    case syncBibliography(SyncBibliographyCommand
    )
    /**
     * Unknown command
     */
    case unknown(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAutomationCommand: FfiConverterRustBuffer {
    typealias SwiftType = AutomationCommand

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutomationCommand {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .search(try FfiConverterTypeSearchCommand.read(from: &buf)
        )
        
        case 2: return .`import`(try FfiConverterTypeImportCommand.read(from: &buf)
        )
        
        case 3: return .`open`(try FfiConverterTypeOpenCommand.read(from: &buf)
        )
        
        case 4: return .lookup(try FfiConverterTypeLookupCommand.read(from: &buf)
        )
        
        case 5: return .export(try FfiConverterTypeExportCommand.read(from: &buf)
        )
        
        case 6: return .library(try FfiConverterTypeLibraryCommand.read(from: &buf)
        )
        
        case 7: return .insertCitation(try FfiConverterTypeInsertCitationCommand.read(from: &buf)
        )
        
        case 8: return .openManuscript(try FfiConverterTypeOpenManuscriptCommand.read(from: &buf)
        )
        
        case 9: return .syncBibliography(try FfiConverterTypeSyncBibliographyCommand.read(from: &buf)
        )
        
        case 10: return .unknown(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AutomationCommand, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .search(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSearchCommand.write(v1, into: &buf)
            
        
        case let .`import`(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImportCommand.write(v1, into: &buf)
            
        
        case let .`open`(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOpenCommand.write(v1, into: &buf)
            
        
        case let .lookup(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeLookupCommand.write(v1, into: &buf)
            
        
        case let .export(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeExportCommand.write(v1, into: &buf)
            
        
        case let .library(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLibraryCommand.write(v1, into: &buf)
            
        
        case let .insertCitation(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeInsertCitationCommand.write(v1, into: &buf)
            
        
        case let .openManuscript(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeOpenManuscriptCommand.write(v1, into: &buf)
            
        
        case let .syncBibliography(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeSyncBibliographyCommand.write(v1, into: &buf)
            
        
        case let .unknown(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutomationCommand_lift(_ buf: RustBuffer) throws -> AutomationCommand {
    return try FfiConverterTypeAutomationCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutomationCommand_lower(_ value: AutomationCommand) -> RustBuffer {
    return FfiConverterTypeAutomationCommand.lower(value)
}



extension AutomationCommand: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Bibliography synchronization action for cross-app communication
 */

public enum BibSyncAction {
    
    /**
     * Export bibliography from imprint to imbib
     */
    case export
    /**
     * Import from imbib library to imprint
     */
    case `import`
    /**
     * Check for missing citations
     */
    case verify
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibSyncAction: FfiConverterRustBuffer {
    typealias SwiftType = BibSyncAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibSyncAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .export
        
        case 2: return .`import`
        
        case 3: return .verify
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BibSyncAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .export:
            writeInt(&buf, Int32(1))
        
        
        case .`import`:
            writeInt(&buf, Int32(2))
        
        
        case .verify:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibSyncAction_lift(_ buf: RustBuffer) throws -> BibSyncAction {
    return try FfiConverterTypeBibSyncAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibSyncAction_lower(_ value: BibSyncAction) -> RustBuffer {
    return FfiConverterTypeBibSyncAction.lower(value)
}



extension BibSyncAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BibTeX entry type
 */

public enum BibTeXEntryType {
    
    case article
    case book
    case booklet
    case inBook
    case inCollection
    case inProceedings
    case manual
    case mastersThesis
    case misc
    case phdThesis
    case proceedings
    case techReport
    case unpublished
    case online
    case software
    case dataset
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXEntryType: FfiConverterRustBuffer {
    typealias SwiftType = BibTeXEntryType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXEntryType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .article
        
        case 2: return .book
        
        case 3: return .booklet
        
        case 4: return .inBook
        
        case 5: return .inCollection
        
        case 6: return .inProceedings
        
        case 7: return .manual
        
        case 8: return .mastersThesis
        
        case 9: return .misc
        
        case 10: return .phdThesis
        
        case 11: return .proceedings
        
        case 12: return .techReport
        
        case 13: return .unpublished
        
        case 14: return .online
        
        case 15: return .software
        
        case 16: return .dataset
        
        case 17: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BibTeXEntryType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .article:
            writeInt(&buf, Int32(1))
        
        
        case .book:
            writeInt(&buf, Int32(2))
        
        
        case .booklet:
            writeInt(&buf, Int32(3))
        
        
        case .inBook:
            writeInt(&buf, Int32(4))
        
        
        case .inCollection:
            writeInt(&buf, Int32(5))
        
        
        case .inProceedings:
            writeInt(&buf, Int32(6))
        
        
        case .manual:
            writeInt(&buf, Int32(7))
        
        
        case .mastersThesis:
            writeInt(&buf, Int32(8))
        
        
        case .misc:
            writeInt(&buf, Int32(9))
        
        
        case .phdThesis:
            writeInt(&buf, Int32(10))
        
        
        case .proceedings:
            writeInt(&buf, Int32(11))
        
        
        case .techReport:
            writeInt(&buf, Int32(12))
        
        
        case .unpublished:
            writeInt(&buf, Int32(13))
        
        
        case .online:
            writeInt(&buf, Int32(14))
        
        
        case .software:
            writeInt(&buf, Int32(15))
        
        
        case .dataset:
            writeInt(&buf, Int32(16))
        
        
        case .unknown:
            writeInt(&buf, Int32(17))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntryType_lift(_ buf: RustBuffer) throws -> BibTeXEntryType {
    return try FfiConverterTypeBibTeXEntryType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntryType_lower(_ value: BibTeXEntryType) -> RustBuffer {
    return FfiConverterTypeBibTeXEntryType.lower(value)
}



extension BibTeXEntryType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Capabilities that an enrichment source can provide
 */

public enum EnrichmentCapability {
    
    /**
     * Citation count
     */
    case citationCount
    /**
     * List of references
     */
    case references
    /**
     * List of citing papers
     */
    case citations
    /**
     * Paper abstract
     */
    case abstract
    /**
     * PDF download URLs
     */
    case pdfUrl
    /**
     * Author statistics (h-index, etc.)
     */
    case authorStats
    /**
     * Open access status
     */
    case openAccess
    /**
     * Venue/journal information
     */
    case venue
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnrichmentCapability: FfiConverterRustBuffer {
    typealias SwiftType = EnrichmentCapability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnrichmentCapability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .citationCount
        
        case 2: return .references
        
        case 3: return .citations
        
        case 4: return .abstract
        
        case 5: return .pdfUrl
        
        case 6: return .authorStats
        
        case 7: return .openAccess
        
        case 8: return .venue
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnrichmentCapability, into buf: inout [UInt8]) {
        switch value {
        
        
        case .citationCount:
            writeInt(&buf, Int32(1))
        
        
        case .references:
            writeInt(&buf, Int32(2))
        
        
        case .citations:
            writeInt(&buf, Int32(3))
        
        
        case .abstract:
            writeInt(&buf, Int32(4))
        
        
        case .pdfUrl:
            writeInt(&buf, Int32(5))
        
        
        case .authorStats:
            writeInt(&buf, Int32(6))
        
        
        case .openAccess:
            writeInt(&buf, Int32(7))
        
        
        case .venue:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentCapability_lift(_ buf: RustBuffer) throws -> EnrichmentCapability {
    return try FfiConverterTypeEnrichmentCapability.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentCapability_lower(_ value: EnrichmentCapability) -> RustBuffer {
    return FfiConverterTypeEnrichmentCapability.lower(value)
}



extension EnrichmentCapability: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Priority levels for enrichment requests
 */

public enum EnrichmentPriority {
    
    /**
     * User explicitly requested enrichment
     */
    case userTriggered
    /**
     * User recently viewed the paper
     */
    case recentlyViewed
    /**
     * Paper is in the user's library
     */
    case libraryPaper
    /**
     * Background periodic refresh
     */
    case backgroundSync
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnrichmentPriority: FfiConverterRustBuffer {
    typealias SwiftType = EnrichmentPriority

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnrichmentPriority {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .userTriggered
        
        case 2: return .recentlyViewed
        
        case 3: return .libraryPaper
        
        case 4: return .backgroundSync
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnrichmentPriority, into buf: inout [UInt8]) {
        switch value {
        
        
        case .userTriggered:
            writeInt(&buf, Int32(1))
        
        
        case .recentlyViewed:
            writeInt(&buf, Int32(2))
        
        
        case .libraryPaper:
            writeInt(&buf, Int32(3))
        
        
        case .backgroundSync:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentPriority_lift(_ buf: RustBuffer) throws -> EnrichmentPriority {
    return try FfiConverterTypeEnrichmentPriority.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentPriority_lower(_ value: EnrichmentPriority) -> RustBuffer {
    return FfiConverterTypeEnrichmentPriority.lower(value)
}



extension EnrichmentPriority: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Sources that can provide enrichment data
 */

public enum EnrichmentSource {
    
    /**
     * NASA Astrophysics Data System
     */
    case ads
    /**
     * Semantic Scholar
     */
    case semanticScholar
    /**
     * OpenAlex
     */
    case openAlex
    /**
     * Crossref
     */
    case crossref
    /**
     * arXiv
     */
    case arxiv
    /**
     * PubMed
     */
    case pubmed
    /**
     * DBLP
     */
    case dblp
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnrichmentSource: FfiConverterRustBuffer {
    typealias SwiftType = EnrichmentSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnrichmentSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ads
        
        case 2: return .semanticScholar
        
        case 3: return .openAlex
        
        case 4: return .crossref
        
        case 5: return .arxiv
        
        case 6: return .pubmed
        
        case 7: return .dblp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnrichmentSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ads:
            writeInt(&buf, Int32(1))
        
        
        case .semanticScholar:
            writeInt(&buf, Int32(2))
        
        
        case .openAlex:
            writeInt(&buf, Int32(3))
        
        
        case .crossref:
            writeInt(&buf, Int32(4))
        
        
        case .arxiv:
            writeInt(&buf, Int32(5))
        
        
        case .pubmed:
            writeInt(&buf, Int32(6))
        
        
        case .dblp:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentSource_lift(_ buf: RustBuffer) throws -> EnrichmentSource {
    return try FfiConverterTypeEnrichmentSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnrichmentSource_lower(_ value: EnrichmentSource) -> RustBuffer {
    return FfiConverterTypeEnrichmentSource.lower(value)
}



extension EnrichmentSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Export format options
 */

public enum ExportFormat {
    
    case bibTeX
    case ris
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExportFormat: FfiConverterRustBuffer {
    typealias SwiftType = ExportFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bibTeX
        
        case 2: return .ris
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExportFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bibTeX:
            writeInt(&buf, Int32(1))
        
        
        case .ris:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportFormat_lift(_ buf: RustBuffer) throws -> ExportFormat {
    return try FfiConverterTypeExportFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExportFormat_lower(_ value: ExportFormat) -> RustBuffer {
    return FfiConverterTypeExportFormat.lower(value)
}



extension ExportFormat: Equatable, Hashable {}




/**
 * FFI-safe error type for parsing operations
 */
public enum FfiError {

    
    
    case ParseError(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiError: FfiConverterRustBuffer {
    typealias SwiftType = FfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .ParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension FfiError: Equatable, Hashable {}

extension FfiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of file storage
 */

public enum FileStorageType {
    
    case local
    case iCloud
    case webDav
    case s3
    case url
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileStorageType: FfiConverterRustBuffer {
    typealias SwiftType = FileStorageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileStorageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .local
        
        case 2: return .iCloud
        
        case 3: return .webDav
        
        case 4: return .s3
        
        case 5: return .url
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileStorageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .local:
            writeInt(&buf, Int32(1))
        
        
        case .iCloud:
            writeInt(&buf, Int32(2))
        
        
        case .webDav:
            writeInt(&buf, Int32(3))
        
        
        case .s3:
            writeInt(&buf, Int32(4))
        
        
        case .url:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileStorageType_lift(_ buf: RustBuffer) throws -> FileStorageType {
    return try FfiConverterTypeFileStorageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileStorageType_lower(_ value: FileStorageType) -> RustBuffer {
    return FfiConverterTypeFileStorageType.lower(value)
}



extension FileStorageType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Platform for help documentation filtering
 */

public enum HelpPlatform {
    
    /**
     * iOS-only feature
     */
    case ios
    /**
     * macOS-only feature
     */
    case macOs
    /**
     * Available on both platforms
     */
    case both
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHelpPlatform: FfiConverterRustBuffer {
    typealias SwiftType = HelpPlatform

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HelpPlatform {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ios
        
        case 2: return .macOs
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HelpPlatform, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ios:
            writeInt(&buf, Int32(1))
        
        
        case .macOs:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpPlatform_lift(_ buf: RustBuffer) throws -> HelpPlatform {
    return try FfiConverterTypeHelpPlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHelpPlatform_lower(_ value: HelpPlatform) -> RustBuffer {
    return FfiConverterTypeHelpPlatform.lower(value)
}



extension HelpPlatform: Equatable, Hashable {}




/**
 * Error type for help search operations
 */
public enum HelpSearchError {

    
    
    case IndexError(String
    )
    case QueryError(String
    )
    case IoError(String
    )
    case InvalidHandle
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHelpSearchError: FfiConverterRustBuffer {
    typealias SwiftType = HelpSearchError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HelpSearchError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .IndexError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .QueryError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .IoError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidHandle

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HelpSearchError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .IndexError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .QueryError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .IoError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidHandle:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension HelpSearchError: Equatable, Hashable {}

extension HelpSearchError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Types of publication identifiers across different sources
 */

public enum IdentifierType {
    
    /**
     * Digital Object Identifier
     */
    case doi
    /**
     * arXiv preprint identifier
     */
    case arxiv
    /**
     * PubMed identifier
     */
    case pmid
    /**
     * PubMed Central identifier
     */
    case pmcid
    /**
     * NASA ADS bibcode
     */
    case bibcode
    /**
     * Semantic Scholar paper ID
     */
    case semanticScholar
    /**
     * OpenAlex work ID
     */
    case openAlex
    /**
     * DBLP record key
     */
    case dblp
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifierType: FfiConverterRustBuffer {
    typealias SwiftType = IdentifierType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .doi
        
        case 2: return .arxiv
        
        case 3: return .pmid
        
        case 4: return .pmcid
        
        case 5: return .bibcode
        
        case 6: return .semanticScholar
        
        case 7: return .openAlex
        
        case 8: return .dblp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentifierType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .doi:
            writeInt(&buf, Int32(1))
        
        
        case .arxiv:
            writeInt(&buf, Int32(2))
        
        
        case .pmid:
            writeInt(&buf, Int32(3))
        
        
        case .pmcid:
            writeInt(&buf, Int32(4))
        
        
        case .bibcode:
            writeInt(&buf, Int32(5))
        
        
        case .semanticScholar:
            writeInt(&buf, Int32(6))
        
        
        case .openAlex:
            writeInt(&buf, Int32(7))
        
        
        case .dblp:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierType_lift(_ buf: RustBuffer) throws -> IdentifierType {
    return try FfiConverterTypeIdentifierType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierType_lower(_ value: IdentifierType) -> RustBuffer {
    return FfiConverterTypeIdentifierType.lower(value)
}



extension IdentifierType: Equatable, Hashable {}




/**
 * Import error type
 */
public enum ImportError {

    
    
    case ParseError(message: String
    )
    case InvalidFormat(message: String
    )
    case EmptyInput
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportError: FfiConverterRustBuffer {
    typealias SwiftType = ImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidFormat(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .EmptyInput

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .InvalidFormat(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case .EmptyInput:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension ImportError: Equatable, Hashable {}

extension ImportError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Detected import format
 */

public enum ImportFormat {
    
    case bibTeX
    case ris
    case auto
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportFormat: FfiConverterRustBuffer {
    typealias SwiftType = ImportFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bibTeX
        
        case 2: return .ris
        
        case 3: return .auto
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bibTeX:
            writeInt(&buf, Int32(1))
        
        
        case .ris:
            writeInt(&buf, Int32(2))
        
        
        case .auto:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportFormat_lift(_ buf: RustBuffer) throws -> ImportFormat {
    return try FfiConverterTypeImportFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportFormat_lower(_ value: ImportFormat) -> RustBuffer {
    return FfiConverterTypeImportFormat.lower(value)
}



extension ImportFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MergeStrategy {
    
    /**
     * Keep local version
     */
    case keepLocal
    /**
     * Keep remote version
     */
    case keepRemote
    /**
     * Keep newer (by modified_at)
     */
    case keepNewer
    /**
     * Merge fields (non-destructive)
     */
    case mergeFields
    /**
     * Manual resolution required
     */
    case manual
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMergeStrategy: FfiConverterRustBuffer {
    typealias SwiftType = MergeStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MergeStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .keepLocal
        
        case 2: return .keepRemote
        
        case 3: return .keepNewer
        
        case 4: return .mergeFields
        
        case 5: return .manual
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MergeStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .keepLocal:
            writeInt(&buf, Int32(1))
        
        
        case .keepRemote:
            writeInt(&buf, Int32(2))
        
        
        case .keepNewer:
            writeInt(&buf, Int32(3))
        
        
        case .mergeFields:
            writeInt(&buf, Int32(4))
        
        
        case .manual:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMergeStrategy_lift(_ buf: RustBuffer) throws -> MergeStrategy {
    return try FfiConverterTypeMergeStrategy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMergeStrategy_lower(_ value: MergeStrategy) -> RustBuffer {
    return FfiConverterTypeMergeStrategy.lower(value)
}



extension MergeStrategy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Open access availability status
 */

public enum OpenAccessStatus {
    
    /**
     * Published in an open access journal
     */
    case gold
    /**
     * Self-archived (preprint/postprint)
     */
    case green
    /**
     * Free to read but not openly licensed
     */
    case bronze
    /**
     * Open access article in subscription journal
     */
    case hybrid
    /**
     * Not freely accessible
     */
    case closed
    /**
     * Status not determined
     */
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenAccessStatus: FfiConverterRustBuffer {
    typealias SwiftType = OpenAccessStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenAccessStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gold
        
        case 2: return .green
        
        case 3: return .bronze
        
        case 4: return .hybrid
        
        case 5: return .closed
        
        case 6: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OpenAccessStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gold:
            writeInt(&buf, Int32(1))
        
        
        case .green:
            writeInt(&buf, Int32(2))
        
        
        case .bronze:
            writeInt(&buf, Int32(3))
        
        
        case .hybrid:
            writeInt(&buf, Int32(4))
        
        
        case .closed:
            writeInt(&buf, Int32(5))
        
        
        case .unknown:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenAccessStatus_lift(_ buf: RustBuffer) throws -> OpenAccessStatus {
    return try FfiConverterTypeOpenAccessStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenAccessStatus_lower(_ value: OpenAccessStatus) -> RustBuffer {
    return FfiConverterTypeOpenAccessStatus.lower(value)
}



extension OpenAccessStatus: Equatable, Hashable {}




/**
 * Error type for parsing failures
 */
public enum ParseError {

    
    
    case InvalidSyntax
    case UnexpectedToken
    case MissingField
    case InvalidEntryType
    case EncodingError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSyntax
        case 2: return .UnexpectedToken
        case 3: return .MissingField
        case 4: return .InvalidEntryType
        case 5: return .EncodingError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidSyntax:
            writeInt(&buf, Int32(1))
        
        
        case .UnexpectedToken:
            writeInt(&buf, Int32(2))
        
        
        case .MissingField:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidEntryType:
            writeInt(&buf, Int32(4))
        
        
        case .EncodingError:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension ParseError: Equatable, Hashable {}

extension ParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


/**
 * Error type for PDF operations.
 *
 * Exposed to Swift via UniFFI.
 */
public enum PdfError {

    
    
    case LoadError(String
    )
    case ExtractionError(String
    )
    case PdfiumNotAvailable
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfError: FfiConverterRustBuffer {
    typealias SwiftType = PdfError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .LoadError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ExtractionError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PdfiumNotAvailable

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PdfError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .LoadError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ExtractionError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .PdfiumNotAvailable:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension PdfError: Equatable, Hashable {}

extension PdfError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of PDF link
 */

public enum PdfLinkType {
    
    case direct
    case landing
    case arXiv
    case publisher
    case openAccess
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePdfLinkType: FfiConverterRustBuffer {
    typealias SwiftType = PdfLinkType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PdfLinkType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .direct
        
        case 2: return .landing
        
        case 3: return .arXiv
        
        case 4: return .publisher
        
        case 5: return .openAccess
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PdfLinkType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .direct:
            writeInt(&buf, Int32(1))
        
        
        case .landing:
            writeInt(&buf, Int32(2))
        
        
        case .arXiv:
            writeInt(&buf, Int32(3))
        
        
        case .publisher:
            writeInt(&buf, Int32(4))
        
        
        case .openAccess:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfLinkType_lift(_ buf: RustBuffer) throws -> PdfLinkType {
    return try FfiConverterTypePdfLinkType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePdfLinkType_lower(_ value: PdfLinkType) -> RustBuffer {
    return FfiConverterTypePdfLinkType.lower(value)
}



extension PdfLinkType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Boolean logic for combining search terms
 */

public enum QueryLogic {
    
    case and
    case or
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQueryLogic: FfiConverterRustBuffer {
    typealias SwiftType = QueryLogic

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueryLogic {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .and
        
        case 2: return .or
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QueryLogic, into buf: inout [UInt8]) {
        switch value {
        
        
        case .and:
            writeInt(&buf, Int32(1))
        
        
        case .or:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryLogic_lift(_ buf: RustBuffer) throws -> QueryLogic {
    return try FfiConverterTypeQueryLogic.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryLogic_lower(_ value: QueryLogic) -> RustBuffer {
    return FfiConverterTypeQueryLogic.lower(value)
}



extension QueryLogic: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * RIS reference type
 */

public enum RisType {
    
    case abst
    case advs
    case aggr
    case ancient
    case art
    case bill
    case blog
    case book
    case `case`
    case chap
    case chart
    case clswk
    case comp
    case conf
    case cpaper
    case ctlg
    case data
    case dbase
    case dict
    case ebook
    case echap
    case edbook
    case ejour
    case elec
    case encyc
    case equa
    case figure
    case gen
    case govdoc
    case grant
    case hear
    case icomm
    case inpr
    case jfull
    case jour
    case legal
    case manscpt
    case map
    case mgzn
    case mpct
    case multi
    case music
    case news
    case pamp
    case pat
    case pcomm
    case rprt
    case ser
    case slide
    case sound
    case stand
    case stat
    case thes
    case unbill
    case unpb
    case video
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISType: FfiConverterRustBuffer {
    typealias SwiftType = RisType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .abst
        
        case 2: return .advs
        
        case 3: return .aggr
        
        case 4: return .ancient
        
        case 5: return .art
        
        case 6: return .bill
        
        case 7: return .blog
        
        case 8: return .book
        
        case 9: return .`case`
        
        case 10: return .chap
        
        case 11: return .chart
        
        case 12: return .clswk
        
        case 13: return .comp
        
        case 14: return .conf
        
        case 15: return .cpaper
        
        case 16: return .ctlg
        
        case 17: return .data
        
        case 18: return .dbase
        
        case 19: return .dict
        
        case 20: return .ebook
        
        case 21: return .echap
        
        case 22: return .edbook
        
        case 23: return .ejour
        
        case 24: return .elec
        
        case 25: return .encyc
        
        case 26: return .equa
        
        case 27: return .figure
        
        case 28: return .gen
        
        case 29: return .govdoc
        
        case 30: return .grant
        
        case 31: return .hear
        
        case 32: return .icomm
        
        case 33: return .inpr
        
        case 34: return .jfull
        
        case 35: return .jour
        
        case 36: return .legal
        
        case 37: return .manscpt
        
        case 38: return .map
        
        case 39: return .mgzn
        
        case 40: return .mpct
        
        case 41: return .multi
        
        case 42: return .music
        
        case 43: return .news
        
        case 44: return .pamp
        
        case 45: return .pat
        
        case 46: return .pcomm
        
        case 47: return .rprt
        
        case 48: return .ser
        
        case 49: return .slide
        
        case 50: return .sound
        
        case 51: return .stand
        
        case 52: return .stat
        
        case 53: return .thes
        
        case 54: return .unbill
        
        case 55: return .unpb
        
        case 56: return .video
        
        case 57: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RisType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .abst:
            writeInt(&buf, Int32(1))
        
        
        case .advs:
            writeInt(&buf, Int32(2))
        
        
        case .aggr:
            writeInt(&buf, Int32(3))
        
        
        case .ancient:
            writeInt(&buf, Int32(4))
        
        
        case .art:
            writeInt(&buf, Int32(5))
        
        
        case .bill:
            writeInt(&buf, Int32(6))
        
        
        case .blog:
            writeInt(&buf, Int32(7))
        
        
        case .book:
            writeInt(&buf, Int32(8))
        
        
        case .`case`:
            writeInt(&buf, Int32(9))
        
        
        case .chap:
            writeInt(&buf, Int32(10))
        
        
        case .chart:
            writeInt(&buf, Int32(11))
        
        
        case .clswk:
            writeInt(&buf, Int32(12))
        
        
        case .comp:
            writeInt(&buf, Int32(13))
        
        
        case .conf:
            writeInt(&buf, Int32(14))
        
        
        case .cpaper:
            writeInt(&buf, Int32(15))
        
        
        case .ctlg:
            writeInt(&buf, Int32(16))
        
        
        case .data:
            writeInt(&buf, Int32(17))
        
        
        case .dbase:
            writeInt(&buf, Int32(18))
        
        
        case .dict:
            writeInt(&buf, Int32(19))
        
        
        case .ebook:
            writeInt(&buf, Int32(20))
        
        
        case .echap:
            writeInt(&buf, Int32(21))
        
        
        case .edbook:
            writeInt(&buf, Int32(22))
        
        
        case .ejour:
            writeInt(&buf, Int32(23))
        
        
        case .elec:
            writeInt(&buf, Int32(24))
        
        
        case .encyc:
            writeInt(&buf, Int32(25))
        
        
        case .equa:
            writeInt(&buf, Int32(26))
        
        
        case .figure:
            writeInt(&buf, Int32(27))
        
        
        case .gen:
            writeInt(&buf, Int32(28))
        
        
        case .govdoc:
            writeInt(&buf, Int32(29))
        
        
        case .grant:
            writeInt(&buf, Int32(30))
        
        
        case .hear:
            writeInt(&buf, Int32(31))
        
        
        case .icomm:
            writeInt(&buf, Int32(32))
        
        
        case .inpr:
            writeInt(&buf, Int32(33))
        
        
        case .jfull:
            writeInt(&buf, Int32(34))
        
        
        case .jour:
            writeInt(&buf, Int32(35))
        
        
        case .legal:
            writeInt(&buf, Int32(36))
        
        
        case .manscpt:
            writeInt(&buf, Int32(37))
        
        
        case .map:
            writeInt(&buf, Int32(38))
        
        
        case .mgzn:
            writeInt(&buf, Int32(39))
        
        
        case .mpct:
            writeInt(&buf, Int32(40))
        
        
        case .multi:
            writeInt(&buf, Int32(41))
        
        
        case .music:
            writeInt(&buf, Int32(42))
        
        
        case .news:
            writeInt(&buf, Int32(43))
        
        
        case .pamp:
            writeInt(&buf, Int32(44))
        
        
        case .pat:
            writeInt(&buf, Int32(45))
        
        
        case .pcomm:
            writeInt(&buf, Int32(46))
        
        
        case .rprt:
            writeInt(&buf, Int32(47))
        
        
        case .ser:
            writeInt(&buf, Int32(48))
        
        
        case .slide:
            writeInt(&buf, Int32(49))
        
        
        case .sound:
            writeInt(&buf, Int32(50))
        
        
        case .stand:
            writeInt(&buf, Int32(51))
        
        
        case .stat:
            writeInt(&buf, Int32(52))
        
        
        case .thes:
            writeInt(&buf, Int32(53))
        
        
        case .unbill:
            writeInt(&buf, Int32(54))
        
        
        case .unpb:
            writeInt(&buf, Int32(55))
        
        
        case .video:
            writeInt(&buf, Int32(56))
        
        
        case .unknown:
            writeInt(&buf, Int32(57))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISType_lift(_ buf: RustBuffer) throws -> RisType {
    return try FfiConverterTypeRISType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISType_lower(_ value: RisType) -> RustBuffer {
    return FfiConverterTypeRISType.lower(value)
}



extension RisType: Equatable, Hashable {}




public enum SearchIndexError {

    
    
    case IndexError(String
    )
    case QueryError(String
    )
    case IoError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSearchIndexError: FfiConverterRustBuffer {
    typealias SwiftType = SearchIndexError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchIndexError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .IndexError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .QueryError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .IoError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SearchIndexError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .IndexError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .QueryError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .IoError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SearchIndexError: Equatable, Hashable {}

extension SearchIndexError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Online source for search results
 */

public enum Source {
    
    case arXiv
    case crossref
    case ads
    case pubMed
    case openAlex
    case dblp
    case semanticScholar
    case sciX
    case local
    case manual
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSource: FfiConverterRustBuffer {
    typealias SwiftType = Source

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Source {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .arXiv
        
        case 2: return .crossref
        
        case 3: return .ads
        
        case 4: return .pubMed
        
        case 5: return .openAlex
        
        case 6: return .dblp
        
        case 7: return .semanticScholar
        
        case 8: return .sciX
        
        case 9: return .local
        
        case 10: return .manual
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Source, into buf: inout [UInt8]) {
        switch value {
        
        
        case .arXiv:
            writeInt(&buf, Int32(1))
        
        
        case .crossref:
            writeInt(&buf, Int32(2))
        
        
        case .ads:
            writeInt(&buf, Int32(3))
        
        
        case .pubMed:
            writeInt(&buf, Int32(4))
        
        
        case .openAlex:
            writeInt(&buf, Int32(5))
        
        
        case .dblp:
            writeInt(&buf, Int32(6))
        
        
        case .semanticScholar:
            writeInt(&buf, Int32(7))
        
        
        case .sciX:
            writeInt(&buf, Int32(8))
        
        
        case .local:
            writeInt(&buf, Int32(9))
        
        
        case .manual:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSource_lift(_ buf: RustBuffer) throws -> Source {
    return try FfiConverterTypeSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSource_lower(_ value: Source) -> RustBuffer {
    return FfiConverterTypeSource.lower(value)
}



extension Source: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Severity of a validation error
 */

public enum ValidationSeverity {
    
    case error
    case warning
    case info
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationSeverity: FfiConverterRustBuffer {
    typealias SwiftType = ValidationSeverity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationSeverity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warning
        
        case 3: return .info
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ValidationSeverity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warning:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSeverity_lift(_ buf: RustBuffer) throws -> ValidationSeverity {
    return try FfiConverterTypeValidationSeverity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationSeverity_lower(_ value: ValidationSeverity) -> RustBuffer {
    return FfiConverterTypeValidationSeverity.lower(value)
}



extension ValidationSeverity: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConflict: FfiConverterRustBuffer {
    typealias SwiftType = Conflict?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConflict.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConflict.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeParsedArXivForm: FfiConverterRustBuffer {
    typealias SwiftType = ParsedArXivForm?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeParsedArXivForm.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeParsedArXivForm.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeParsedClassicForm: FfiConverterRustBuffer {
    typealias SwiftType = ParsedClassicForm?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeParsedClassicForm.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeParsedClassicForm.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeParsedPaperForm: FfiConverterRustBuffer {
    typealias SwiftType = ParsedPaperForm?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeParsedPaperForm.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeParsedPaperForm.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePreferredIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = PreferredIdentifier?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePreferredIdentifier.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePreferredIdentifier.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePublication: FfiConverterRustBuffer {
    typealias SwiftType = Publication?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublication.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublication.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAutomationCommand: FfiConverterRustBuffer {
    typealias SwiftType = AutomationCommand?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAutomationCommand.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAutomationCommand.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeHelpPlatform: FfiConverterRustBuffer {
    typealias SwiftType = HelpPlatform?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHelpPlatform.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHelpPlatform.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceFloat: FfiConverterRustBuffer {
    typealias SwiftType = [Float]

    public static func write(_ value: [Float], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterFloat.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Float] {
        let len: Int32 = try readInt(&buf)
        var seq = [Float]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterFloat.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnIndexItem: FfiConverterRustBuffer {
    typealias SwiftType = [AnnIndexItem]

    public static func write(_ value: [AnnIndexItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnIndexItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AnnIndexItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [AnnIndexItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnIndexItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnSimilarityResult: FfiConverterRustBuffer {
    typealias SwiftType = [AnnSimilarityResult]

    public static func write(_ value: [AnnSimilarityResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnSimilarityResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AnnSimilarityResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [AnnSimilarityResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnSimilarityResult.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnotation: FfiConverterRustBuffer {
    typealias SwiftType = [Annotation]

    public static func write(_ value: [Annotation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnotation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Annotation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Annotation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnotation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAuthor: FfiConverterRustBuffer {
    typealias SwiftType = [Author]

    public static func write(_ value: [Author], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Author] {
        let len: Int32 = try readInt(&buf)
        var seq = [Author]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAuthor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXEntry: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXEntry]

    public static func write(_ value: [BibTeXEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXField: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXField]

    public static func write(_ value: [BibTeXField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXField] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXField.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXParseError: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXParseError]

    public static func write(_ value: [BibTeXParseError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXParseError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXParseError] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXParseError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXParseError.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDeduplicatedGroup: FfiConverterRustBuffer {
    typealias SwiftType = [DeduplicatedGroup]

    public static func write(_ value: [DeduplicatedGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDeduplicatedGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DeduplicatedGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [DeduplicatedGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDeduplicatedGroup.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDeduplicationInput: FfiConverterRustBuffer {
    typealias SwiftType = [DeduplicationInput]

    public static func write(_ value: [DeduplicationInput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDeduplicationInput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DeduplicationInput] {
        let len: Int32 = try readInt(&buf)
        var seq = [DeduplicationInput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDeduplicationInput.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDrawingAnnotation: FfiConverterRustBuffer {
    typealias SwiftType = [DrawingAnnotation]

    public static func write(_ value: [DrawingAnnotation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDrawingAnnotation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DrawingAnnotation] {
        let len: Int32 = try readInt(&buf)
        var seq = [DrawingAnnotation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDrawingAnnotation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDrawingStroke: FfiConverterRustBuffer {
    typealias SwiftType = [DrawingStroke]

    public static func write(_ value: [DrawingStroke], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDrawingStroke.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DrawingStroke] {
        let len: Int32 = try readInt(&buf)
        var seq = [DrawingStroke]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDrawingStroke.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDuplicateGroup: FfiConverterRustBuffer {
    typealias SwiftType = [DuplicateGroup]

    public static func write(_ value: [DuplicateGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDuplicateGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DuplicateGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [DuplicateGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDuplicateGroup.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExtractedIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ExtractedIdentifier]

    public static func write(_ value: [ExtractedIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExtractedIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExtractedIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExtractedIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExtractedIdentifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHelpSearchResult: FfiConverterRustBuffer {
    typealias SwiftType = [HelpSearchResult]

    public static func write(_ value: [HelpSearchResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHelpSearchResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HelpSearchResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [HelpSearchResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHelpSearchResult.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLinkedFile: FfiConverterRustBuffer {
    typealias SwiftType = [LinkedFile]

    public static func write(_ value: [LinkedFile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLinkedFile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LinkedFile] {
        let len: Int32 = try readInt(&buf)
        var seq = [LinkedFile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLinkedFile.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePageText: FfiConverterRustBuffer {
    typealias SwiftType = [PageText]

    public static func write(_ value: [PageText], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePageText.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PageText] {
        let len: Int32 = try readInt(&buf)
        var seq = [PageText]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePageText.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaperStub: FfiConverterRustBuffer {
    typealias SwiftType = [PaperStub]

    public static func write(_ value: [PaperStub], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaperStub.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaperStub] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaperStub]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaperStub.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParsedArXivTerm: FfiConverterRustBuffer {
    typealias SwiftType = [ParsedArXivTerm]

    public static func write(_ value: [ParsedArXivTerm], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParsedArXivTerm.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParsedArXivTerm] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParsedArXivTerm]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParsedArXivTerm.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePdfLink: FfiConverterRustBuffer {
    typealias SwiftType = [PdfLink]

    public static func write(_ value: [PdfLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePdfLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PdfLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [PdfLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePdfLink.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePoint: FfiConverterRustBuffer {
    typealias SwiftType = [Point]

    public static func write(_ value: [Point], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Point] {
        let len: Int32 = try readInt(&buf)
        var seq = [Point]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePublication: FfiConverterRustBuffer {
    typealias SwiftType = [Publication]

    public static func write(_ value: [Publication], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublication.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Publication] {
        let len: Int32 = try readInt(&buf)
        var seq = [Publication]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublication.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRISEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RisEntry]

    public static func write(_ value: [RisEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRISEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RisEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RisEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRISEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRISTag: FfiConverterRustBuffer {
    typealias SwiftType = [RisTag]

    public static func write(_ value: [RisTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRISTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RisTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [RisTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRISTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRect: FfiConverterRustBuffer {
    typealias SwiftType = [Rect]

    public static func write(_ value: [Rect], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRect.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rect] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rect]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRect.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSearchHit: FfiConverterRustBuffer {
    typealias SwiftType = [SearchHit]

    public static func write(_ value: [SearchHit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSearchHit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SearchHit] {
        let len: Int32 = try readInt(&buf)
        var seq = [SearchHit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSearchHit.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSearchResult: FfiConverterRustBuffer {
    typealias SwiftType = [SearchResult]

    public static func write(_ value: [SearchResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSearchResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SearchResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [SearchResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSearchResult.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTextMatch: FfiConverterRustBuffer {
    typealias SwiftType = [TextMatch]

    public static func write(_ value: [TextMatch], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTextMatch.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TextMatch] {
        let len: Int32 = try readInt(&buf)
        var seq = [TextMatch]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTextMatch.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeValidationError: FfiConverterRustBuffer {
    typealias SwiftType = [ValidationError]

    public static func write(_ value: [ValidationError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidationError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidationError] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidationError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValidationError.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnnotationOperation: FfiConverterRustBuffer {
    typealias SwiftType = [AnnotationOperation]

    public static func write(_ value: [AnnotationOperation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnnotationOperation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AnnotationOperation] {
        let len: Int32 = try readInt(&buf)
        var seq = [AnnotationOperation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnnotationOperation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
/**
 * Add an embedding to the index
 */
public func annIndexAdd(handleId: UInt64, publicationId: String, embedding: [Float]) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_add(
        FfiConverterUInt64.lower(handleId),
        FfiConverterString.lower(publicationId),
        FfiConverterSequenceFloat.lower(embedding),$0
    )
})
}
/**
 * Add multiple embeddings at once
 */
public func annIndexAddBatch(handleId: UInt64, items: [AnnIndexItem]) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_add_batch(
        FfiConverterUInt64.lower(handleId),
        FfiConverterSequenceTypeAnnIndexItem.lower(items),$0
    )
})
}
/**
 * Close and release an index
 */
public func annIndexClose(handleId: UInt64) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_close(
        FfiConverterUInt64.lower(handleId),$0
    )
})
}
/**
 * Create a new ANN index, returns a handle
 */
public func annIndexCreate() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_create($0
    )
})
}
/**
 * Create a new ANN index with custom configuration
 */
public func annIndexCreateWithConfig(maxConnections: UInt32, capacity: UInt32, maxLayer: UInt32, efConstruction: UInt32) -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_create_with_config(
        FfiConverterUInt32.lower(maxConnections),
        FfiConverterUInt32.lower(capacity),
        FfiConverterUInt32.lower(maxLayer),
        FfiConverterUInt32.lower(efConstruction),$0
    )
})
}
/**
 * Get the number of active index handles (for debugging)
 */
public func annIndexHandleCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_handle_count($0
    )
})
}
/**
 * Search for similar items
 */
public func annIndexSearch(handleId: UInt64, query: [Float], topK: UInt32) -> [AnnSimilarityResult] {
    return try!  FfiConverterSequenceTypeAnnSimilarityResult.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_search(
        FfiConverterUInt64.lower(handleId),
        FfiConverterSequenceFloat.lower(query),
        FfiConverterUInt32.lower(topK),$0
    )
})
}
/**
 * Get the number of items in the index
 */
public func annIndexSize(handleId: UInt64) -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ann_index_size(
        FfiConverterUInt64.lower(handleId),$0
    )
})
}
public func authorsOverlap(authors1: String, authors2: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_authors_overlap(
        FfiConverterString.lower(authors1),
        FfiConverterString.lower(authors2),$0
    )
})
}
public func bdskFileCreateFields(paths: [String]) -> [String: String] {
    return try!  FfiConverterDictionaryStringString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bdsk_file_create_fields(
        FfiConverterSequenceString.lower(paths),$0
    )
})
}
public func bdskFileDecode(value: String) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bdsk_file_decode(
        FfiConverterString.lower(value),$0
    )
})
}
public func bdskFileEncode(relativePath: String) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bdsk_file_encode(
        FfiConverterString.lower(relativePath),$0
    )
})
}
public func bdskFileExtractAll(fields: [String: String]) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bdsk_file_extract_all(
        FfiConverterDictionaryStringString.lower(fields),$0
    )
})
}
public func bibtexFormatEntries(entries: [BibTeXEntry]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bibtex_format_entries(
        FfiConverterSequenceTypeBibTeXEntry.lower(entries),$0
    )
})
}
public func bibtexFormatEntry(entry: BibTeXEntry) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bibtex_format_entry(
        FfiConverterTypeBibTeXEntry.lower(entry),$0
    )
})
}
/**
 * These wrap the internal functions with prefixed names to avoid conflicts
 */
public func bibtexParse(input: String)throws  -> BibTeXParseResult {
    return try  FfiConverterTypeBibTeXParseResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_bibtex_parse(
        FfiConverterString.lower(input),$0
    )
})
}
public func bibtexParseEntry(input: String)throws  -> BibTeXEntry {
    return try  FfiConverterTypeBibTeXEntry.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_bibtex_parse_entry(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Build arXiv API query from user query
 *
 * Supports field prefixes:
 * - cat:cs.LG - Category
 * - au:Author - Author
 * - ti:Title - Title
 * - abs:Abstract - Abstract
 * - id:2301.12345 - arXiv ID
 */
public func buildApiQuery(userQuery: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_api_query(
        FfiConverterString.lower(userQuery),$0
    )
})
}
/**
 * Build an arXiv API query for author + categories.
 *
 * # Arguments
 * * `author` - Author name to search for
 * * `categories` - List of arXiv category IDs (e.g., "astro-ph.GA", "hep-th")
 * * `include_cross_listed` - Whether to include cross-listed papers (currently unused)
 *
 * # Returns
 * arXiv API query string
 */
public func buildArxivAuthorCategoryQuery(author: String, categories: [String], includeCrossListed: Bool) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_arxiv_author_category_query(
        FfiConverterString.lower(author),
        FfiConverterSequenceString.lower(categories),
        FfiConverterBool.lower(includeCrossListed),$0
    )
})
}
/**
 * Build an ADS query from classic form fields.
 *
 * # Arguments
 * * `authors` - Newline-separated author names
 * * `objects` - SIMBAD/NED object names
 * * `title_words` - Space-separated title words
 * * `title_logic` - AND/OR logic for title words
 * * `abstract_words` - Space-separated abstract/keyword words
 * * `abstract_logic` - AND/OR logic for abstract words
 * * `year_from` - Start year (optional)
 * * `year_to` - End year (optional)
 * * `database` - ADS database selection
 * * `refereed_only` - Only peer-reviewed papers
 * * `articles_only` - Only journal articles
 *
 * # Returns
 * ADS query string
 */
public func buildClassicQuery(authors: String, objects: String, titleWords: String, titleLogic: QueryLogic, abstractWords: String, abstractLogic: QueryLogic, yearFrom: Int32?, yearTo: Int32?, database: AdsDatabase, refereedOnly: Bool, articlesOnly: Bool) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_classic_query(
        FfiConverterString.lower(authors),
        FfiConverterString.lower(objects),
        FfiConverterString.lower(titleWords),
        FfiConverterTypeQueryLogic.lower(titleLogic),
        FfiConverterString.lower(abstractWords),
        FfiConverterTypeQueryLogic.lower(abstractLogic),
        FfiConverterOptionInt32.lower(yearFrom),
        FfiConverterOptionInt32.lower(yearTo),
        FfiConverterTypeADSDatabase.lower(database),
        FfiConverterBool.lower(refereedOnly),
        FfiConverterBool.lower(articlesOnly),$0
    )
})
}
public func buildInsertCitationUrl(citeKey: String, documentId: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_insert_citation_url(
        FfiConverterString.lower(citeKey),
        FfiConverterOptionString.lower(documentId),$0
    )
})
}
public func buildLookupUrl(doi: String?, arxivId: String?, title: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_lookup_url(
        FfiConverterOptionString.lower(doi),
        FfiConverterOptionString.lower(arxivId),
        FfiConverterOptionString.lower(title),$0
    )
})
}
public func buildOpenManuscriptUrl(manuscriptId: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_open_manuscript_url(
        FfiConverterString.lower(manuscriptId),$0
    )
})
}
public func buildOpenUrl(doi: String?, arxivId: String?, citeKey: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_open_url(
        FfiConverterOptionString.lower(doi),
        FfiConverterOptionString.lower(arxivId),
        FfiConverterOptionString.lower(citeKey),$0
    )
})
}
/**
 * Build an ADS query from paper identifier fields.
 *
 * # Arguments
 * * `bibcode` - ADS bibcode
 * * `doi` - Digital Object Identifier
 * * `arxiv_id` - arXiv identifier (old or new format)
 *
 * # Returns
 * ADS query string (identifiers joined with OR)
 */
public func buildPaperQuery(bibcode: String, doi: String, arxivId: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_paper_query(
        FfiConverterString.lower(bibcode),
        FfiConverterString.lower(doi),
        FfiConverterString.lower(arxivId),$0
    )
})
}
public func buildSearchUrl(query: String, source: String?, maxResults: Int32?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_search_url(
        FfiConverterString.lower(query),
        FfiConverterOptionString.lower(source),
        FfiConverterOptionInt32.lower(maxResults),$0
    )
})
}
public func buildSyncBibliographyUrl(documentId: String, action: BibSyncAction) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_build_sync_bibliography_url(
        FfiConverterString.lower(documentId),
        FfiConverterTypeBibSyncAction.lower(action),$0
    )
})
}
public func calculatePublicationSimilarity(a: Publication, b: Publication) -> DeduplicationMatch {
    return try!  FfiConverterTypeDeduplicationMatch.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_calculate_publication_similarity(
        FfiConverterTypePublication.lower(a),
        FfiConverterTypePublication.lower(b),$0
    )
})
}
public func calculateSimilarity(entry1: BibTeXEntry, entry2: BibTeXEntry) -> DeduplicationMatch {
    return try!  FfiConverterTypeDeduplicationMatch.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_calculate_similarity(
        FfiConverterTypeBibTeXEntry.lower(entry1),
        FfiConverterTypeBibTeXEntry.lower(entry2),$0
    )
})
}
public func canResolveToSource(identifiers: [String: String], source: EnrichmentSource) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_can_resolve_to_source(
        FfiConverterDictionaryStringString.lower(identifiers),
        FfiConverterTypeEnrichmentSource.lower(source),$0
    )
})
}
/**
 * Decode HTML entities to their Unicode equivalents
 */
public func decodeHtmlEntities(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_decode_html_entities(
        FfiConverterString.lower(text),$0
    )
})
}
public func decodeLatex(input: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_decode_latex(
        FfiConverterString.lower(input),$0
    )
})
}
public func deduplicateSearchResults(results: [DeduplicationInput], config: DeduplicationConfig) -> [DeduplicatedGroup] {
    return try!  FfiConverterSequenceTypeDeduplicatedGroup.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_deduplicate_search_results(
        FfiConverterSequenceTypeDeduplicationInput.lower(results),
        FfiConverterTypeDeduplicationConfig.lower(config),$0
    )
})
}
public func defaultDeduplicationConfig() -> DeduplicationConfig {
    return try!  FfiConverterTypeDeduplicationConfig.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_default_deduplication_config($0
    )
})
}
/**
 * Get default export options
 */
public func defaultExportOptions() -> ExportOptions {
    return try!  FfiConverterTypeExportOptions.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_default_export_options($0
    )
})
}
public func defaultFilenameOptions() -> FilenameOptions {
    return try!  FfiConverterTypeFilenameOptions.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_default_filename_options($0
    )
})
}
/**
 * Deserialize annotations from JSON
 */
public func deserializeAnnotations(json: String)throws  -> PublicationAnnotations {
    return try  FfiConverterTypePublicationAnnotations.lift(try rustCallWithError(FfiConverterTypeAnnotationStorageError.lift) {
    uniffi_imbib_core_fn_func_deserialize_annotations(
        FfiConverterString.lower(json),$0
    )
})
}
public func detectConflict(local: Publication, remote: Publication, base: Publication?) -> Conflict? {
    return try!  FfiConverterOptionTypeConflict.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_detect_conflict(
        FfiConverterTypePublication.lower(local),
        FfiConverterTypePublication.lower(remote),
        FfiConverterOptionTypePublication.lower(base),$0
    )
})
}
public func detectFormat(content: String) -> ImportFormat {
    return try!  FfiConverterTypeImportFormat.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_detect_format(
        FfiConverterString.lower(content),$0
    )
})
}
public func enrichmentCapabilityDisplayName(capability: EnrichmentCapability) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_enrichment_capability_display_name(
        FfiConverterTypeEnrichmentCapability.lower(capability),$0
    )
})
}
public func enrichmentDataIsStale(data: EnrichmentData, thresholdDays: Int32) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_enrichment_data_is_stale(
        FfiConverterTypeEnrichmentData.lower(data),
        FfiConverterInt32.lower(thresholdDays),$0
    )
})
}
public func enrichmentPriorityDisplayName(priority: EnrichmentPriority) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_enrichment_priority_display_name(
        FfiConverterTypeEnrichmentPriority.lower(priority),$0
    )
})
}
public func enrichmentSourceDisplayName(source: EnrichmentSource) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_enrichment_source_display_name(
        FfiConverterTypeEnrichmentSource.lower(source),$0
    )
})
}
public func expandJournalMacro(value: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_expand_journal_macro(
        FfiConverterString.lower(value),$0
    )
})
}
/**
 * Export single publication to BibTeX
 */
public func exportBibtex(publication: Publication, options: ExportOptions) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_export_bibtex(
        FfiConverterTypePublication.lower(publication),
        FfiConverterTypeExportOptions.lower(options),$0
    )
})
}
/**
 * Export multiple publications to BibTeX
 */
public func exportBibtexMultiple(publications: [Publication], options: ExportOptions) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_export_bibtex_multiple(
        FfiConverterSequenceTypePublication.lower(publications),
        FfiConverterTypeExportOptions.lower(options),$0
    )
})
}
/**
 * Export single publication to RIS
 */
public func exportRis(publication: Publication) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_export_ris(
        FfiConverterTypePublication.lower(publication),$0
    )
})
}
/**
 * Export multiple publications to RIS
 */
public func exportRisMultiple(publications: [Publication]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_export_ris_multiple(
        FfiConverterSequenceTypePublication.lower(publications),$0
    )
})
}
public func extractAll(text: String) -> [ExtractedIdentifier] {
    return try!  FfiConverterSequenceTypeExtractedIdentifier.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_all(
        FfiConverterString.lower(text),$0
    )
})
}
public func extractArxivIds(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_arxiv_ids(
        FfiConverterString.lower(text),$0
    )
})
}
public func extractDois(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_dois(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Extract the first author's last name from a BibTeX author field.
 *
 * Handles both "Last, First" and "First Last" formats.
 * Returns "Unknown" if no author is provided.
 */
public func extractFirstAuthorLastName(authorField: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_first_author_last_name(
        FfiConverterString.lower(authorField),$0
    )
})
}
/**
 * Extract the first meaningful word from a title for cite key generation.
 *
 * Skips common stop words and returns a capitalized word of at least 3 characters.
 */
public func extractFirstMeaningfulWord(title: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_first_meaningful_word(
        FfiConverterString.lower(title),$0
    )
})
}
public func extractIsbns(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_isbns(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Extract a snippet around query terms
 */
public func extractSnippet(text: String, queryTerms: [String], contextChars: UInt32) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_snippet(
        FfiConverterString.lower(text),
        FfiConverterSequenceString.lower(queryTerms),
        FfiConverterUInt32.lower(contextChars),$0
    )
})
}
/**
 * Extract surname from an author name.
 *
 * Handles both "Last, First" and "First Last" formats.
 */
public func extractSurname(author: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_surname(
        FfiConverterString.lower(author),$0
    )
})
}
public func findDuplicates(publications: [Publication], threshold: Double) -> [DuplicateGroup] {
    return try!  FfiConverterSequenceTypeDuplicateGroup.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_find_duplicates(
        FfiConverterSequenceTypePublication.lower(publications),
        FfiConverterDouble.lower(threshold),$0
    )
})
}
public func fuzzyMatchResults(a: DeduplicationInput, b: DeduplicationInput, titleThreshold: Double) -> Double? {
    return try!  FfiConverterOptionDouble.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_fuzzy_match_results(
        FfiConverterTypeDeduplicationInput.lower(a),
        FfiConverterTypeDeduplicationInput.lower(b),
        FfiConverterDouble.lower(titleThreshold),$0
    )
})
}
public func generateCiteKey(author: String?, year: String?, title: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_cite_key(
        FfiConverterOptionString.lower(author),
        FfiConverterOptionString.lower(year),
        FfiConverterOptionString.lower(title),$0
    )
})
}
/**
 * Generate a cite key with the specified format (UniFFI export)
 */
public func generateCiteKeyFormatted(format: String, author: String?, year: String?, title: String?, lowercase: Bool) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_cite_key_formatted(
        FfiConverterString.lower(format),
        FfiConverterOptionString.lower(author),
        FfiConverterOptionString.lower(year),
        FfiConverterOptionString.lower(title),
        FfiConverterBool.lower(lowercase),$0
    )
})
}
public func generatePdfFilename(publication: Publication, options: FilenameOptions) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_pdf_filename(
        FfiConverterTypePublication.lower(publication),
        FfiConverterTypeFilenameOptions.lower(options),$0
    )
})
}
public func generatePdfFilenameFromMetadata(title: String, authors: [String], year: Int32?, options: FilenameOptions) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_pdf_filename_from_metadata(
        FfiConverterString.lower(title),
        FfiConverterSequenceString.lower(authors),
        FfiConverterOptionInt32.lower(year),
        FfiConverterTypeFilenameOptions.lower(options),$0
    )
})
}
public func generateUniqueCiteKey(author: String?, year: String?, title: String?, existingKeys: [String]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_unique_cite_key(
        FfiConverterOptionString.lower(author),
        FfiConverterOptionString.lower(year),
        FfiConverterOptionString.lower(title),
        FfiConverterSequenceString.lower(existingKeys),$0
    )
})
}
/**
 * Generate a unique cite key with the specified format (UniFFI export)
 */
public func generateUniqueCiteKeyFormatted(format: String, author: String?, year: String?, title: String?, lowercase: Bool, existingKeys: [String]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_unique_cite_key_formatted(
        FfiConverterString.lower(format),
        FfiConverterOptionString.lower(author),
        FfiConverterOptionString.lower(year),
        FfiConverterOptionString.lower(title),
        FfiConverterBool.lower(lowercase),
        FfiConverterSequenceString.lower(existingKeys),$0
    )
})
}
public func getAllJournalMacroNames() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_get_all_journal_macro_names($0
    )
})
}
/**
 * Hello world function to verify FFI setup
 */
public func helloFromRust() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_hello_from_rust($0
    )
})
}
/**
 * Add a help document to the index
 */
public func helpIndexAddDocument(handleId: UInt64, document: HelpDocument)throws  {try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_add_document(
        FfiConverterUInt64.lower(handleId),
        FfiConverterTypeHelpDocument.lower(document),$0
    )
}
}
/**
 * Close and release a help index handle
 */
public func helpIndexClose(handleId: UInt64)throws  {try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_close(
        FfiConverterUInt64.lower(handleId),$0
    )
}
}
/**
 * Commit pending changes
 */
public func helpIndexCommit(handleId: UInt64)throws  {try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_commit(
        FfiConverterUInt64.lower(handleId),$0
    )
}
}
/**
 * Create a new help search index at the given path
 */
public func helpIndexCreate(path: String)throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_create(
        FfiConverterString.lower(path),$0
    )
})
}
/**
 * Create an in-memory help search index
 */
public func helpIndexCreateInMemory()throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_create_in_memory($0
    )
})
}
/**
 * Get the number of active help index handles
 */
public func helpIndexHandleCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_help_index_handle_count($0
    )
})
}
/**
 * Search the help index
 */
public func helpIndexSearch(handleId: UInt64, query: String, limit: UInt32, platform: HelpPlatform?)throws  -> [HelpSearchResult] {
    return try  FfiConverterSequenceTypeHelpSearchResult.lift(try rustCallWithError(FfiConverterTypeHelpSearchError.lift) {
    uniffi_imbib_core_fn_func_help_index_search(
        FfiConverterUInt64.lower(handleId),
        FfiConverterString.lower(query),
        FfiConverterUInt32.lower(limit),
        FfiConverterOptionTypeHelpPlatform.lower(platform),$0
    )
})
}
/**
 * Highlight query terms in text
 */
public func highlightTerms(text: String, queryTerms: [String], highlightStart: String, highlightEnd: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_highlight_terms(
        FfiConverterString.lower(text),
        FfiConverterSequenceString.lower(queryTerms),
        FfiConverterString.lower(highlightStart),
        FfiConverterString.lower(highlightEnd),$0
    )
})
}
public func identifierDisplayName(idType: IdentifierType) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_identifier_display_name(
        FfiConverterTypeIdentifierType.lower(idType),$0
    )
})
}
public func identifierUrl(idType: IdentifierType, value: String) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_identifier_url(
        FfiConverterTypeIdentifierType.lower(idType),
        FfiConverterString.lower(value),$0
    )
})
}
public func identifierUrlPrefix(idType: IdentifierType) -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_identifier_url_prefix(
        FfiConverterTypeIdentifierType.lower(idType),$0
    )
})
}
public func importAuto(content: String)throws  -> ImportResult {
    return try  FfiConverterTypeImportResult.lift(try rustCallWithError(FfiConverterTypeImportError.lift) {
    uniffi_imbib_core_fn_func_import_auto(
        FfiConverterString.lower(content),$0
    )
})
}
public func importBibtex(content: String)throws  -> ImportResult {
    return try  FfiConverterTypeImportResult.lift(try rustCallWithError(FfiConverterTypeImportError.lift) {
    uniffi_imbib_core_fn_func_import_bibtex(
        FfiConverterString.lower(content),$0
    )
})
}
public func importRis(content: String)throws  -> ImportResult {
    return try  FfiConverterTypeImportResult.lift(try rustCallWithError(FfiConverterTypeImportError.lift) {
    uniffi_imbib_core_fn_func_import_ris(
        FfiConverterString.lower(content),$0
    )
})
}
/**
 * Check if classic form has any search criteria.
 */
public func isClassicFormEmpty(authors: String, objects: String, titleWords: String, abstractWords: String, yearFrom: Int32?, yearTo: Int32?) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_classic_form_empty(
        FfiConverterString.lower(authors),
        FfiConverterString.lower(objects),
        FfiConverterString.lower(titleWords),
        FfiConverterString.lower(abstractWords),
        FfiConverterOptionInt32.lower(yearFrom),
        FfiConverterOptionInt32.lower(yearTo),$0
    )
})
}
public func isJournalMacro(value: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_journal_macro(
        FfiConverterString.lower(value),$0
    )
})
}
/**
 * Check if paper form has any identifier.
 */
public func isPaperFormEmpty(bibcode: String, doi: String, arxivId: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_paper_form_empty(
        FfiConverterString.lower(bibcode),
        FfiConverterString.lower(doi),
        FfiConverterString.lower(arxivId),$0
    )
})
}
/**
 * Check if a publication is valid (no errors)
 */
public func isValid(publication: Publication) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid(
        FfiConverterTypePublication.lower(publication),$0
    )
})
}
public func isValidArxivId(arxivId: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_arxiv_id(
        FfiConverterString.lower(arxivId),$0
    )
})
}
public func isValidDoi(doi: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_doi(
        FfiConverterString.lower(doi),$0
    )
})
}
public func isValidIsbn(isbn: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_isbn(
        FfiConverterString.lower(isbn),$0
    )
})
}
public func makeCiteKeyUnique(base: String, existingKeys: [String]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_make_cite_key_unique(
        FfiConverterString.lower(base),
        FfiConverterSequenceString.lower(existingKeys),$0
    )
})
}
/**
 * Merge two annotation sets (for sync conflicts)
 *
 * Strategy: Keep all unique annotations, prefer newer versions for conflicts
 */
public func mergeAnnotations(local: PublicationAnnotations, remote: PublicationAnnotations) -> PublicationAnnotations {
    return try!  FfiConverterTypePublicationAnnotations.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_merge_annotations(
        FfiConverterTypePublicationAnnotations.lower(local),
        FfiConverterTypePublicationAnnotations.lower(remote),$0
    )
})
}
public func mergePublications(local: Publication, remote: Publication, strategy: MergeStrategy) -> MergeResult {
    return try!  FfiConverterTypeMergeResult.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_merge_publications(
        FfiConverterTypePublication.lower(local),
        FfiConverterTypePublication.lower(remote),
        FfiConverterTypeMergeStrategy.lower(strategy),$0
    )
})
}
public func normalizeAuthorExport(author: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_author_export(
        FfiConverterString.lower(author),$0
    )
})
}
/**
 * Normalize an author name for comparison.
 *
 * - Converts to lowercase
 * - Removes diacritics
 * - Removes titles (Dr., Prof., etc.)
 * - Removes suffixes (Jr., Sr., PhD, etc.)
 */
public func normalizeAuthorName(name: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_author_name(
        FfiConverterString.lower(name),$0
    )
})
}
public func normalizeDoi(doi: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_doi(
        FfiConverterString.lower(doi),$0
    )
})
}
public func normalizeTitleExport(title: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_title_export(
        FfiConverterString.lower(title),$0
    )
})
}
public func openAccessStatusDisplayName(status: OpenAccessStatus) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_open_access_status_display_name(
        FfiConverterTypeOpenAccessStatus.lower(status),$0
    )
})
}
public func parse(input: String)throws  -> BibTeXParseResult {
    return try  FfiConverterTypeBibTeXParseResult.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_imbib_core_fn_func_parse(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Parse ADS BibTeX export response JSON (exported for FFI)
 */
public func parseAdsBibtexExport(json: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_ads_bibtex_export(
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Parse ADS paper stubs response JSON (exported for FFI)
 */
public func parseAdsPaperStubsResponse(json: String)throws  -> [PaperStub] {
    return try  FfiConverterSequenceTypePaperStub.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_ads_paper_stubs_response(
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Parse ADS search response JSON (exported for FFI)
 */
public func parseAdsSearchResponse(json: String)throws  -> [SearchResult] {
    return try  FfiConverterSequenceTypeSearchResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_ads_search_response(
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Try to parse an arXiv query back to form fields
 */
public func parseArxivQuery(query: String) -> ParsedArXivForm? {
    return try!  FfiConverterOptionTypeParsedArXivForm.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_arxiv_query(
        FfiConverterString.lower(query),$0
    )
})
}
/**
 * Parse arXiv Atom XML feed to SearchResults (exported for FFI)
 */
public func parseAtomFeed(xml: String)throws  -> [SearchResult] {
    return try  FfiConverterSequenceTypeSearchResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_atom_feed(
        FfiConverterString.lower(xml),$0
    )
})
}
public func parseAuthorString(input: String) -> [Author] {
    return try!  FfiConverterSequenceTypeAuthor.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_author_string(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Try to parse an ADS query back to classic form fields
 */
public func parseClassicQuery(query: String) -> ParsedClassicForm? {
    return try!  FfiConverterOptionTypeParsedClassicForm.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_classic_query(
        FfiConverterString.lower(query),$0
    )
})
}
/**
 * Parse Crossref search response JSON (exported for FFI)
 */
public func parseCrossrefSearchResponse(json: String)throws  -> [SearchResult] {
    return try  FfiConverterSequenceTypeSearchResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_crossref_search_response(
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Parse Crossref single work response JSON (exported for FFI)
 */
public func parseCrossrefWorkResponse(json: String)throws  -> SearchResult {
    return try  FfiConverterTypeSearchResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_crossref_work_response(
        FfiConverterString.lower(json),$0
    )
})
}
public func parseEntry(input: String)throws  -> BibTeXEntry {
    return try  FfiConverterTypeBibTeXEntry.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_imbib_core_fn_func_parse_entry(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Parse text containing MathML and convert to readable Unicode text.
 *
 * Example input:
 * ```text
 * Text with <inline-formula><mml:math><mml:mi>S</mml:mi><mml:mo>/</mml:mo><mml:mi>N</mml:mi></mml:math></inline-formula> ratio
 * ```
 * Example output:
 * ```text
 * Text with S/N ratio
 * ```
 */
public func parseMathml(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_mathml(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Try to parse an ADS query to paper form fields
 */
public func parsePaperQuery(query: String) -> ParsedPaperForm? {
    return try!  FfiConverterOptionTypeParsedPaperForm.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_paper_query(
        FfiConverterString.lower(query),$0
    )
})
}
/**
 * Parse PubMed efetch XML response (exported for FFI)
 */
public func parsePubmedEfetchResponse(xml: String)throws  -> [SearchResult] {
    return try  FfiConverterSequenceTypeSearchResult.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_pubmed_efetch_response(
        FfiConverterString.lower(xml),$0
    )
})
}
/**
 * Parse PubMed esearch XML response to get PMIDs (exported for FFI)
 */
public func parsePubmedEsearchResponse(xml: String)throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_parse_pubmed_esearch_response(
        FfiConverterString.lower(xml),$0
    )
})
}
public func parseUrlCommand(urlString: String) -> ParseResult {
    return try!  FfiConverterTypeParseResult.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_parse_url_command(
        FfiConverterString.lower(urlString),$0
    )
})
}
/**
 * Extract all text from a PDF file.
 *
 * Returns structured text content with per-page breakdown for search indexing.
 */
public func pdfExtractText(pdfBytes: Data)throws  -> PdfTextResult {
    return try  FfiConverterTypePdfTextResult.lift(try rustCallWithError(FfiConverterTypePdfError.lift) {
    uniffi_imbib_core_fn_func_pdf_extract_text(
        FfiConverterData.lower(pdfBytes),$0
    )
})
}
/**
 * Generate a thumbnail for a PDF page.
 *
 * Returns RGBA pixel data that can be converted to an image.
 * Default config: 200x280 pixels, page 1.
 */
public func pdfGenerateThumbnail(pdfBytes: Data, config: ThumbnailConfig)throws  -> PdfThumbnail {
    return try  FfiConverterTypePdfThumbnail.lift(try rustCallWithError(FfiConverterTypePdfError.lift) {
    uniffi_imbib_core_fn_func_pdf_generate_thumbnail(
        FfiConverterData.lower(pdfBytes),
        FfiConverterTypeThumbnailConfig.lower(config),$0
    )
})
}
/**
 * Get the number of pages in a PDF.
 */
public func pdfGetPageCount(pdfBytes: Data)throws  -> UInt32 {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypePdfError.lift) {
    uniffi_imbib_core_fn_func_pdf_get_page_count(
        FfiConverterData.lower(pdfBytes),$0
    )
})
}
/**
 * Get dimensions of a specific page.
 */
public func pdfGetPageDimensions(pdfBytes: Data, pageNumber: UInt32)throws  -> PageDimensions {
    return try  FfiConverterTypePageDimensions.lift(try rustCallWithError(FfiConverterTypePdfError.lift) {
    uniffi_imbib_core_fn_func_pdf_get_page_dimensions(
        FfiConverterData.lower(pdfBytes),
        FfiConverterUInt32.lower(pageNumber),$0
    )
})
}
/**
 * Search for text within a PDF and return matches with context.
 */
public func pdfSearch(pdfBytes: Data, query: String, maxResults: UInt32)throws  -> [TextMatch] {
    return try  FfiConverterSequenceTypeTextMatch.lift(try rustCallWithError(FfiConverterTypePdfError.lift) {
    uniffi_imbib_core_fn_func_pdf_search(
        FfiConverterData.lower(pdfBytes),
        FfiConverterString.lower(query),
        FfiConverterUInt32.lower(maxResults),$0
    )
})
}
public func preferredIdentifierForSource(identifiers: [String: String], source: EnrichmentSource) -> PreferredIdentifier? {
    return try!  FfiConverterOptionTypePreferredIdentifier.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_preferred_identifier_for_source(
        FfiConverterDictionaryStringString.lower(identifiers),
        FfiConverterTypeEnrichmentSource.lower(source),$0
    )
})
}
/**
 * Combined preprocessing for scientific text
 *
 * Applies all preprocessing steps in order:
 * 1. Decode HTML entities
 * 2. Replace Greek letters
 * 3. Strip font commands
 * 4. Strip standalone braces
 */
public func preprocessScientificText(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_preprocess_scientific_text(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Generate a preview cite key using example data
 */
public func previewCiteKeyFormat(format: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_preview_cite_key_format(
        FfiConverterString.lower(format),$0
    )
})
}
public func publicationFromBibtex(entry: BibTeXEntry) -> Publication {
    return try!  FfiConverterTypePublication.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_publication_from_bibtex(
        FfiConverterTypeBibTeXEntry.lower(entry),$0
    )
})
}
public func publicationToBibtex(publication: Publication) -> BibTeXEntry {
    return try!  FfiConverterTypeBibTeXEntry.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_publication_to_bibtex(
        FfiConverterTypePublication.lower(publication),$0
    )
})
}
public func publicationToBibtexString(publication: Publication) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_publication_to_bibtex_string(
        FfiConverterTypePublication.lower(publication),$0
    )
})
}
/**
 * Replace LaTeX Greek letter commands with Unicode characters
 */
public func replaceGreekLetters(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_replace_greek_letters(
        FfiConverterString.lower(text),$0
    )
})
}
public func resolveArxivToSemanticScholar(arxivId: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_resolve_arxiv_to_semantic_scholar(
        FfiConverterString.lower(arxivId),$0
    )
})
}
public func resolveDoiToSemanticScholar(doi: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_resolve_doi_to_semantic_scholar(
        FfiConverterString.lower(doi),$0
    )
})
}
public func resolvePmidToSemanticScholar(pmid: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_resolve_pmid_to_semantic_scholar(
        FfiConverterString.lower(pmid),$0
    )
})
}
public func risFormatEntry(entry: RisEntry) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_format_entry(
        FfiConverterTypeRISEntry.lower(entry),$0
    )
})
}
public func risFromBibtex(entry: BibTeXEntry) -> RisEntry {
    return try!  FfiConverterTypeRISEntry.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_from_bibtex(
        FfiConverterTypeBibTeXEntry.lower(entry),$0
    )
})
}
public func risParse(input: String)throws  -> [RisEntry] {
    return try  FfiConverterSequenceTypeRISEntry.lift(try rustCallWithError(FfiConverterTypeFfiError.lift) {
    uniffi_imbib_core_fn_func_ris_parse(
        FfiConverterString.lower(input),$0
    )
})
}
public func risToBibtex(entry: RisEntry) -> BibTeXEntry {
    return try!  FfiConverterTypeBibTeXEntry.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_to_bibtex(
        FfiConverterTypeRISEntry.lower(entry),$0
    )
})
}
public func sanitizeCiteKey(key: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_sanitize_cite_key(
        FfiConverterString.lower(key),$0
    )
})
}
/**
 * Add a publication to the search index
 */
public func searchIndexAdd(handleId: UInt64, publication: Publication, fullText: String?)throws  {try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_add(
        FfiConverterUInt64.lower(handleId),
        FfiConverterTypePublication.lower(publication),
        FfiConverterOptionString.lower(fullText),$0
    )
}
}
/**
 * Close and release a search index handle
 */
public func searchIndexClose(handleId: UInt64)throws  {try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_close(
        FfiConverterUInt64.lower(handleId),$0
    )
}
}
/**
 * Commit pending changes to the search index
 */
public func searchIndexCommit(handleId: UInt64)throws  {try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_commit(
        FfiConverterUInt64.lower(handleId),$0
    )
}
}
/**
 * Create a new search index at the given path
 * Returns a handle ID for subsequent operations
 */
public func searchIndexCreate(path: String)throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_create(
        FfiConverterString.lower(path),$0
    )
})
}
/**
 * Create an in-memory search index (for testing)
 * Returns a handle ID for subsequent operations
 */
public func searchIndexCreateInMemory()throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_create_in_memory($0
    )
})
}
/**
 * Delete a publication from the search index
 */
public func searchIndexDelete(handleId: UInt64, publicationId: String)throws  {try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_delete(
        FfiConverterUInt64.lower(handleId),
        FfiConverterString.lower(publicationId),$0
    )
}
}
/**
 * Get the number of active index handles (for debugging)
 */
public func searchIndexHandleCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_search_index_handle_count($0
    )
})
}
/**
 * Search the index
 */
public func searchIndexSearch(handleId: UInt64, query: String, limit: UInt32, libraryId: String?)throws  -> [SearchHit] {
    return try  FfiConverterSequenceTypeSearchHit.lift(try rustCallWithError(FfiConverterTypeSearchIndexError.lift) {
    uniffi_imbib_core_fn_func_search_index_search(
        FfiConverterUInt64.lower(handleId),
        FfiConverterString.lower(query),
        FfiConverterUInt32.lower(limit),
        FfiConverterOptionString.lower(libraryId),$0
    )
})
}
/**
 * Serialize annotations to JSON
 */
public func serializeAnnotations(annotations: PublicationAnnotations)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeAnnotationStorageError.lift) {
    uniffi_imbib_core_fn_func_serialize_annotations(
        FfiConverterTypePublicationAnnotations.lower(annotations),$0
    )
})
}
public func sharesIdentifier(a: DeduplicationInput, b: DeduplicationInput) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_shares_identifier(
        FfiConverterTypeDeduplicationInput.lower(a),
        FfiConverterTypeDeduplicationInput.lower(b),$0
    )
})
}
/**
 * Split a BibTeX author field into individual authors.
 *
 * Handles " and " separators (BibTeX style) and ";" separators.
 */
public func splitAuthors(authorField: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_split_authors(
        FfiConverterString.lower(authorField),$0
    )
})
}
/**
 * Strip LaTeX font-switching commands
 */
public func stripFontCommands(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_strip_font_commands(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Remove standalone LaTeX braces like {pc}  pc
 * Preserves braces that are part of ^{...} or _{...} notation
 */
public func stripStandaloneBraces(text: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_strip_standalone_braces(
        FfiConverterString.lower(text),$0
    )
})
}
public func supportedIdentifiersForSource(source: EnrichmentSource) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_supported_identifiers_for_source(
        FfiConverterTypeEnrichmentSource.lower(source),$0
    )
})
}
public func titlesMatch(title1: String, title2: String, threshold: Double) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_titles_match(
        FfiConverterString.lower(title1),
        FfiConverterString.lower(title2),
        FfiConverterDouble.lower(threshold),$0
    )
})
}
/**
 * Validate a cite key format string
 */
public func validateCiteKeyFormat(format: String) -> CiteKeyFormatValidation {
    return try!  FfiConverterTypeCiteKeyFormatValidation.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_validate_cite_key_format(
        FfiConverterString.lower(format),$0
    )
})
}
/**
 * Validate a publication and return errors/warnings
 */
public func validatePublication(publication: Publication) -> [ValidationError] {
    return try!  FfiConverterSequenceTypeValidationError.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_validate_publication(
        FfiConverterTypePublication.lower(publication),$0
    )
})
}
/**
 * Returns the version of imbib-core
 */
public func version() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_version($0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_imbib_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_add() != 45084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_add_batch() != 33163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_close() != 45798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_create() != 3579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_create_with_config() != 64301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_handle_count() != 43259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_search() != 45546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ann_index_size() != 62570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_authors_overlap() != 34149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bdsk_file_create_fields() != 51608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bdsk_file_decode() != 35653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bdsk_file_encode() != 45464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bdsk_file_extract_all() != 26564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_format_entries() != 41213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_format_entry() != 22118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_parse() != 23563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_parse_entry() != 35930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_api_query() != 24123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_arxiv_author_category_query() != 44263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_classic_query() != 51091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_insert_citation_url() != 21142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_lookup_url() != 43550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_open_manuscript_url() != 9950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_open_url() != 36804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_paper_query() != 38864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_search_url() != 48) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_build_sync_bibliography_url() != 23107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_calculate_publication_similarity() != 24378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_calculate_similarity() != 25622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_can_resolve_to_source() != 53850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_decode_html_entities() != 51511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_decode_latex() != 44047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_deduplicate_search_results() != 30645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_default_deduplication_config() != 12015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_default_export_options() != 24163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_default_filename_options() != 1379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_deserialize_annotations() != 21222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_detect_conflict() != 9657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_detect_format() != 52778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_enrichment_capability_display_name() != 63589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_enrichment_data_is_stale() != 2482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_enrichment_priority_display_name() != 48290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_enrichment_source_display_name() != 36887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_expand_journal_macro() != 57079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_export_bibtex() != 698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_export_bibtex_multiple() != 50527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_export_ris() != 28112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_export_ris_multiple() != 61714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_all() != 12026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_arxiv_ids() != 23986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_dois() != 1063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_first_author_last_name() != 43908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_first_meaningful_word() != 54605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_isbns() != 38246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_snippet() != 18064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_surname() != 49125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_find_duplicates() != 50914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_fuzzy_match_results() != 45882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_cite_key() != 7221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_cite_key_formatted() != 20649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_pdf_filename() != 22946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_pdf_filename_from_metadata() != 15324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_unique_cite_key() != 43249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_unique_cite_key_formatted() != 28363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_get_all_journal_macro_names() != 53362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_hello_from_rust() != 10594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_add_document() != 48809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_close() != 8078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_commit() != 6287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_create() != 55195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_create_in_memory() != 47752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_handle_count() != 19407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_help_index_search() != 57103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_highlight_terms() != 15570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_identifier_display_name() != 3998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_identifier_url() != 1720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_identifier_url_prefix() != 3718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_import_auto() != 63086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_import_bibtex() != 54272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_import_ris() != 29117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_classic_form_empty() != 13413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_journal_macro() != 60166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_paper_form_empty() != 50194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid() != 34682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_arxiv_id() != 39857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_doi() != 47862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_isbn() != 39443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_make_cite_key_unique() != 41508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_merge_annotations() != 16430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_merge_publications() != 39027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_author_export() != 63058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_author_name() != 30980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_doi() != 20476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_title_export() != 30873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_open_access_status_display_name() != 17852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse() != 37269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_ads_bibtex_export() != 54740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_ads_paper_stubs_response() != 9775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_ads_search_response() != 10016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_arxiv_query() != 14449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_atom_feed() != 8901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_author_string() != 40953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_classic_query() != 9697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_crossref_search_response() != 33737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_crossref_work_response() != 10074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_entry() != 28990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_mathml() != 41337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_paper_query() != 42664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_pubmed_efetch_response() != 54300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_pubmed_esearch_response() != 5870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_parse_url_command() != 56881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_pdf_extract_text() != 59811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_pdf_generate_thumbnail() != 2147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_pdf_get_page_count() != 41684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_pdf_get_page_dimensions() != 3862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_pdf_search() != 19162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_preferred_identifier_for_source() != 60356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_preprocess_scientific_text() != 17542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_preview_cite_key_format() != 19118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_publication_from_bibtex() != 56917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_publication_to_bibtex() != 29692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_publication_to_bibtex_string() != 2490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_replace_greek_letters() != 55256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_resolve_arxiv_to_semantic_scholar() != 15426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_resolve_doi_to_semantic_scholar() != 48059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_resolve_pmid_to_semantic_scholar() != 58412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_format_entry() != 35878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_from_bibtex() != 56357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_parse() != 19943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_to_bibtex() != 61743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_sanitize_cite_key() != 7057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_add() != 5715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_close() != 59881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_commit() != 54433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_create() != 44457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_create_in_memory() != 63589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_delete() != 10067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_handle_count() != 27621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_search_index_search() != 18445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_serialize_annotations() != 26309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_shares_identifier() != 15446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_split_authors() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_strip_font_commands() != 57981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_strip_standalone_braces() != 56542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_supported_identifiers_for_source() != 39367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_titles_match() != 58179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_validate_cite_key_format() != 32590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_validate_publication() != 151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_version() != 42387) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all