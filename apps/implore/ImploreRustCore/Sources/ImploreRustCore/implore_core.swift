// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(implore_coreFFI)
import implore_coreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_implore_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_implore_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Thread-safe handle to the generator registry.
 *
 * This is the main entry point for Swift code to interact with
 * the data generator system.
 */
public protocol GeneratorRegistryHandleProtocol : AnyObject {
    
    /**
     * Get all categories that have at least one generator.
     */
    func categories()  -> [GeneratorCategory]
    
    /**
     * Get the total number of registered generators.
     */
    func count()  -> UInt32
    
    /**
     * Get the default parameters for a generator as JSON.
     */
    func defaultParamsJson(generatorId: String) throws  -> String
    
    /**
     * Generate data using the specified generator and parameters.
     *
     * Parameters are passed as a JSON string for FFI simplicity.
     * Returns the generated data or an error.
     */
    func generate(generatorId: String, paramsJson: String) throws  -> GeneratedDataFfi
    
    /**
     * Get metadata for a specific generator.
     */
    func getMetadata(generatorId: String)  -> GeneratorMetadata?
    
    /**
     * List all available generators.
     */
    func listAll()  -> [GeneratorMetadata]
    
    /**
     * List generators in a specific category.
     */
    func listByCategory(category: GeneratorCategory)  -> [GeneratorMetadata]
    
    /**
     * Search generators by name or description.
     */
    func search(query: String)  -> [GeneratorMetadata]
    
}

/**
 * Thread-safe handle to the generator registry.
 *
 * This is the main entry point for Swift code to interact with
 * the data generator system.
 */
open class GeneratorRegistryHandle:
    GeneratorRegistryHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_implore_core_fn_clone_generatorregistryhandle(self.pointer, $0) }
    }
    /**
     * Create a new registry handle with all built-in generators.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_implore_core_fn_constructor_generatorregistryhandle_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_implore_core_fn_free_generatorregistryhandle(pointer, $0) }
    }

    

    
    /**
     * Get all categories that have at least one generator.
     */
open func categories() -> [GeneratorCategory] {
    return try!  FfiConverterSequenceTypeGeneratorCategory.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_categories(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the total number of registered generators.
     */
open func count() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the default parameters for a generator as JSON.
     */
open func defaultParamsJson(generatorId: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGeneratorErrorFfi.lift) {
    uniffi_implore_core_fn_method_generatorregistryhandle_default_params_json(self.uniffiClonePointer(),
        FfiConverterString.lower(generatorId),$0
    )
})
}
    
    /**
     * Generate data using the specified generator and parameters.
     *
     * Parameters are passed as a JSON string for FFI simplicity.
     * Returns the generated data or an error.
     */
open func generate(generatorId: String, paramsJson: String)throws  -> GeneratedDataFfi {
    return try  FfiConverterTypeGeneratedDataFfi.lift(try rustCallWithError(FfiConverterTypeGeneratorErrorFfi.lift) {
    uniffi_implore_core_fn_method_generatorregistryhandle_generate(self.uniffiClonePointer(),
        FfiConverterString.lower(generatorId),
        FfiConverterString.lower(paramsJson),$0
    )
})
}
    
    /**
     * Get metadata for a specific generator.
     */
open func getMetadata(generatorId: String) -> GeneratorMetadata? {
    return try!  FfiConverterOptionTypeGeneratorMetadata.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_get_metadata(self.uniffiClonePointer(),
        FfiConverterString.lower(generatorId),$0
    )
})
}
    
    /**
     * List all available generators.
     */
open func listAll() -> [GeneratorMetadata] {
    return try!  FfiConverterSequenceTypeGeneratorMetadata.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_list_all(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List generators in a specific category.
     */
open func listByCategory(category: GeneratorCategory) -> [GeneratorMetadata] {
    return try!  FfiConverterSequenceTypeGeneratorMetadata.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_list_by_category(self.uniffiClonePointer(),
        FfiConverterTypeGeneratorCategory.lower(category),$0
    )
})
}
    
    /**
     * Search generators by name or description.
     */
open func search(query: String) -> [GeneratorMetadata] {
    return try!  FfiConverterSequenceTypeGeneratorMetadata.lift(try! rustCall() {
    uniffi_implore_core_fn_method_generatorregistryhandle_search(self.uniffiClonePointer(),
        FfiConverterString.lower(query),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratorRegistryHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GeneratorRegistryHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GeneratorRegistryHandle {
        return GeneratorRegistryHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GeneratorRegistryHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratorRegistryHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GeneratorRegistryHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorRegistryHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> GeneratorRegistryHandle {
    return try FfiConverterTypeGeneratorRegistryHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorRegistryHandle_lower(_ value: GeneratorRegistryHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGeneratorRegistryHandle.lower(value)
}


/**
 * Configuration for art shader mode
 */
public struct ArtShaderConfig {
    /**
     * Shader name or identifier
     */
    public var shaderName: String
    /**
     * Shader parameters as key-value pairs
     */
    public var parameters: [ShaderParameter]
    /**
     * Whether to hide all UI chrome
     */
    public var hideChrome: Bool
    /**
     * Post-processing effects to apply
     */
    public var postEffects: [PostEffect]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shader name or identifier
         */shaderName: String, 
        /**
         * Shader parameters as key-value pairs
         */parameters: [ShaderParameter], 
        /**
         * Whether to hide all UI chrome
         */hideChrome: Bool, 
        /**
         * Post-processing effects to apply
         */postEffects: [PostEffect]) {
        self.shaderName = shaderName
        self.parameters = parameters
        self.hideChrome = hideChrome
        self.postEffects = postEffects
    }
}



extension ArtShaderConfig: Equatable, Hashable {
    public static func ==(lhs: ArtShaderConfig, rhs: ArtShaderConfig) -> Bool {
        if lhs.shaderName != rhs.shaderName {
            return false
        }
        if lhs.parameters != rhs.parameters {
            return false
        }
        if lhs.hideChrome != rhs.hideChrome {
            return false
        }
        if lhs.postEffects != rhs.postEffects {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shaderName)
        hasher.combine(parameters)
        hasher.combine(hideChrome)
        hasher.combine(postEffects)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArtShaderConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArtShaderConfig {
        return
            try ArtShaderConfig(
                shaderName: FfiConverterString.read(from: &buf), 
                parameters: FfiConverterSequenceTypeShaderParameter.read(from: &buf), 
                hideChrome: FfiConverterBool.read(from: &buf), 
                postEffects: FfiConverterSequenceTypePostEffect.read(from: &buf)
        )
    }

    public static func write(_ value: ArtShaderConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.shaderName, into: &buf)
        FfiConverterSequenceTypeShaderParameter.write(value.parameters, into: &buf)
        FfiConverterBool.write(value.hideChrome, into: &buf)
        FfiConverterSequenceTypePostEffect.write(value.postEffects, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArtShaderConfig_lift(_ buf: RustBuffer) throws -> ArtShaderConfig {
    return try FfiConverterTypeArtShaderConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArtShaderConfig_lower(_ value: ArtShaderConfig) -> RustBuffer {
    return FfiConverterTypeArtShaderConfig.lower(value)
}


/**
 * Configuration for 3D box view
 */
public struct Box3DConfig {
    /**
     * Field to map to X axis
     */
    public var xField: String
    /**
     * Field to map to Y axis
     */
    public var yField: String
    /**
     * Field to map to Z axis
     */
    public var zField: String
    /**
     * Whether to show wireframe box
     */
    public var showBox: Bool
    /**
     * Whether to enable depth cueing (fog)
     */
    public var depthCueing: Bool
    /**
     * Depth cueing strength (0-1)
     */
    public var depthCueingStrength: Float
    /**
     * Whether to enable depth sorting
     */
    public var depthSort: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Field to map to X axis
         */xField: String, 
        /**
         * Field to map to Y axis
         */yField: String, 
        /**
         * Field to map to Z axis
         */zField: String, 
        /**
         * Whether to show wireframe box
         */showBox: Bool, 
        /**
         * Whether to enable depth cueing (fog)
         */depthCueing: Bool, 
        /**
         * Depth cueing strength (0-1)
         */depthCueingStrength: Float, 
        /**
         * Whether to enable depth sorting
         */depthSort: Bool) {
        self.xField = xField
        self.yField = yField
        self.zField = zField
        self.showBox = showBox
        self.depthCueing = depthCueing
        self.depthCueingStrength = depthCueingStrength
        self.depthSort = depthSort
    }
}



extension Box3DConfig: Equatable, Hashable {
    public static func ==(lhs: Box3DConfig, rhs: Box3DConfig) -> Bool {
        if lhs.xField != rhs.xField {
            return false
        }
        if lhs.yField != rhs.yField {
            return false
        }
        if lhs.zField != rhs.zField {
            return false
        }
        if lhs.showBox != rhs.showBox {
            return false
        }
        if lhs.depthCueing != rhs.depthCueing {
            return false
        }
        if lhs.depthCueingStrength != rhs.depthCueingStrength {
            return false
        }
        if lhs.depthSort != rhs.depthSort {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(xField)
        hasher.combine(yField)
        hasher.combine(zField)
        hasher.combine(showBox)
        hasher.combine(depthCueing)
        hasher.combine(depthCueingStrength)
        hasher.combine(depthSort)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBox3DConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Box3DConfig {
        return
            try Box3DConfig(
                xField: FfiConverterString.read(from: &buf), 
                yField: FfiConverterString.read(from: &buf), 
                zField: FfiConverterString.read(from: &buf), 
                showBox: FfiConverterBool.read(from: &buf), 
                depthCueing: FfiConverterBool.read(from: &buf), 
                depthCueingStrength: FfiConverterFloat.read(from: &buf), 
                depthSort: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Box3DConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.xField, into: &buf)
        FfiConverterString.write(value.yField, into: &buf)
        FfiConverterString.write(value.zField, into: &buf)
        FfiConverterBool.write(value.showBox, into: &buf)
        FfiConverterBool.write(value.depthCueing, into: &buf)
        FfiConverterFloat.write(value.depthCueingStrength, into: &buf)
        FfiConverterBool.write(value.depthSort, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3DConfig_lift(_ buf: RustBuffer) throws -> Box3DConfig {
    return try FfiConverterTypeBox3DConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBox3DConfig_lower(_ value: Box3DConfig) -> RustBuffer {
    return FfiConverterTypeBox3DConfig.lower(value)
}


/**
 * 3D camera with position, target, and projection
 */
public struct Camera3D {
    /**
     * Camera position in world space
     */
    public var position: Vec3f
    /**
     * Point the camera is looking at
     */
    public var target: Vec3f
    /**
     * Up vector
     */
    public var up: Vec3f
    /**
     * Field of view in degrees (for perspective)
     */
    public var fov: Float
    /**
     * Near clipping plane
     */
    public var near: Float
    /**
     * Far clipping plane
     */
    public var far: Float
    /**
     * Whether to use orthographic projection
     */
    public var orthographic: Bool
    /**
     * Orthographic scale (only used if orthographic)
     */
    public var orthoScale: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Camera position in world space
         */position: Vec3f, 
        /**
         * Point the camera is looking at
         */target: Vec3f, 
        /**
         * Up vector
         */up: Vec3f, 
        /**
         * Field of view in degrees (for perspective)
         */fov: Float, 
        /**
         * Near clipping plane
         */near: Float, 
        /**
         * Far clipping plane
         */far: Float, 
        /**
         * Whether to use orthographic projection
         */orthographic: Bool, 
        /**
         * Orthographic scale (only used if orthographic)
         */orthoScale: Float) {
        self.position = position
        self.target = target
        self.up = up
        self.fov = fov
        self.near = near
        self.far = far
        self.orthographic = orthographic
        self.orthoScale = orthoScale
    }
}



extension Camera3D: Equatable, Hashable {
    public static func ==(lhs: Camera3D, rhs: Camera3D) -> Bool {
        if lhs.position != rhs.position {
            return false
        }
        if lhs.target != rhs.target {
            return false
        }
        if lhs.up != rhs.up {
            return false
        }
        if lhs.fov != rhs.fov {
            return false
        }
        if lhs.near != rhs.near {
            return false
        }
        if lhs.far != rhs.far {
            return false
        }
        if lhs.orthographic != rhs.orthographic {
            return false
        }
        if lhs.orthoScale != rhs.orthoScale {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(position)
        hasher.combine(target)
        hasher.combine(up)
        hasher.combine(fov)
        hasher.combine(near)
        hasher.combine(far)
        hasher.combine(orthographic)
        hasher.combine(orthoScale)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCamera3D: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Camera3D {
        return
            try Camera3D(
                position: FfiConverterTypeVec3f.read(from: &buf), 
                target: FfiConverterTypeVec3f.read(from: &buf), 
                up: FfiConverterTypeVec3f.read(from: &buf), 
                fov: FfiConverterFloat.read(from: &buf), 
                near: FfiConverterFloat.read(from: &buf), 
                far: FfiConverterFloat.read(from: &buf), 
                orthographic: FfiConverterBool.read(from: &buf), 
                orthoScale: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Camera3D, into buf: inout [UInt8]) {
        FfiConverterTypeVec3f.write(value.position, into: &buf)
        FfiConverterTypeVec3f.write(value.target, into: &buf)
        FfiConverterTypeVec3f.write(value.up, into: &buf)
        FfiConverterFloat.write(value.fov, into: &buf)
        FfiConverterFloat.write(value.near, into: &buf)
        FfiConverterFloat.write(value.far, into: &buf)
        FfiConverterBool.write(value.orthographic, into: &buf)
        FfiConverterFloat.write(value.orthoScale, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCamera3D_lift(_ buf: RustBuffer) throws -> Camera3D {
    return try FfiConverterTypeCamera3D.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCamera3D_lower(_ value: Camera3D) -> RustBuffer {
    return FfiConverterTypeCamera3D.lower(value)
}


/**
 * Color mapping configuration
 */
public struct ColorMapping {
    /**
     * Field to use for color mapping
     */
    public var field: String?
    /**
     * Colormap name (e.g., "viridis", "plasma", "inferno")
     */
    public var colormap: String
    /**
     * Minimum value for colormap (None = auto)
     */
    public var vmin: Double?
    /**
     * Maximum value for colormap (None = auto)
     */
    public var vmax: Double?
    /**
     * Whether to apply log scaling before color mapping
     */
    public var logScale: Bool
    /**
     * Whether to reverse the colormap
     */
    public var reversed: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Field to use for color mapping
         */field: String?, 
        /**
         * Colormap name (e.g., "viridis", "plasma", "inferno")
         */colormap: String, 
        /**
         * Minimum value for colormap (None = auto)
         */vmin: Double?, 
        /**
         * Maximum value for colormap (None = auto)
         */vmax: Double?, 
        /**
         * Whether to apply log scaling before color mapping
         */logScale: Bool, 
        /**
         * Whether to reverse the colormap
         */reversed: Bool) {
        self.field = field
        self.colormap = colormap
        self.vmin = vmin
        self.vmax = vmax
        self.logScale = logScale
        self.reversed = reversed
    }
}



extension ColorMapping: Equatable, Hashable {
    public static func ==(lhs: ColorMapping, rhs: ColorMapping) -> Bool {
        if lhs.field != rhs.field {
            return false
        }
        if lhs.colormap != rhs.colormap {
            return false
        }
        if lhs.vmin != rhs.vmin {
            return false
        }
        if lhs.vmax != rhs.vmax {
            return false
        }
        if lhs.logScale != rhs.logScale {
            return false
        }
        if lhs.reversed != rhs.reversed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(field)
        hasher.combine(colormap)
        hasher.combine(vmin)
        hasher.combine(vmax)
        hasher.combine(logScale)
        hasher.combine(reversed)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColorMapping: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorMapping {
        return
            try ColorMapping(
                field: FfiConverterOptionString.read(from: &buf), 
                colormap: FfiConverterString.read(from: &buf), 
                vmin: FfiConverterOptionDouble.read(from: &buf), 
                vmax: FfiConverterOptionDouble.read(from: &buf), 
                logScale: FfiConverterBool.read(from: &buf), 
                reversed: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ColorMapping, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.field, into: &buf)
        FfiConverterString.write(value.colormap, into: &buf)
        FfiConverterOptionDouble.write(value.vmin, into: &buf)
        FfiConverterOptionDouble.write(value.vmax, into: &buf)
        FfiConverterBool.write(value.logScale, into: &buf)
        FfiConverterBool.write(value.reversed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorMapping_lift(_ buf: RustBuffer) throws -> ColorMapping {
    return try FfiConverterTypeColorMapping.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorMapping_lower(_ value: ColorMapping) -> RustBuffer {
    return FfiConverterTypeColorMapping.lower(value)
}


/**
 * An RGB color represented as three f32 values (0.0-1.0)
 */
public struct ColorRgb {
    public var r: Float
    public var g: Float
    public var b: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: Float, g: Float, b: Float) {
        self.r = r
        self.g = g
        self.b = b
    }
}



extension ColorRgb: Equatable, Hashable {
    public static func ==(lhs: ColorRgb, rhs: ColorRgb) -> Bool {
        if lhs.r != rhs.r {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        if lhs.b != rhs.b {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(r)
        hasher.combine(g)
        hasher.combine(b)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColorRgb: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorRgb {
        return
            try ColorRgb(
                r: FfiConverterFloat.read(from: &buf), 
                g: FfiConverterFloat.read(from: &buf), 
                b: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: ColorRgb, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.r, into: &buf)
        FfiConverterFloat.write(value.g, into: &buf)
        FfiConverterFloat.write(value.b, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorRgb_lift(_ buf: RustBuffer) throws -> ColorRgb {
    return try FfiConverterTypeColorRgb.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorRgb_lower(_ value: ColorRgb) -> RustBuffer {
    return FfiConverterTypeColorRgb.lower(value)
}


/**
 * Academic provenance for a dataset
 *
 * Links the dataset to publications in imbib for proper citation.
 */
public struct DataProvenance {
    /**
     * imbib publication IDs for papers that produced this data
     */
    public var sourcePublicationIds: [String]
    /**
     * DOIs for data repositories (Zenodo, Figshare, etc.)
     */
    public var dataDois: [String]
    /**
     * When the provenance was established
     */
    public var createdAt: String?
    /**
     * Notes about data origin
     */
    public var notes: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * imbib publication IDs for papers that produced this data
         */sourcePublicationIds: [String], 
        /**
         * DOIs for data repositories (Zenodo, Figshare, etc.)
         */dataDois: [String], 
        /**
         * When the provenance was established
         */createdAt: String?, 
        /**
         * Notes about data origin
         */notes: String?) {
        self.sourcePublicationIds = sourcePublicationIds
        self.dataDois = dataDois
        self.createdAt = createdAt
        self.notes = notes
    }
}



extension DataProvenance: Equatable, Hashable {
    public static func ==(lhs: DataProvenance, rhs: DataProvenance) -> Bool {
        if lhs.sourcePublicationIds != rhs.sourcePublicationIds {
            return false
        }
        if lhs.dataDois != rhs.dataDois {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sourcePublicationIds)
        hasher.combine(dataDois)
        hasher.combine(createdAt)
        hasher.combine(notes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataProvenance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataProvenance {
        return
            try DataProvenance(
                sourcePublicationIds: FfiConverterSequenceString.read(from: &buf), 
                dataDois: FfiConverterSequenceString.read(from: &buf), 
                createdAt: FfiConverterOptionString.read(from: &buf), 
                notes: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DataProvenance, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.sourcePublicationIds, into: &buf)
        FfiConverterSequenceString.write(value.dataDois, into: &buf)
        FfiConverterOptionString.write(value.createdAt, into: &buf)
        FfiConverterOptionString.write(value.notes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataProvenance_lift(_ buf: RustBuffer) throws -> DataProvenance {
    return try FfiConverterTypeDataProvenance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataProvenance_lower(_ value: DataProvenance) -> RustBuffer {
    return FfiConverterTypeDataProvenance.lower(value)
}


/**
 * Schema describing dataset fields
 */
public struct DataSchema {
    /**
     * Field descriptors
     */
    public var fields: [FieldDescriptor]
    /**
     * Number of records
     */
    public var numRecords: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Field descriptors
         */fields: [FieldDescriptor], 
        /**
         * Number of records
         */numRecords: UInt64) {
        self.fields = fields
        self.numRecords = numRecords
    }
}



extension DataSchema: Equatable, Hashable {
    public static func ==(lhs: DataSchema, rhs: DataSchema) -> Bool {
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.numRecords != rhs.numRecords {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fields)
        hasher.combine(numRecords)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataSchema {
        return
            try DataSchema(
                fields: FfiConverterSequenceTypeFieldDescriptor.read(from: &buf), 
                numRecords: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DataSchema, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFieldDescriptor.write(value.fields, into: &buf)
        FfiConverterUInt64.write(value.numRecords, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSchema_lift(_ buf: RustBuffer) throws -> DataSchema {
    return try FfiConverterTypeDataSchema.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataSchema_lower(_ value: DataSchema) -> RustBuffer {
    return FfiConverterTypeDataSchema.lower(value)
}


/**
 * A scientific dataset with schema and provenance
 */
public struct Dataset {
    /**
     * Unique identifier for this dataset
     */
    public var id: String
    /**
     * Human-readable name
     */
    public var name: String
    /**
     * Source location and format
     */
    public var source: DatasetSource
    /**
     * Schema describing fields
     */
    public var schema: DataSchema
    /**
     * Additional metadata
     */
    public var metadata: DatasetMetadata
    /**
     * Academic provenance (links to publications)
     */
    public var provenance: DataProvenance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for this dataset
         */id: String, 
        /**
         * Human-readable name
         */name: String, 
        /**
         * Source location and format
         */source: DatasetSource, 
        /**
         * Schema describing fields
         */schema: DataSchema, 
        /**
         * Additional metadata
         */metadata: DatasetMetadata, 
        /**
         * Academic provenance (links to publications)
         */provenance: DataProvenance) {
        self.id = id
        self.name = name
        self.source = source
        self.schema = schema
        self.metadata = metadata
        self.provenance = provenance
    }
}



extension Dataset: Equatable, Hashable {
    public static func ==(lhs: Dataset, rhs: Dataset) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.schema != rhs.schema {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.provenance != rhs.provenance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(source)
        hasher.combine(schema)
        hasher.combine(metadata)
        hasher.combine(provenance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataset: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Dataset {
        return
            try Dataset(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypeDatasetSource.read(from: &buf), 
                schema: FfiConverterTypeDataSchema.read(from: &buf), 
                metadata: FfiConverterTypeDatasetMetadata.read(from: &buf), 
                provenance: FfiConverterTypeDataProvenance.read(from: &buf)
        )
    }

    public static func write(_ value: Dataset, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeDatasetSource.write(value.source, into: &buf)
        FfiConverterTypeDataSchema.write(value.schema, into: &buf)
        FfiConverterTypeDatasetMetadata.write(value.metadata, into: &buf)
        FfiConverterTypeDataProvenance.write(value.provenance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lift(_ buf: RustBuffer) throws -> Dataset {
    return try FfiConverterTypeDataset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataset_lower(_ value: Dataset) -> RustBuffer {
    return FfiConverterTypeDataset.lower(value)
}


/**
 * Additional metadata for a dataset
 */
public struct DatasetMetadata {
    /**
     * Arbitrary key-value pairs
     */
    public var attributes: [String: String]
    /**
     * Creation timestamp (Unix milliseconds)
     */
    public var createdAt: Int64?
    /**
     * Last modified timestamp
     */
    public var modifiedAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Arbitrary key-value pairs
         */attributes: [String: String], 
        /**
         * Creation timestamp (Unix milliseconds)
         */createdAt: Int64?, 
        /**
         * Last modified timestamp
         */modifiedAt: Int64?) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }
}



extension DatasetMetadata: Equatable, Hashable {
    public static func ==(lhs: DatasetMetadata, rhs: DatasetMetadata) -> Bool {
        if lhs.attributes != rhs.attributes {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attributes)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatasetMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatasetMetadata {
        return
            try DatasetMetadata(
                attributes: FfiConverterDictionaryStringString.read(from: &buf), 
                createdAt: FfiConverterOptionInt64.read(from: &buf), 
                modifiedAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DatasetMetadata, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringString.write(value.attributes, into: &buf)
        FfiConverterOptionInt64.write(value.createdAt, into: &buf)
        FfiConverterOptionInt64.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetMetadata_lift(_ buf: RustBuffer) throws -> DatasetMetadata {
    return try FfiConverterTypeDatasetMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetMetadata_lower(_ value: DatasetMetadata) -> RustBuffer {
    return FfiConverterTypeDatasetMetadata.lower(value)
}


/**
 * Descriptor for a single field in the dataset
 */
public struct FieldDescriptor {
    /**
     * Field name
     */
    public var name: String
    /**
     * Data type
     */
    public var dtype: DataType
    /**
     * Physical units (if known)
     */
    public var unit: String?
    /**
     * Human-readable description
     */
    public var description: String?
    /**
     * Minimum value (for numeric types)
     */
    public var minValue: Double?
    /**
     * Maximum value (for numeric types)
     */
    public var maxValue: Double?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Field name
         */name: String, 
        /**
         * Data type
         */dtype: DataType, 
        /**
         * Physical units (if known)
         */unit: String?, 
        /**
         * Human-readable description
         */description: String?, 
        /**
         * Minimum value (for numeric types)
         */minValue: Double?, 
        /**
         * Maximum value (for numeric types)
         */maxValue: Double?) {
        self.name = name
        self.dtype = dtype
        self.unit = unit
        self.description = description
        self.minValue = minValue
        self.maxValue = maxValue
    }
}



extension FieldDescriptor: Equatable, Hashable {
    public static func ==(lhs: FieldDescriptor, rhs: FieldDescriptor) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.dtype != rhs.dtype {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.minValue != rhs.minValue {
            return false
        }
        if lhs.maxValue != rhs.maxValue {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(dtype)
        hasher.combine(unit)
        hasher.combine(description)
        hasher.combine(minValue)
        hasher.combine(maxValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFieldDescriptor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldDescriptor {
        return
            try FieldDescriptor(
                name: FfiConverterString.read(from: &buf), 
                dtype: FfiConverterTypeDataType.read(from: &buf), 
                unit: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                minValue: FfiConverterOptionDouble.read(from: &buf), 
                maxValue: FfiConverterOptionDouble.read(from: &buf)
        )
    }

    public static func write(_ value: FieldDescriptor, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeDataType.write(value.dtype, into: &buf)
        FfiConverterOptionString.write(value.unit, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionDouble.write(value.minValue, into: &buf)
        FfiConverterOptionDouble.write(value.maxValue, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldDescriptor_lift(_ buf: RustBuffer) throws -> FieldDescriptor {
    return try FfiConverterTypeFieldDescriptor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldDescriptor_lower(_ value: FieldDescriptor) -> RustBuffer {
    return FfiConverterTypeFieldDescriptor.lower(value)
}


/**
 * An exported version of a figure
 */
public struct FigureExport {
    /**
     * Export format
     */
    public var format: FigureFormat
    /**
     * File path (if saved to disk)
     */
    public var path: String?
    /**
     * Embedded data (for small exports)
     */
    public var embeddedData: Data?
    /**
     * Width in pixels
     */
    public var widthPx: UInt32
    /**
     * Height in pixels
     */
    public var heightPx: UInt32
    /**
     * DPI for raster formats
     */
    public var dpi: UInt32
    /**
     * Export timestamp
     */
    public var exportedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Export format
         */format: FigureFormat, 
        /**
         * File path (if saved to disk)
         */path: String?, 
        /**
         * Embedded data (for small exports)
         */embeddedData: Data?, 
        /**
         * Width in pixels
         */widthPx: UInt32, 
        /**
         * Height in pixels
         */heightPx: UInt32, 
        /**
         * DPI for raster formats
         */dpi: UInt32, 
        /**
         * Export timestamp
         */exportedAt: String) {
        self.format = format
        self.path = path
        self.embeddedData = embeddedData
        self.widthPx = widthPx
        self.heightPx = heightPx
        self.dpi = dpi
        self.exportedAt = exportedAt
    }
}



extension FigureExport: Equatable, Hashable {
    public static func ==(lhs: FigureExport, rhs: FigureExport) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.embeddedData != rhs.embeddedData {
            return false
        }
        if lhs.widthPx != rhs.widthPx {
            return false
        }
        if lhs.heightPx != rhs.heightPx {
            return false
        }
        if lhs.dpi != rhs.dpi {
            return false
        }
        if lhs.exportedAt != rhs.exportedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(path)
        hasher.combine(embeddedData)
        hasher.combine(widthPx)
        hasher.combine(heightPx)
        hasher.combine(dpi)
        hasher.combine(exportedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFigureExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FigureExport {
        return
            try FigureExport(
                format: FfiConverterTypeFigureFormat.read(from: &buf), 
                path: FfiConverterOptionString.read(from: &buf), 
                embeddedData: FfiConverterOptionData.read(from: &buf), 
                widthPx: FfiConverterUInt32.read(from: &buf), 
                heightPx: FfiConverterUInt32.read(from: &buf), 
                dpi: FfiConverterUInt32.read(from: &buf), 
                exportedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FigureExport, into buf: inout [UInt8]) {
        FfiConverterTypeFigureFormat.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterOptionData.write(value.embeddedData, into: &buf)
        FfiConverterUInt32.write(value.widthPx, into: &buf)
        FfiConverterUInt32.write(value.heightPx, into: &buf)
        FfiConverterUInt32.write(value.dpi, into: &buf)
        FfiConverterString.write(value.exportedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureExport_lift(_ buf: RustBuffer) throws -> FigureExport {
    return try FfiConverterTypeFigureExport.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureExport_lower(_ value: FigureExport) -> RustBuffer {
    return FfiConverterTypeFigureExport.lower(value)
}


/**
 * Folder for organizing figures
 */
public struct FigureFolder {
    /**
     * Unique identifier
     */
    public var id: String
    /**
     * Folder name
     */
    public var name: String
    /**
     * IDs of figures in this folder
     */
    public var figureIds: [String]
    /**
     * Whether the folder is collapsed in UI
     */
    public var collapsed: Bool
    /**
     * Sort order (lower = earlier)
     */
    public var sortOrder: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier
         */id: String, 
        /**
         * Folder name
         */name: String, 
        /**
         * IDs of figures in this folder
         */figureIds: [String], 
        /**
         * Whether the folder is collapsed in UI
         */collapsed: Bool, 
        /**
         * Sort order (lower = earlier)
         */sortOrder: Int32) {
        self.id = id
        self.name = name
        self.figureIds = figureIds
        self.collapsed = collapsed
        self.sortOrder = sortOrder
    }
}



extension FigureFolder: Equatable, Hashable {
    public static func ==(lhs: FigureFolder, rhs: FigureFolder) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.figureIds != rhs.figureIds {
            return false
        }
        if lhs.collapsed != rhs.collapsed {
            return false
        }
        if lhs.sortOrder != rhs.sortOrder {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(figureIds)
        hasher.combine(collapsed)
        hasher.combine(sortOrder)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFigureFolder: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FigureFolder {
        return
            try FigureFolder(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                figureIds: FfiConverterSequenceString.read(from: &buf), 
                collapsed: FfiConverterBool.read(from: &buf), 
                sortOrder: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: FigureFolder, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceString.write(value.figureIds, into: &buf)
        FfiConverterBool.write(value.collapsed, into: &buf)
        FfiConverterInt32.write(value.sortOrder, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureFolder_lift(_ buf: RustBuffer) throws -> FigureFolder {
    return try FfiConverterTypeFigureFolder.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureFolder_lower(_ value: FigureFolder) -> RustBuffer {
    return FfiConverterTypeFigureFolder.lower(value)
}


/**
 * A library of figures organized by folders
 */
public struct FigureLibrary {
    /**
     * Unique identifier for this library
     */
    public var id: String
    /**
     * Human-readable name
     */
    public var name: String
    /**
     * All figures in the library
     */
    public var figures: [LibraryFigure]
    /**
     * Folder organization
     */
    public var folders: [FigureFolder]
    /**
     * When this library was created
     */
    public var createdAt: String
    /**
     * When this library was last modified
     */
    public var modifiedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for this library
         */id: String, 
        /**
         * Human-readable name
         */name: String, 
        /**
         * All figures in the library
         */figures: [LibraryFigure], 
        /**
         * Folder organization
         */folders: [FigureFolder], 
        /**
         * When this library was created
         */createdAt: String, 
        /**
         * When this library was last modified
         */modifiedAt: String) {
        self.id = id
        self.name = name
        self.figures = figures
        self.folders = folders
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }
}



extension FigureLibrary: Equatable, Hashable {
    public static func ==(lhs: FigureLibrary, rhs: FigureLibrary) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.figures != rhs.figures {
            return false
        }
        if lhs.folders != rhs.folders {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(figures)
        hasher.combine(folders)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFigureLibrary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FigureLibrary {
        return
            try FigureLibrary(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                figures: FfiConverterSequenceTypeLibraryFigure.read(from: &buf), 
                folders: FfiConverterSequenceTypeFigureFolder.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                modifiedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FigureLibrary, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceTypeLibraryFigure.write(value.figures, into: &buf)
        FfiConverterSequenceTypeFigureFolder.write(value.folders, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureLibrary_lift(_ buf: RustBuffer) throws -> FigureLibrary {
    return try FfiConverterTypeFigureLibrary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureLibrary_lower(_ value: FigureLibrary) -> RustBuffer {
    return FfiConverterTypeFigureLibrary.lower(value)
}


/**
 * FFI-safe representation of generated data.
 *
 * Unlike `GeneratedData`, this uses column-major flattened arrays
 * which are more efficient for FFI transfer.
 */
public struct GeneratedDataFfi {
    /**
     * Names of the data columns in order
     */
    public var columnNames: [String]
    /**
     * Flattened column-major data (all values for column 0, then column 1, etc.)
     */
    public var data: [Double]
    /**
     * Number of rows in the dataset
     */
    public var rowCount: UInt64
    /**
     * Minimum bounds for each dimension (if available)
     */
    public var boundsMin: [Double]?
    /**
     * Maximum bounds for each dimension (if available)
     */
    public var boundsMax: [Double]?
    /**
     * Additional metadata key-value pairs
     */
    public var metadata: [MetadataEntry]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Names of the data columns in order
         */columnNames: [String], 
        /**
         * Flattened column-major data (all values for column 0, then column 1, etc.)
         */data: [Double], 
        /**
         * Number of rows in the dataset
         */rowCount: UInt64, 
        /**
         * Minimum bounds for each dimension (if available)
         */boundsMin: [Double]?, 
        /**
         * Maximum bounds for each dimension (if available)
         */boundsMax: [Double]?, 
        /**
         * Additional metadata key-value pairs
         */metadata: [MetadataEntry]) {
        self.columnNames = columnNames
        self.data = data
        self.rowCount = rowCount
        self.boundsMin = boundsMin
        self.boundsMax = boundsMax
        self.metadata = metadata
    }
}



extension GeneratedDataFfi: Equatable, Hashable {
    public static func ==(lhs: GeneratedDataFfi, rhs: GeneratedDataFfi) -> Bool {
        if lhs.columnNames != rhs.columnNames {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.rowCount != rhs.rowCount {
            return false
        }
        if lhs.boundsMin != rhs.boundsMin {
            return false
        }
        if lhs.boundsMax != rhs.boundsMax {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(columnNames)
        hasher.combine(data)
        hasher.combine(rowCount)
        hasher.combine(boundsMin)
        hasher.combine(boundsMax)
        hasher.combine(metadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratedDataFfi: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratedDataFfi {
        return
            try GeneratedDataFfi(
                columnNames: FfiConverterSequenceString.read(from: &buf), 
                data: FfiConverterSequenceDouble.read(from: &buf), 
                rowCount: FfiConverterUInt64.read(from: &buf), 
                boundsMin: FfiConverterOptionSequenceDouble.read(from: &buf), 
                boundsMax: FfiConverterOptionSequenceDouble.read(from: &buf), 
                metadata: FfiConverterSequenceTypeMetadataEntry.read(from: &buf)
        )
    }

    public static func write(_ value: GeneratedDataFfi, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.columnNames, into: &buf)
        FfiConverterSequenceDouble.write(value.data, into: &buf)
        FfiConverterUInt64.write(value.rowCount, into: &buf)
        FfiConverterOptionSequenceDouble.write(value.boundsMin, into: &buf)
        FfiConverterOptionSequenceDouble.write(value.boundsMax, into: &buf)
        FfiConverterSequenceTypeMetadataEntry.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratedDataFfi_lift(_ buf: RustBuffer) throws -> GeneratedDataFfi {
    return try FfiConverterTypeGeneratedDataFfi.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratedDataFfi_lower(_ value: GeneratedDataFfi) -> RustBuffer {
    return FfiConverterTypeGeneratedDataFfi.lower(value)
}


/**
 * Metadata describing a data generator plugin
 */
public struct GeneratorMetadata {
    /**
     * Unique identifier (e.g., "noise-perlin-2d")
     */
    public var id: String
    /**
     * Human-readable name (e.g., "Perlin Noise (2D)")
     */
    public var name: String
    /**
     * Category for organization
     */
    public var category: GeneratorCategory
    /**
     * Description of what this generator produces
     */
    public var description: String
    /**
     * SF Symbol icon name
     */
    public var icon: String
    /**
     * Parameter specifications
     */
    public var parameters: [ParameterSpec]
    /**
     * Output dimensionality (1, 2, or 3)
     */
    public var outputDimensions: UInt8
    /**
     * Whether this generator supports time-based animation
     */
    public var supportsAnimation: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier (e.g., "noise-perlin-2d")
         */id: String, 
        /**
         * Human-readable name (e.g., "Perlin Noise (2D)")
         */name: String, 
        /**
         * Category for organization
         */category: GeneratorCategory, 
        /**
         * Description of what this generator produces
         */description: String, 
        /**
         * SF Symbol icon name
         */icon: String, 
        /**
         * Parameter specifications
         */parameters: [ParameterSpec], 
        /**
         * Output dimensionality (1, 2, or 3)
         */outputDimensions: UInt8, 
        /**
         * Whether this generator supports time-based animation
         */supportsAnimation: Bool) {
        self.id = id
        self.name = name
        self.category = category
        self.description = description
        self.icon = icon
        self.parameters = parameters
        self.outputDimensions = outputDimensions
        self.supportsAnimation = supportsAnimation
    }
}



extension GeneratorMetadata: Equatable, Hashable {
    public static func ==(lhs: GeneratorMetadata, rhs: GeneratorMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.category != rhs.category {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.parameters != rhs.parameters {
            return false
        }
        if lhs.outputDimensions != rhs.outputDimensions {
            return false
        }
        if lhs.supportsAnimation != rhs.supportsAnimation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(category)
        hasher.combine(description)
        hasher.combine(icon)
        hasher.combine(parameters)
        hasher.combine(outputDimensions)
        hasher.combine(supportsAnimation)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratorMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratorMetadata {
        return
            try GeneratorMetadata(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                category: FfiConverterTypeGeneratorCategory.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                icon: FfiConverterString.read(from: &buf), 
                parameters: FfiConverterSequenceTypeParameterSpec.read(from: &buf), 
                outputDimensions: FfiConverterUInt8.read(from: &buf), 
                supportsAnimation: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: GeneratorMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeGeneratorCategory.write(value.category, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterSequenceTypeParameterSpec.write(value.parameters, into: &buf)
        FfiConverterUInt8.write(value.outputDimensions, into: &buf)
        FfiConverterBool.write(value.supportsAnimation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorMetadata_lift(_ buf: RustBuffer) throws -> GeneratorMetadata {
    return try FfiConverterTypeGeneratorMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorMetadata_lower(_ value: GeneratorMetadata) -> RustBuffer {
    return FfiConverterTypeGeneratorMetadata.lower(value)
}


/**
 * Link to an imprint document
 */
public struct ImprintLink {
    /**
     * ID of the imprint document
     */
    public var documentId: String
    /**
     * Title of the document (for display)
     */
    public var documentTitle: String
    /**
     * Label used in the document (e.g., "fig:noise-comparison")
     */
    public var figureLabel: String
    /**
     * Whether to auto-update when figure changes
     */
    public var autoUpdate: Bool
    /**
     * When this figure was last synced to the document
     */
    public var lastSynced: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of the imprint document
         */documentId: String, 
        /**
         * Title of the document (for display)
         */documentTitle: String, 
        /**
         * Label used in the document (e.g., "fig:noise-comparison")
         */figureLabel: String, 
        /**
         * Whether to auto-update when figure changes
         */autoUpdate: Bool, 
        /**
         * When this figure was last synced to the document
         */lastSynced: String?) {
        self.documentId = documentId
        self.documentTitle = documentTitle
        self.figureLabel = figureLabel
        self.autoUpdate = autoUpdate
        self.lastSynced = lastSynced
    }
}



extension ImprintLink: Equatable, Hashable {
    public static func ==(lhs: ImprintLink, rhs: ImprintLink) -> Bool {
        if lhs.documentId != rhs.documentId {
            return false
        }
        if lhs.documentTitle != rhs.documentTitle {
            return false
        }
        if lhs.figureLabel != rhs.figureLabel {
            return false
        }
        if lhs.autoUpdate != rhs.autoUpdate {
            return false
        }
        if lhs.lastSynced != rhs.lastSynced {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(documentId)
        hasher.combine(documentTitle)
        hasher.combine(figureLabel)
        hasher.combine(autoUpdate)
        hasher.combine(lastSynced)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImprintLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImprintLink {
        return
            try ImprintLink(
                documentId: FfiConverterString.read(from: &buf), 
                documentTitle: FfiConverterString.read(from: &buf), 
                figureLabel: FfiConverterString.read(from: &buf), 
                autoUpdate: FfiConverterBool.read(from: &buf), 
                lastSynced: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImprintLink, into buf: inout [UInt8]) {
        FfiConverterString.write(value.documentId, into: &buf)
        FfiConverterString.write(value.documentTitle, into: &buf)
        FfiConverterString.write(value.figureLabel, into: &buf)
        FfiConverterBool.write(value.autoUpdate, into: &buf)
        FfiConverterOptionString.write(value.lastSynced, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintLink_lift(_ buf: RustBuffer) throws -> ImprintLink {
    return try FfiConverterTypeImprintLink.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImprintLink_lower(_ value: ImprintLink) -> RustBuffer {
    return FfiConverterTypeImprintLink.lower(value)
}


/**
 * A figure saved in the library
 */
public struct LibraryFigure {
    /**
     * Unique identifier for this figure
     */
    public var id: String
    /**
     * User-given title
     */
    public var title: String
    /**
     * Optional thumbnail (PNG data)
     */
    public var thumbnail: Data?
    /**
     * Reference to the source session
     */
    public var sessionId: String
    /**
     * JSON-serialized view state for reproducibility
     */
    public var viewStateSnapshot: String
    /**
     * How the data was obtained
     */
    public var datasetSource: DatasetSource
    /**
     * Links to imprint documents using this figure
     */
    public var imprintLinks: [ImprintLink]
    /**
     * User tags for organization
     */
    public var tags: [String]
    /**
     * Optional folder ID (None = unfiled)
     */
    public var folderId: String?
    /**
     * When this figure was created
     */
    public var createdAt: String
    /**
     * When this figure was last modified
     */
    public var modifiedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for this figure
         */id: String, 
        /**
         * User-given title
         */title: String, 
        /**
         * Optional thumbnail (PNG data)
         */thumbnail: Data?, 
        /**
         * Reference to the source session
         */sessionId: String, 
        /**
         * JSON-serialized view state for reproducibility
         */viewStateSnapshot: String, 
        /**
         * How the data was obtained
         */datasetSource: DatasetSource, 
        /**
         * Links to imprint documents using this figure
         */imprintLinks: [ImprintLink], 
        /**
         * User tags for organization
         */tags: [String], 
        /**
         * Optional folder ID (None = unfiled)
         */folderId: String?, 
        /**
         * When this figure was created
         */createdAt: String, 
        /**
         * When this figure was last modified
         */modifiedAt: String) {
        self.id = id
        self.title = title
        self.thumbnail = thumbnail
        self.sessionId = sessionId
        self.viewStateSnapshot = viewStateSnapshot
        self.datasetSource = datasetSource
        self.imprintLinks = imprintLinks
        self.tags = tags
        self.folderId = folderId
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }
}



extension LibraryFigure: Equatable, Hashable {
    public static func ==(lhs: LibraryFigure, rhs: LibraryFigure) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.viewStateSnapshot != rhs.viewStateSnapshot {
            return false
        }
        if lhs.datasetSource != rhs.datasetSource {
            return false
        }
        if lhs.imprintLinks != rhs.imprintLinks {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.modifiedAt != rhs.modifiedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(thumbnail)
        hasher.combine(sessionId)
        hasher.combine(viewStateSnapshot)
        hasher.combine(datasetSource)
        hasher.combine(imprintLinks)
        hasher.combine(tags)
        hasher.combine(folderId)
        hasher.combine(createdAt)
        hasher.combine(modifiedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLibraryFigure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LibraryFigure {
        return
            try LibraryFigure(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterString.read(from: &buf), 
                thumbnail: FfiConverterOptionData.read(from: &buf), 
                sessionId: FfiConverterString.read(from: &buf), 
                viewStateSnapshot: FfiConverterString.read(from: &buf), 
                datasetSource: FfiConverterTypeDatasetSource.read(from: &buf), 
                imprintLinks: FfiConverterSequenceTypeImprintLink.read(from: &buf), 
                tags: FfiConverterSequenceString.read(from: &buf), 
                folderId: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf), 
                modifiedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LibraryFigure, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterOptionData.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.sessionId, into: &buf)
        FfiConverterString.write(value.viewStateSnapshot, into: &buf)
        FfiConverterTypeDatasetSource.write(value.datasetSource, into: &buf)
        FfiConverterSequenceTypeImprintLink.write(value.imprintLinks, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
        FfiConverterOptionString.write(value.folderId, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.modifiedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibraryFigure_lift(_ buf: RustBuffer) throws -> LibraryFigure {
    return try FfiConverterTypeLibraryFigure.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLibraryFigure_lower(_ value: LibraryFigure) -> RustBuffer {
    return FfiConverterTypeLibraryFigure.lower(value)
}


/**
 * A key-value metadata entry for FFI.
 */
public struct MetadataEntry {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension MetadataEntry: Equatable, Hashable {
    public static func ==(lhs: MetadataEntry, rhs: MetadataEntry) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMetadataEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataEntry {
        return
            try MetadataEntry(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadataEntry_lift(_ buf: RustBuffer) throws -> MetadataEntry {
    return try FfiConverterTypeMetadataEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadataEntry_lower(_ value: MetadataEntry) -> RustBuffer {
    return FfiConverterTypeMetadataEntry.lower(value)
}


/**
 * Constraints on parameter values
 */
public struct ParameterConstraints {
    /**
     * Minimum value (for numeric types)
     */
    public var min: Double?
    /**
     * Maximum value (for numeric types)
     */
    public var max: Double?
    /**
     * Step size for UI sliders
     */
    public var step: Double?
    /**
     * Whether the parameter must be a positive integer
     */
    public var positive: Bool
    /**
     * Whether the parameter must be a power of 2
     */
    public var powerOfTwo: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Minimum value (for numeric types)
         */min: Double?, 
        /**
         * Maximum value (for numeric types)
         */max: Double?, 
        /**
         * Step size for UI sliders
         */step: Double?, 
        /**
         * Whether the parameter must be a positive integer
         */positive: Bool, 
        /**
         * Whether the parameter must be a power of 2
         */powerOfTwo: Bool) {
        self.min = min
        self.max = max
        self.step = step
        self.positive = positive
        self.powerOfTwo = powerOfTwo
    }
}



extension ParameterConstraints: Equatable, Hashable {
    public static func ==(lhs: ParameterConstraints, rhs: ParameterConstraints) -> Bool {
        if lhs.min != rhs.min {
            return false
        }
        if lhs.max != rhs.max {
            return false
        }
        if lhs.step != rhs.step {
            return false
        }
        if lhs.positive != rhs.positive {
            return false
        }
        if lhs.powerOfTwo != rhs.powerOfTwo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(min)
        hasher.combine(max)
        hasher.combine(step)
        hasher.combine(positive)
        hasher.combine(powerOfTwo)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameterConstraints: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParameterConstraints {
        return
            try ParameterConstraints(
                min: FfiConverterOptionDouble.read(from: &buf), 
                max: FfiConverterOptionDouble.read(from: &buf), 
                step: FfiConverterOptionDouble.read(from: &buf), 
                positive: FfiConverterBool.read(from: &buf), 
                powerOfTwo: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ParameterConstraints, into buf: inout [UInt8]) {
        FfiConverterOptionDouble.write(value.min, into: &buf)
        FfiConverterOptionDouble.write(value.max, into: &buf)
        FfiConverterOptionDouble.write(value.step, into: &buf)
        FfiConverterBool.write(value.positive, into: &buf)
        FfiConverterBool.write(value.powerOfTwo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterConstraints_lift(_ buf: RustBuffer) throws -> ParameterConstraints {
    return try FfiConverterTypeParameterConstraints.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterConstraints_lower(_ value: ParameterConstraints) -> RustBuffer {
    return FfiConverterTypeParameterConstraints.lower(value)
}


/**
 * Specification for a generator parameter
 */
public struct ParameterSpec {
    /**
     * Internal parameter name (e.g., "resolution")
     */
    public var name: String
    /**
     * Display label (e.g., "Resolution")
     */
    public var label: String
    /**
     * Parameter type
     */
    public var paramType: ParameterType
    /**
     * Default value
     */
    public var defaultValue: ParameterValue
    /**
     * Optional constraints
     */
    public var constraints: ParameterConstraints?
    /**
     * Optional description/tooltip
     */
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Internal parameter name (e.g., "resolution")
         */name: String, 
        /**
         * Display label (e.g., "Resolution")
         */label: String, 
        /**
         * Parameter type
         */paramType: ParameterType, 
        /**
         * Default value
         */defaultValue: ParameterValue, 
        /**
         * Optional constraints
         */constraints: ParameterConstraints?, 
        /**
         * Optional description/tooltip
         */description: String?) {
        self.name = name
        self.label = label
        self.paramType = paramType
        self.defaultValue = defaultValue
        self.constraints = constraints
        self.description = description
    }
}



extension ParameterSpec: Equatable, Hashable {
    public static func ==(lhs: ParameterSpec, rhs: ParameterSpec) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.paramType != rhs.paramType {
            return false
        }
        if lhs.defaultValue != rhs.defaultValue {
            return false
        }
        if lhs.constraints != rhs.constraints {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(label)
        hasher.combine(paramType)
        hasher.combine(defaultValue)
        hasher.combine(constraints)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameterSpec: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParameterSpec {
        return
            try ParameterSpec(
                name: FfiConverterString.read(from: &buf), 
                label: FfiConverterString.read(from: &buf), 
                paramType: FfiConverterTypeParameterType.read(from: &buf), 
                defaultValue: FfiConverterTypeParameterValue.read(from: &buf), 
                constraints: FfiConverterOptionTypeParameterConstraints.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParameterSpec, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterTypeParameterType.write(value.paramType, into: &buf)
        FfiConverterTypeParameterValue.write(value.defaultValue, into: &buf)
        FfiConverterOptionTypeParameterConstraints.write(value.constraints, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterSpec_lift(_ buf: RustBuffer) throws -> ParameterSpec {
    return try FfiConverterTypeParameterSpec.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterSpec_lower(_ value: ParameterSpec) -> RustBuffer {
    return FfiConverterTypeParameterSpec.lower(value)
}


/**
 * Configuration for 2D scientific plots
 */
public struct Science2DConfig {
    /**
     * Field to map to X axis
     */
    public var xField: String
    /**
     * Field to map to Y axis
     */
    public var yField: String
    /**
     * Whether to show X marginal (ECDF)
     */
    public var showXMarginal: Bool
    /**
     * Whether to show Y marginal (ECDF)
     */
    public var showYMarginal: Bool
    /**
     * Axis scale for X (linear or log)
     */
    public var xScale: AxisScale
    /**
     * Axis scale for Y (linear or log)
     */
    public var yScale: AxisScale
    /**
     * Whether to show grid lines
     */
    public var showGrid: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Field to map to X axis
         */xField: String, 
        /**
         * Field to map to Y axis
         */yField: String, 
        /**
         * Whether to show X marginal (ECDF)
         */showXMarginal: Bool, 
        /**
         * Whether to show Y marginal (ECDF)
         */showYMarginal: Bool, 
        /**
         * Axis scale for X (linear or log)
         */xScale: AxisScale, 
        /**
         * Axis scale for Y (linear or log)
         */yScale: AxisScale, 
        /**
         * Whether to show grid lines
         */showGrid: Bool) {
        self.xField = xField
        self.yField = yField
        self.showXMarginal = showXMarginal
        self.showYMarginal = showYMarginal
        self.xScale = xScale
        self.yScale = yScale
        self.showGrid = showGrid
    }
}



extension Science2DConfig: Equatable, Hashable {
    public static func ==(lhs: Science2DConfig, rhs: Science2DConfig) -> Bool {
        if lhs.xField != rhs.xField {
            return false
        }
        if lhs.yField != rhs.yField {
            return false
        }
        if lhs.showXMarginal != rhs.showXMarginal {
            return false
        }
        if lhs.showYMarginal != rhs.showYMarginal {
            return false
        }
        if lhs.xScale != rhs.xScale {
            return false
        }
        if lhs.yScale != rhs.yScale {
            return false
        }
        if lhs.showGrid != rhs.showGrid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(xField)
        hasher.combine(yField)
        hasher.combine(showXMarginal)
        hasher.combine(showYMarginal)
        hasher.combine(xScale)
        hasher.combine(yScale)
        hasher.combine(showGrid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScience2DConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Science2DConfig {
        return
            try Science2DConfig(
                xField: FfiConverterString.read(from: &buf), 
                yField: FfiConverterString.read(from: &buf), 
                showXMarginal: FfiConverterBool.read(from: &buf), 
                showYMarginal: FfiConverterBool.read(from: &buf), 
                xScale: FfiConverterTypeAxisScale.read(from: &buf), 
                yScale: FfiConverterTypeAxisScale.read(from: &buf), 
                showGrid: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Science2DConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.xField, into: &buf)
        FfiConverterString.write(value.yField, into: &buf)
        FfiConverterBool.write(value.showXMarginal, into: &buf)
        FfiConverterBool.write(value.showYMarginal, into: &buf)
        FfiConverterTypeAxisScale.write(value.xScale, into: &buf)
        FfiConverterTypeAxisScale.write(value.yScale, into: &buf)
        FfiConverterBool.write(value.showGrid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScience2DConfig_lift(_ buf: RustBuffer) throws -> Science2DConfig {
    return try FfiConverterTypeScience2DConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScience2DConfig_lower(_ value: Science2DConfig) -> RustBuffer {
    return FfiConverterTypeScience2DConfig.lower(value)
}


/**
 * Selection bounds in data coordinates
 */
public struct SelectionBounds {
    /**
     * Minimum corner
     */
    public var min: Vec3d
    /**
     * Maximum corner
     */
    public var max: Vec3d

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Minimum corner
         */min: Vec3d, 
        /**
         * Maximum corner
         */max: Vec3d) {
        self.min = min
        self.max = max
    }
}



extension SelectionBounds: Equatable, Hashable {
    public static func ==(lhs: SelectionBounds, rhs: SelectionBounds) -> Bool {
        if lhs.min != rhs.min {
            return false
        }
        if lhs.max != rhs.max {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(min)
        hasher.combine(max)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectionBounds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionBounds {
        return
            try SelectionBounds(
                min: FfiConverterTypeVec3d.read(from: &buf), 
                max: FfiConverterTypeVec3d.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionBounds, into buf: inout [UInt8]) {
        FfiConverterTypeVec3d.write(value.min, into: &buf)
        FfiConverterTypeVec3d.write(value.max, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionBounds_lift(_ buf: RustBuffer) throws -> SelectionBounds {
    return try FfiConverterTypeSelectionBounds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionBounds_lower(_ value: SelectionBounds) -> RustBuffer {
    return FfiConverterTypeSelectionBounds.lower(value)
}


/**
 * A figure exported from a session
 */
public struct SessionFigure {
    /**
     * Unique figure identifier
     */
    public var id: String
    /**
     * Figure title
     */
    public var title: String?
    /**
     * Figure caption
     */
    public var caption: String?
    /**
     * View state snapshot (JSON)
     */
    public var viewStateSnapshot: String
    /**
     * Dataset ID this figure was created from
     */
    public var datasetId: String
    /**
     * Exported formats
     */
    public var exports: [FigureExport]
    /**
     * Creation timestamp
     */
    public var createdAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique figure identifier
         */id: String, 
        /**
         * Figure title
         */title: String?, 
        /**
         * Figure caption
         */caption: String?, 
        /**
         * View state snapshot (JSON)
         */viewStateSnapshot: String, 
        /**
         * Dataset ID this figure was created from
         */datasetId: String, 
        /**
         * Exported formats
         */exports: [FigureExport], 
        /**
         * Creation timestamp
         */createdAt: String) {
        self.id = id
        self.title = title
        self.caption = caption
        self.viewStateSnapshot = viewStateSnapshot
        self.datasetId = datasetId
        self.exports = exports
        self.createdAt = createdAt
    }
}



extension SessionFigure: Equatable, Hashable {
    public static func ==(lhs: SessionFigure, rhs: SessionFigure) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.caption != rhs.caption {
            return false
        }
        if lhs.viewStateSnapshot != rhs.viewStateSnapshot {
            return false
        }
        if lhs.datasetId != rhs.datasetId {
            return false
        }
        if lhs.exports != rhs.exports {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(caption)
        hasher.combine(viewStateSnapshot)
        hasher.combine(datasetId)
        hasher.combine(exports)
        hasher.combine(createdAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionFigure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionFigure {
        return
            try SessionFigure(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                viewStateSnapshot: FfiConverterString.read(from: &buf), 
                datasetId: FfiConverterString.read(from: &buf), 
                exports: FfiConverterSequenceTypeFigureExport.read(from: &buf), 
                createdAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SessionFigure, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterString.write(value.viewStateSnapshot, into: &buf)
        FfiConverterString.write(value.datasetId, into: &buf)
        FfiConverterSequenceTypeFigureExport.write(value.exports, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionFigure_lift(_ buf: RustBuffer) throws -> SessionFigure {
    return try FfiConverterTypeSessionFigure.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionFigure_lower(_ value: SessionFigure) -> RustBuffer {
    return FfiConverterTypeSessionFigure.lower(value)
}


/**
 * A shader parameter with name and value
 */
public struct ShaderParameter {
    public var name: String
    public var value: ShaderValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, value: ShaderValue) {
        self.name = name
        self.value = value
    }
}



extension ShaderParameter: Equatable, Hashable {
    public static func ==(lhs: ShaderParameter, rhs: ShaderParameter) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShaderParameter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShaderParameter {
        return
            try ShaderParameter(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterTypeShaderValue.read(from: &buf)
        )
    }

    public static func write(_ value: ShaderParameter, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeShaderValue.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShaderParameter_lift(_ buf: RustBuffer) throws -> ShaderParameter {
    return try FfiConverterTypeShaderParameter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShaderParameter_lower(_ value: ShaderParameter) -> RustBuffer {
    return FfiConverterTypeShaderParameter.lower(value)
}


/**
 * A 2D vector of f32 values
 */
public struct Vec2f {
    public var x: Float
    public var y: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float) {
        self.x = x
        self.y = y
    }
}



extension Vec2f: Equatable, Hashable {
    public static func ==(lhs: Vec2f, rhs: Vec2f) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVec2f: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vec2f {
        return
            try Vec2f(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Vec2f, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec2f_lift(_ buf: RustBuffer) throws -> Vec2f {
    return try FfiConverterTypeVec2f.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec2f_lower(_ value: Vec2f) -> RustBuffer {
    return FfiConverterTypeVec2f.lower(value)
}


/**
 * A 3D vector of f64 values (for double-precision coordinates)
 */
public struct Vec3d {
    public var x: Double
    public var y: Double
    public var z: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double, z: Double) {
        self.x = x
        self.y = y
        self.z = z
    }
}



extension Vec3d: Equatable, Hashable {
    public static func ==(lhs: Vec3d, rhs: Vec3d) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.z != rhs.z {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(z)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVec3d: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vec3d {
        return
            try Vec3d(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                z: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Vec3d, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.z, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3d_lift(_ buf: RustBuffer) throws -> Vec3d {
    return try FfiConverterTypeVec3d.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3d_lower(_ value: Vec3d) -> RustBuffer {
    return FfiConverterTypeVec3d.lower(value)
}


/**
 * A 3D vector of f32 values
 */
public struct Vec3f {
    public var x: Float
    public var y: Float
    public var z: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float, z: Float) {
        self.x = x
        self.y = y
        self.z = z
    }
}



extension Vec3f: Equatable, Hashable {
    public static func ==(lhs: Vec3f, rhs: Vec3f) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.z != rhs.z {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(z)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVec3f: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vec3f {
        return
            try Vec3f(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf), 
                z: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Vec3f, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
        FfiConverterFloat.write(value.z, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3f_lift(_ buf: RustBuffer) throws -> Vec3f {
    return try FfiConverterTypeVec3f.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3f_lower(_ value: Vec3f) -> RustBuffer {
    return FfiConverterTypeVec3f.lower(value)
}


/**
 * A 4D vector of f32 values
 */
public struct Vec4f {
    public var x: Float
    public var y: Float
    public var z: Float
    public var w: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Float, y: Float, z: Float, w: Float) {
        self.x = x
        self.y = y
        self.z = z
        self.w = w
    }
}



extension Vec4f: Equatable, Hashable {
    public static func ==(lhs: Vec4f, rhs: Vec4f) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.z != rhs.z {
            return false
        }
        if lhs.w != rhs.w {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(z)
        hasher.combine(w)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVec4f: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vec4f {
        return
            try Vec4f(
                x: FfiConverterFloat.read(from: &buf), 
                y: FfiConverterFloat.read(from: &buf), 
                z: FfiConverterFloat.read(from: &buf), 
                w: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: Vec4f, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.x, into: &buf)
        FfiConverterFloat.write(value.y, into: &buf)
        FfiConverterFloat.write(value.z, into: &buf)
        FfiConverterFloat.write(value.w, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec4f_lift(_ buf: RustBuffer) throws -> Vec4f {
    return try FfiConverterTypeVec4f.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec4f_lower(_ value: Vec4f) -> RustBuffer {
    return FfiConverterTypeVec4f.lower(value)
}


/**
 * Current state of the visualization view
 */
public struct ViewState {
    /**
     * Rendering mode (Science2D, Box3D, or ArtShader)
     */
    public var mode: RenderMode
    /**
     * 3D camera state (used in Box3D and ArtShader modes)
     */
    public var camera: Camera3D
    /**
     * Color mapping configuration
     */
    public var colorMapping: ColorMapping
    /**
     * Point size in pixels
     */
    public var pointSize: Float
    /**
     * Current selection bounds (if any)
     */
    public var selectionBounds: SelectionBounds?
    /**
     * Visible layers (for multi-layer datasets)
     */
    public var visibleLayers: [String]
    /**
     * Whether to show axes
     */
    public var showAxes: Bool
    /**
     * Whether to show grid
     */
    public var showGrid: Bool
    /**
     * Background color (RGB, 0-1)
     */
    public var backgroundColor: ColorRgb

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Rendering mode (Science2D, Box3D, or ArtShader)
         */mode: RenderMode, 
        /**
         * 3D camera state (used in Box3D and ArtShader modes)
         */camera: Camera3D, 
        /**
         * Color mapping configuration
         */colorMapping: ColorMapping, 
        /**
         * Point size in pixels
         */pointSize: Float, 
        /**
         * Current selection bounds (if any)
         */selectionBounds: SelectionBounds?, 
        /**
         * Visible layers (for multi-layer datasets)
         */visibleLayers: [String], 
        /**
         * Whether to show axes
         */showAxes: Bool, 
        /**
         * Whether to show grid
         */showGrid: Bool, 
        /**
         * Background color (RGB, 0-1)
         */backgroundColor: ColorRgb) {
        self.mode = mode
        self.camera = camera
        self.colorMapping = colorMapping
        self.pointSize = pointSize
        self.selectionBounds = selectionBounds
        self.visibleLayers = visibleLayers
        self.showAxes = showAxes
        self.showGrid = showGrid
        self.backgroundColor = backgroundColor
    }
}



extension ViewState: Equatable, Hashable {
    public static func ==(lhs: ViewState, rhs: ViewState) -> Bool {
        if lhs.mode != rhs.mode {
            return false
        }
        if lhs.camera != rhs.camera {
            return false
        }
        if lhs.colorMapping != rhs.colorMapping {
            return false
        }
        if lhs.pointSize != rhs.pointSize {
            return false
        }
        if lhs.selectionBounds != rhs.selectionBounds {
            return false
        }
        if lhs.visibleLayers != rhs.visibleLayers {
            return false
        }
        if lhs.showAxes != rhs.showAxes {
            return false
        }
        if lhs.showGrid != rhs.showGrid {
            return false
        }
        if lhs.backgroundColor != rhs.backgroundColor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mode)
        hasher.combine(camera)
        hasher.combine(colorMapping)
        hasher.combine(pointSize)
        hasher.combine(selectionBounds)
        hasher.combine(visibleLayers)
        hasher.combine(showAxes)
        hasher.combine(showGrid)
        hasher.combine(backgroundColor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeViewState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ViewState {
        return
            try ViewState(
                mode: FfiConverterTypeRenderMode.read(from: &buf), 
                camera: FfiConverterTypeCamera3D.read(from: &buf), 
                colorMapping: FfiConverterTypeColorMapping.read(from: &buf), 
                pointSize: FfiConverterFloat.read(from: &buf), 
                selectionBounds: FfiConverterOptionTypeSelectionBounds.read(from: &buf), 
                visibleLayers: FfiConverterSequenceString.read(from: &buf), 
                showAxes: FfiConverterBool.read(from: &buf), 
                showGrid: FfiConverterBool.read(from: &buf), 
                backgroundColor: FfiConverterTypeColorRgb.read(from: &buf)
        )
    }

    public static func write(_ value: ViewState, into buf: inout [UInt8]) {
        FfiConverterTypeRenderMode.write(value.mode, into: &buf)
        FfiConverterTypeCamera3D.write(value.camera, into: &buf)
        FfiConverterTypeColorMapping.write(value.colorMapping, into: &buf)
        FfiConverterFloat.write(value.pointSize, into: &buf)
        FfiConverterOptionTypeSelectionBounds.write(value.selectionBounds, into: &buf)
        FfiConverterSequenceString.write(value.visibleLayers, into: &buf)
        FfiConverterBool.write(value.showAxes, into: &buf)
        FfiConverterBool.write(value.showGrid, into: &buf)
        FfiConverterTypeColorRgb.write(value.backgroundColor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeViewState_lift(_ buf: RustBuffer) throws -> ViewState {
    return try FfiConverterTypeViewState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeViewState_lower(_ value: ViewState) -> RustBuffer {
    return FfiConverterTypeViewState.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Axis scale type
 */

public enum AxisScale {
    
    case linear
    case log10
    case log2
    case symLog
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAxisScale: FfiConverterRustBuffer {
    typealias SwiftType = AxisScale

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AxisScale {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .linear
        
        case 2: return .log10
        
        case 3: return .log2
        
        case 4: return .symLog
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AxisScale, into buf: inout [UInt8]) {
        switch value {
        
        
        case .linear:
            writeInt(&buf, Int32(1))
        
        
        case .log10:
            writeInt(&buf, Int32(2))
        
        
        case .log2:
            writeInt(&buf, Int32(3))
        
        
        case .symLog:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAxisScale_lift(_ buf: RustBuffer) throws -> AxisScale {
    return try FfiConverterTypeAxisScale.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAxisScale_lower(_ value: AxisScale) -> RustBuffer {
    return FfiConverterTypeAxisScale.lower(value)
}



extension AxisScale: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Data type for a field
 */

public enum DataType {
    
    /**
     * 32-bit floating point
     */
    case float32
    /**
     * 64-bit floating point
     */
    case float64
    /**
     * 32-bit signed integer
     */
    case int32
    /**
     * 64-bit signed integer
     */
    case int64
    /**
     * Boolean
     */
    case bool
    /**
     * UTF-8 string
     */
    case string
    /**
     * Unknown or unsupported type
     */
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataType: FfiConverterRustBuffer {
    typealias SwiftType = DataType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .float32
        
        case 2: return .float64
        
        case 3: return .int32
        
        case 4: return .int64
        
        case 5: return .bool
        
        case 6: return .string
        
        case 7: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DataType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .float32:
            writeInt(&buf, Int32(1))
        
        
        case .float64:
            writeInt(&buf, Int32(2))
        
        
        case .int32:
            writeInt(&buf, Int32(3))
        
        
        case .int64:
            writeInt(&buf, Int32(4))
        
        
        case .bool:
            writeInt(&buf, Int32(5))
        
        
        case .string:
            writeInt(&buf, Int32(6))
        
        
        case .unknown:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataType_lift(_ buf: RustBuffer) throws -> DataType {
    return try FfiConverterTypeDataType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataType_lower(_ value: DataType) -> RustBuffer {
    return FfiConverterTypeDataType.lower(value)
}



extension DataType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Source location and format for a dataset
 */

public enum DatasetSource {
    
    /**
     * HDF5 file with dataset path
     */
    case hdf5(path: String, datasetPath: String
    )
    /**
     * FITS file with extension number
     */
    case fits(path: String, `extension`: UInt32
    )
    /**
     * CSV file with optional delimiter (as a single-character string for FFI compatibility)
     */
    case csv(path: String, delimiter: String?
    )
    /**
     * Parquet file
     */
    case parquet(path: String
    )
    /**
     * In-memory data (for testing or generated data)
     */
    case inMemory(format: String
    )
    /**
     * Plugin-generated data
     */
    case generated(
        /**
         * ID of the generator used
         */generatorId: String, 
        /**
         * JSON-serialized parameters
         */paramsJson: String, 
        /**
         * When the data was generated
         */generatedAt: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatasetSource: FfiConverterRustBuffer {
    typealias SwiftType = DatasetSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatasetSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hdf5(path: try FfiConverterString.read(from: &buf), datasetPath: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .fits(path: try FfiConverterString.read(from: &buf), extension: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .csv(path: try FfiConverterString.read(from: &buf), delimiter: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .parquet(path: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .inMemory(format: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .generated(generatorId: try FfiConverterString.read(from: &buf), paramsJson: try FfiConverterString.read(from: &buf), generatedAt: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatasetSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hdf5(path,datasetPath):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(path, into: &buf)
            FfiConverterString.write(datasetPath, into: &buf)
            
        
        case let .fits(path,`extension`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(path, into: &buf)
            FfiConverterUInt32.write(`extension`, into: &buf)
            
        
        case let .csv(path,delimiter):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(path, into: &buf)
            FfiConverterOptionString.write(delimiter, into: &buf)
            
        
        case let .parquet(path):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(path, into: &buf)
            
        
        case let .inMemory(format):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(format, into: &buf)
            
        
        case let .generated(generatorId,paramsJson,generatedAt):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(generatorId, into: &buf)
            FfiConverterString.write(paramsJson, into: &buf)
            FfiConverterString.write(generatedAt, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetSource_lift(_ buf: RustBuffer) throws -> DatasetSource {
    return try FfiConverterTypeDatasetSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatasetSource_lower(_ value: DatasetSource) -> RustBuffer {
    return FfiConverterTypeDatasetSource.lower(value)
}



extension DatasetSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Figure export formats
 */

public enum FigureFormat {
    
    /**
     * PNG raster image
     */
    case png
    /**
     * PDF vector format
     */
    case pdf
    /**
     * SVG vector format
     */
    case svg
    /**
     * EPS (Encapsulated PostScript)
     */
    case eps
    /**
     * Native Typst figure for imprint embedding
     */
    case typst
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFigureFormat: FfiConverterRustBuffer {
    typealias SwiftType = FigureFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FigureFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .png
        
        case 2: return .pdf
        
        case 3: return .svg
        
        case 4: return .eps
        
        case 5: return .typst
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FigureFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .png:
            writeInt(&buf, Int32(1))
        
        
        case .pdf:
            writeInt(&buf, Int32(2))
        
        
        case .svg:
            writeInt(&buf, Int32(3))
        
        
        case .eps:
            writeInt(&buf, Int32(4))
        
        
        case .typst:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureFormat_lift(_ buf: RustBuffer) throws -> FigureFormat {
    return try FfiConverterTypeFigureFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFigureFormat_lower(_ value: FigureFormat) -> RustBuffer {
    return FfiConverterTypeFigureFormat.lower(value)
}



extension FigureFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Category of data generator
 */

public enum GeneratorCategory {
    
    /**
     * Noise generators (Perlin, Simplex, Worley, etc.)
     */
    case noise
    /**
     * Fractal generators (Mandelbrot, Julia, etc.)
     */
    case fractal
    /**
     * Statistical distributions (Gaussian clusters, power-law, etc.)
     */
    case statistical
    /**
     * Mathematical functions (sin, cos, parametric, etc.)
     */
    case function
    /**
     * Physics simulations (N-body, fluid, etc.)
     */
    case simulation
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratorCategory: FfiConverterRustBuffer {
    typealias SwiftType = GeneratorCategory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratorCategory {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noise
        
        case 2: return .fractal
        
        case 3: return .statistical
        
        case 4: return .function
        
        case 5: return .simulation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GeneratorCategory, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noise:
            writeInt(&buf, Int32(1))
        
        
        case .fractal:
            writeInt(&buf, Int32(2))
        
        
        case .statistical:
            writeInt(&buf, Int32(3))
        
        
        case .function:
            writeInt(&buf, Int32(4))
        
        
        case .simulation:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorCategory_lift(_ buf: RustBuffer) throws -> GeneratorCategory {
    return try FfiConverterTypeGeneratorCategory.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratorCategory_lower(_ value: GeneratorCategory) -> RustBuffer {
    return FfiConverterTypeGeneratorCategory.lower(value)
}



extension GeneratorCategory: Equatable, Hashable {}




/**
 * FFI-safe error type for generator operations.
 */
public enum GeneratorErrorFfi {

    
    
    /**
     * Generator with the given ID was not found
     */
    case NotFound(generatorId: String
    )
    /**
     * A parameter was invalid
     */
    case InvalidParameter(name: String, reason: String
    )
    /**
     * A required parameter was missing
     */
    case MissingParameter(name: String
    )
    /**
     * Parameter type did not match expected type
     */
    case TypeMismatch(name: String, expected: String
    )
    /**
     * Generation failed with an error message
     */
    case GenerationFailed(message: String
    )
    /**
     * Expression parsing failed
     */
    case ExpressionError(message: String
    )
    /**
     * The dataset is not from a generator
     */
    case NotGenerated
    /**
     * JSON serialization/deserialization error
     */
    case JsonError(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratorErrorFfi: FfiConverterRustBuffer {
    typealias SwiftType = GeneratorErrorFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratorErrorFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotFound(
            generatorId: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidParameter(
            name: try FfiConverterString.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 3: return .MissingParameter(
            name: try FfiConverterString.read(from: &buf)
            )
        case 4: return .TypeMismatch(
            name: try FfiConverterString.read(from: &buf), 
            expected: try FfiConverterString.read(from: &buf)
            )
        case 5: return .GenerationFailed(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .ExpressionError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 7: return .NotGenerated
        case 8: return .JsonError(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GeneratorErrorFfi, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .NotFound(generatorId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(generatorId, into: &buf)
            
        
        case let .InvalidParameter(name,reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .MissingParameter(name):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .TypeMismatch(name,expected):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(expected, into: &buf)
            
        
        case let .GenerationFailed(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .ExpressionError(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
            
        
        case .NotGenerated:
            writeInt(&buf, Int32(7))
        
        
        case let .JsonError(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


extension GeneratorErrorFfi: Equatable, Hashable {}

extension GeneratorErrorFfi: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of a parameter
 */

public enum ParameterType {
    
    /**
     * 64-bit floating point
     */
    case float
    /**
     * 64-bit signed integer
     */
    case int
    /**
     * Boolean
     */
    case bool
    /**
     * String (for expressions, file paths, etc.)
     */
    case string
    /**
     * 2D vector [x, y]
     */
    case vec2
    /**
     * 3D vector [x, y, z]
     */
    case vec3
    /**
     * Range with min and max
     */
    case range(min: Double, max: Double
    )
    /**
     * Choice from a list of options
     */
    case choice(options: [String]
    )
    /**
     * Color (RGBA)
     */
    case color
    /**
     * Polynomial coefficients for power spectrum
     */
    case polynomial
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameterType: FfiConverterRustBuffer {
    typealias SwiftType = ParameterType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParameterType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .float
        
        case 2: return .int
        
        case 3: return .bool
        
        case 4: return .string
        
        case 5: return .vec2
        
        case 6: return .vec3
        
        case 7: return .range(min: try FfiConverterDouble.read(from: &buf), max: try FfiConverterDouble.read(from: &buf)
        )
        
        case 8: return .choice(options: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 9: return .color
        
        case 10: return .polynomial
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParameterType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .float:
            writeInt(&buf, Int32(1))
        
        
        case .int:
            writeInt(&buf, Int32(2))
        
        
        case .bool:
            writeInt(&buf, Int32(3))
        
        
        case .string:
            writeInt(&buf, Int32(4))
        
        
        case .vec2:
            writeInt(&buf, Int32(5))
        
        
        case .vec3:
            writeInt(&buf, Int32(6))
        
        
        case let .range(min,max):
            writeInt(&buf, Int32(7))
            FfiConverterDouble.write(min, into: &buf)
            FfiConverterDouble.write(max, into: &buf)
            
        
        case let .choice(options):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceString.write(options, into: &buf)
            
        
        case .color:
            writeInt(&buf, Int32(9))
        
        
        case .polynomial:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterType_lift(_ buf: RustBuffer) throws -> ParameterType {
    return try FfiConverterTypeParameterType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterType_lower(_ value: ParameterType) -> RustBuffer {
    return FfiConverterTypeParameterType.lower(value)
}



extension ParameterType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Runtime parameter value
 */

public enum ParameterValue {
    
    case float(Double
    )
    case int(Int64
    )
    case bool(Bool
    )
    case string(String
    )
    case vec([Double]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParameterValue: FfiConverterRustBuffer {
    typealias SwiftType = ParameterValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParameterValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .float(try FfiConverterDouble.read(from: &buf)
        )
        
        case 2: return .int(try FfiConverterInt64.read(from: &buf)
        )
        
        case 3: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 4: return .string(try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .vec(try FfiConverterSequenceDouble.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParameterValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .float(v1):
            writeInt(&buf, Int32(1))
            FfiConverterDouble.write(v1, into: &buf)
            
        
        case let .int(v1):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(v1, into: &buf)
            
        
        case let .bool(v1):
            writeInt(&buf, Int32(3))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .string(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .vec(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceDouble.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterValue_lift(_ buf: RustBuffer) throws -> ParameterValue {
    return try FfiConverterTypeParameterValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParameterValue_lower(_ value: ParameterValue) -> RustBuffer {
    return FfiConverterTypeParameterValue.lower(value)
}



extension ParameterValue: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Post-processing effects
 */

public enum PostEffect {
    
    /**
     * Bloom effect with intensity
     */
    case bloom(intensity: Float
    )
    /**
     * Depth of field with focus distance and blur amount
     */
    case depthOfField(focusDistance: Float, blur: Float
    )
    /**
     * Vignette with intensity
     */
    case vignette(intensity: Float
    )
    /**
     * Color grading with LUT name
     */
    case colorGrade(lutName: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePostEffect: FfiConverterRustBuffer {
    typealias SwiftType = PostEffect

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostEffect {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bloom(intensity: try FfiConverterFloat.read(from: &buf)
        )
        
        case 2: return .depthOfField(focusDistance: try FfiConverterFloat.read(from: &buf), blur: try FfiConverterFloat.read(from: &buf)
        )
        
        case 3: return .vignette(intensity: try FfiConverterFloat.read(from: &buf)
        )
        
        case 4: return .colorGrade(lutName: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PostEffect, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bloom(intensity):
            writeInt(&buf, Int32(1))
            FfiConverterFloat.write(intensity, into: &buf)
            
        
        case let .depthOfField(focusDistance,blur):
            writeInt(&buf, Int32(2))
            FfiConverterFloat.write(focusDistance, into: &buf)
            FfiConverterFloat.write(blur, into: &buf)
            
        
        case let .vignette(intensity):
            writeInt(&buf, Int32(3))
            FfiConverterFloat.write(intensity, into: &buf)
            
        
        case let .colorGrade(lutName):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(lutName, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePostEffect_lift(_ buf: RustBuffer) throws -> PostEffect {
    return try FfiConverterTypePostEffect.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePostEffect_lower(_ value: PostEffect) -> RustBuffer {
    return FfiConverterTypePostEffect.lower(value)
}



extension PostEffect: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Rendering mode for the visualization
 */

public enum RenderMode {
    
    /**
     * 2D statistical plots with axes and marginals
     */
    case science2D(Science2DConfig
    )
    /**
     * 3D point cloud viewer with perspective camera
     */
    case box3D(Box3DConfig
    )
    /**
     * Custom shader rendering for artistic visualizations
     */
    case artShader(ArtShaderConfig
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRenderMode: FfiConverterRustBuffer {
    typealias SwiftType = RenderMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RenderMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .science2D(try FfiConverterTypeScience2DConfig.read(from: &buf)
        )
        
        case 2: return .box3D(try FfiConverterTypeBox3DConfig.read(from: &buf)
        )
        
        case 3: return .artShader(try FfiConverterTypeArtShaderConfig.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RenderMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .science2D(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeScience2DConfig.write(v1, into: &buf)
            
        
        case let .box3D(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBox3DConfig.write(v1, into: &buf)
            
        
        case let .artShader(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeArtShaderConfig.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRenderMode_lift(_ buf: RustBuffer) throws -> RenderMode {
    return try FfiConverterTypeRenderMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRenderMode_lower(_ value: RenderMode) -> RustBuffer {
    return FfiConverterTypeRenderMode.lower(value)
}



extension RenderMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Value types for shader parameters
 */

public enum ShaderValue {
    
    case float(Float
    )
    case vec2(Vec2f
    )
    case vec3(Vec3f
    )
    case vec4(Vec4f
    )
    case int(Int32
    )
    case bool(Bool
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShaderValue: FfiConverterRustBuffer {
    typealias SwiftType = ShaderValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShaderValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .float(try FfiConverterFloat.read(from: &buf)
        )
        
        case 2: return .vec2(try FfiConverterTypeVec2f.read(from: &buf)
        )
        
        case 3: return .vec3(try FfiConverterTypeVec3f.read(from: &buf)
        )
        
        case 4: return .vec4(try FfiConverterTypeVec4f.read(from: &buf)
        )
        
        case 5: return .int(try FfiConverterInt32.read(from: &buf)
        )
        
        case 6: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShaderValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .float(v1):
            writeInt(&buf, Int32(1))
            FfiConverterFloat.write(v1, into: &buf)
            
        
        case let .vec2(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeVec2f.write(v1, into: &buf)
            
        
        case let .vec3(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeVec3f.write(v1, into: &buf)
            
        
        case let .vec4(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVec4f.write(v1, into: &buf)
            
        
        case let .int(v1):
            writeInt(&buf, Int32(5))
            FfiConverterInt32.write(v1, into: &buf)
            
        
        case let .bool(v1):
            writeInt(&buf, Int32(6))
            FfiConverterBool.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShaderValue_lift(_ buf: RustBuffer) throws -> ShaderValue {
    return try FfiConverterTypeShaderValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShaderValue_lower(_ value: ShaderValue) -> RustBuffer {
    return FfiConverterTypeShaderValue.lower(value)
}



extension ShaderValue: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeGeneratorMetadata: FfiConverterRustBuffer {
    typealias SwiftType = GeneratorMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGeneratorMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGeneratorMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeParameterConstraints: FfiConverterRustBuffer {
    typealias SwiftType = ParameterConstraints?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeParameterConstraints.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeParameterConstraints.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSelectionBounds: FfiConverterRustBuffer {
    typealias SwiftType = SelectionBounds?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSelectionBounds.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSelectionBounds.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceDouble: FfiConverterRustBuffer {
    typealias SwiftType = [Double]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceDouble: FfiConverterRustBuffer {
    typealias SwiftType = [Double]

    public static func write(_ value: [Double], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterDouble.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Double] {
        let len: Int32 = try readInt(&buf)
        var seq = [Double]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterDouble.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFieldDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = [FieldDescriptor]

    public static func write(_ value: [FieldDescriptor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldDescriptor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldDescriptor] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldDescriptor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldDescriptor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFigureExport: FfiConverterRustBuffer {
    typealias SwiftType = [FigureExport]

    public static func write(_ value: [FigureExport], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFigureExport.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FigureExport] {
        let len: Int32 = try readInt(&buf)
        var seq = [FigureExport]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFigureExport.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFigureFolder: FfiConverterRustBuffer {
    typealias SwiftType = [FigureFolder]

    public static func write(_ value: [FigureFolder], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFigureFolder.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FigureFolder] {
        let len: Int32 = try readInt(&buf)
        var seq = [FigureFolder]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFigureFolder.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGeneratorMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [GeneratorMetadata]

    public static func write(_ value: [GeneratorMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGeneratorMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GeneratorMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [GeneratorMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGeneratorMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeImprintLink: FfiConverterRustBuffer {
    typealias SwiftType = [ImprintLink]

    public static func write(_ value: [ImprintLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeImprintLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ImprintLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [ImprintLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeImprintLink.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLibraryFigure: FfiConverterRustBuffer {
    typealias SwiftType = [LibraryFigure]

    public static func write(_ value: [LibraryFigure], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLibraryFigure.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LibraryFigure] {
        let len: Int32 = try readInt(&buf)
        var seq = [LibraryFigure]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLibraryFigure.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMetadataEntry: FfiConverterRustBuffer {
    typealias SwiftType = [MetadataEntry]

    public static func write(_ value: [MetadataEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMetadataEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MetadataEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [MetadataEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMetadataEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParameterSpec: FfiConverterRustBuffer {
    typealias SwiftType = [ParameterSpec]

    public static func write(_ value: [ParameterSpec], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParameterSpec.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParameterSpec] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParameterSpec]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParameterSpec.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeShaderParameter: FfiConverterRustBuffer {
    typealias SwiftType = [ShaderParameter]

    public static func write(_ value: [ShaderParameter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShaderParameter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShaderParameter] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShaderParameter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShaderParameter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGeneratorCategory: FfiConverterRustBuffer {
    typealias SwiftType = [GeneratorCategory]

    public static func write(_ value: [GeneratorCategory], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGeneratorCategory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GeneratorCategory] {
        let len: Int32 = try readInt(&buf)
        var seq = [GeneratorCategory]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGeneratorCategory.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePostEffect: FfiConverterRustBuffer {
    typealias SwiftType = [PostEffect]

    public static func write(_ value: [PostEffect], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePostEffect.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostEffect] {
        let len: Int32 = try readInt(&buf)
        var seq = [PostEffect]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePostEffect.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_implore_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_categories() != 41569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_count() != 16245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_default_params_json() != 11426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_generate() != 42272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_get_metadata() != 64114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_list_all() != 61835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_list_by_category() != 48414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_method_generatorregistryhandle_search() != 41774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_implore_core_checksum_constructor_generatorregistryhandle_new() != 49680) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all