// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(imbib_coreFFI)
import imbib_coreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_imbib_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_imbib_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


/**
 * A parsed BibTeX entry
 */
public struct BibTeXEntry {
    public var citeKey: String
    public var entryType: BibTeXEntryType
    public var fields: [BibTeXField]
    public var rawBibtex: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(citeKey: String, entryType: BibTeXEntryType, fields: [BibTeXField], rawBibtex: String?) {
        self.citeKey = citeKey
        self.entryType = entryType
        self.fields = fields
        self.rawBibtex = rawBibtex
    }
}



extension BibTeXEntry: Equatable, Hashable {
    public static func ==(lhs: BibTeXEntry, rhs: BibTeXEntry) -> Bool {
        if lhs.citeKey != rhs.citeKey {
            return false
        }
        if lhs.entryType != rhs.entryType {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.rawBibtex != rhs.rawBibtex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(citeKey)
        hasher.combine(entryType)
        hasher.combine(fields)
        hasher.combine(rawBibtex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXEntry {
        return
            try BibTeXEntry(
                citeKey: FfiConverterString.read(from: &buf), 
                entryType: FfiConverterTypeBibTeXEntryType.read(from: &buf), 
                fields: FfiConverterSequenceTypeBibTeXField.read(from: &buf), 
                rawBibtex: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.citeKey, into: &buf)
        FfiConverterTypeBibTeXEntryType.write(value.entryType, into: &buf)
        FfiConverterSequenceTypeBibTeXField.write(value.fields, into: &buf)
        FfiConverterOptionString.write(value.rawBibtex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntry_lift(_ buf: RustBuffer) throws -> BibTeXEntry {
    return try FfiConverterTypeBibTeXEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntry_lower(_ value: BibTeXEntry) -> RustBuffer {
    return FfiConverterTypeBibTeXEntry.lower(value)
}


/**
 * A single BibTeX field (key-value pair)
 */
public struct BibTeXField {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension BibTeXField: Equatable, Hashable {
    public static func ==(lhs: BibTeXField, rhs: BibTeXField) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXField {
        return
            try BibTeXField(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXField, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXField_lift(_ buf: RustBuffer) throws -> BibTeXField {
    return try FfiConverterTypeBibTeXField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXField_lower(_ value: BibTeXField) -> RustBuffer {
    return FfiConverterTypeBibTeXField.lower(value)
}


/**
 * Parse error information
 */
public struct BibTeXParseError {
    public var line: UInt32
    public var column: UInt32
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: UInt32, column: UInt32, message: String) {
        self.line = line
        self.column = column
        self.message = message
    }
}



extension BibTeXParseError: Equatable, Hashable {
    public static func ==(lhs: BibTeXParseError, rhs: BibTeXParseError) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.column != rhs.column {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(column)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXParseError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXParseError {
        return
            try BibTeXParseError(
                line: FfiConverterUInt32.read(from: &buf), 
                column: FfiConverterUInt32.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXParseError, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.line, into: &buf)
        FfiConverterUInt32.write(value.column, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseError_lift(_ buf: RustBuffer) throws -> BibTeXParseError {
    return try FfiConverterTypeBibTeXParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseError_lower(_ value: BibTeXParseError) -> RustBuffer {
    return FfiConverterTypeBibTeXParseError.lower(value)
}


/**
 * Result of parsing a BibTeX file
 */
public struct BibTeXParseResult {
    public var entries: [BibTeXEntry]
    public var preambles: [String]
    public var strings: [String: String]
    public var errors: [BibTeXParseError]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entries: [BibTeXEntry], preambles: [String], strings: [String: String], errors: [BibTeXParseError]) {
        self.entries = entries
        self.preambles = preambles
        self.strings = strings
        self.errors = errors
    }
}



extension BibTeXParseResult: Equatable, Hashable {
    public static func ==(lhs: BibTeXParseResult, rhs: BibTeXParseResult) -> Bool {
        if lhs.entries != rhs.entries {
            return false
        }
        if lhs.preambles != rhs.preambles {
            return false
        }
        if lhs.strings != rhs.strings {
            return false
        }
        if lhs.errors != rhs.errors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entries)
        hasher.combine(preambles)
        hasher.combine(strings)
        hasher.combine(errors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXParseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXParseResult {
        return
            try BibTeXParseResult(
                entries: FfiConverterSequenceTypeBibTeXEntry.read(from: &buf), 
                preambles: FfiConverterSequenceString.read(from: &buf), 
                strings: FfiConverterDictionaryStringString.read(from: &buf), 
                errors: FfiConverterSequenceTypeBibTeXParseError.read(from: &buf)
        )
    }

    public static func write(_ value: BibTeXParseResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBibTeXEntry.write(value.entries, into: &buf)
        FfiConverterSequenceString.write(value.preambles, into: &buf)
        FfiConverterDictionaryStringString.write(value.strings, into: &buf)
        FfiConverterSequenceTypeBibTeXParseError.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseResult_lift(_ buf: RustBuffer) throws -> BibTeXParseResult {
    return try FfiConverterTypeBibTeXParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXParseResult_lower(_ value: BibTeXParseResult) -> RustBuffer {
    return FfiConverterTypeBibTeXParseResult.lower(value)
}


/**
 * Result of a deduplication comparison
 */
public struct DeduplicationMatch {
    /**
     * Overall similarity score (0.0 to 1.0)
     */
    public var score: Double
    /**
     * Human-readable explanation of why entries match
     */
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Overall similarity score (0.0 to 1.0)
         */score: Double, 
        /**
         * Human-readable explanation of why entries match
         */reason: String) {
        self.score = score
        self.reason = reason
    }
}



extension DeduplicationMatch: Equatable, Hashable {
    public static func ==(lhs: DeduplicationMatch, rhs: DeduplicationMatch) -> Bool {
        if lhs.score != rhs.score {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(score)
        hasher.combine(reason)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeduplicationMatch: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeduplicationMatch {
        return
            try DeduplicationMatch(
                score: FfiConverterDouble.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeduplicationMatch, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.score, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationMatch_lift(_ buf: RustBuffer) throws -> DeduplicationMatch {
    return try FfiConverterTypeDeduplicationMatch.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeduplicationMatch_lower(_ value: DeduplicationMatch) -> RustBuffer {
    return FfiConverterTypeDeduplicationMatch.lower(value)
}


/**
 * Extracted identifier with position information
 */
public struct ExtractedIdentifier {
    public var identifierType: String
    public var value: String
    public var startIndex: UInt32
    public var endIndex: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifierType: String, value: String, startIndex: UInt32, endIndex: UInt32) {
        self.identifierType = identifierType
        self.value = value
        self.startIndex = startIndex
        self.endIndex = endIndex
    }
}



extension ExtractedIdentifier: Equatable, Hashable {
    public static func ==(lhs: ExtractedIdentifier, rhs: ExtractedIdentifier) -> Bool {
        if lhs.identifierType != rhs.identifierType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.startIndex != rhs.startIndex {
            return false
        }
        if lhs.endIndex != rhs.endIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifierType)
        hasher.combine(value)
        hasher.combine(startIndex)
        hasher.combine(endIndex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtractedIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtractedIdentifier {
        return
            try ExtractedIdentifier(
                identifierType: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                startIndex: FfiConverterUInt32.read(from: &buf), 
                endIndex: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ExtractedIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifierType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterUInt32.write(value.startIndex, into: &buf)
        FfiConverterUInt32.write(value.endIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractedIdentifier_lift(_ buf: RustBuffer) throws -> ExtractedIdentifier {
    return try FfiConverterTypeExtractedIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractedIdentifier_lower(_ value: ExtractedIdentifier) -> RustBuffer {
    return FfiConverterTypeExtractedIdentifier.lower(value)
}


/**
 * A parsed RIS entry
 */
public struct RisEntry {
    public var entryType: RisType
    public var tags: [RisTag]
    public var rawRis: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entryType: RisType, tags: [RisTag], rawRis: String?) {
        self.entryType = entryType
        self.tags = tags
        self.rawRis = rawRis
    }
}



extension RisEntry: Equatable, Hashable {
    public static func ==(lhs: RisEntry, rhs: RisEntry) -> Bool {
        if lhs.entryType != rhs.entryType {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.rawRis != rhs.rawRis {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entryType)
        hasher.combine(tags)
        hasher.combine(rawRis)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisEntry {
        return
            try RisEntry(
                entryType: FfiConverterTypeRISType.read(from: &buf), 
                tags: FfiConverterSequenceTypeRISTag.read(from: &buf), 
                rawRis: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RisEntry, into buf: inout [UInt8]) {
        FfiConverterTypeRISType.write(value.entryType, into: &buf)
        FfiConverterSequenceTypeRISTag.write(value.tags, into: &buf)
        FfiConverterOptionString.write(value.rawRis, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISEntry_lift(_ buf: RustBuffer) throws -> RisEntry {
    return try FfiConverterTypeRISEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISEntry_lower(_ value: RisEntry) -> RustBuffer {
    return FfiConverterTypeRISEntry.lower(value)
}


/**
 * A single RIS tag (key-value pair)
 */
public struct RisTag {
    public var tag: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tag: String, value: String) {
        self.tag = tag
        self.value = value
    }
}



extension RisTag: Equatable, Hashable {
    public static func ==(lhs: RisTag, rhs: RisTag) -> Bool {
        if lhs.tag != rhs.tag {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tag)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisTag {
        return
            try RisTag(
                tag: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RisTag, into buf: inout [UInt8]) {
        FfiConverterString.write(value.tag, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISTag_lift(_ buf: RustBuffer) throws -> RisTag {
    return try FfiConverterTypeRISTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISTag_lower(_ value: RisTag) -> RustBuffer {
    return FfiConverterTypeRISTag.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BibTeX entry type
 */

public enum BibTeXEntryType {
    
    case article
    case book
    case booklet
    case inBook
    case inCollection
    case inProceedings
    case manual
    case mastersThesis
    case misc
    case phdThesis
    case proceedings
    case techReport
    case unpublished
    case online
    case software
    case dataset
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBibTeXEntryType: FfiConverterRustBuffer {
    typealias SwiftType = BibTeXEntryType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BibTeXEntryType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .article
        
        case 2: return .book
        
        case 3: return .booklet
        
        case 4: return .inBook
        
        case 5: return .inCollection
        
        case 6: return .inProceedings
        
        case 7: return .manual
        
        case 8: return .mastersThesis
        
        case 9: return .misc
        
        case 10: return .phdThesis
        
        case 11: return .proceedings
        
        case 12: return .techReport
        
        case 13: return .unpublished
        
        case 14: return .online
        
        case 15: return .software
        
        case 16: return .dataset
        
        case 17: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BibTeXEntryType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .article:
            writeInt(&buf, Int32(1))
        
        
        case .book:
            writeInt(&buf, Int32(2))
        
        
        case .booklet:
            writeInt(&buf, Int32(3))
        
        
        case .inBook:
            writeInt(&buf, Int32(4))
        
        
        case .inCollection:
            writeInt(&buf, Int32(5))
        
        
        case .inProceedings:
            writeInt(&buf, Int32(6))
        
        
        case .manual:
            writeInt(&buf, Int32(7))
        
        
        case .mastersThesis:
            writeInt(&buf, Int32(8))
        
        
        case .misc:
            writeInt(&buf, Int32(9))
        
        
        case .phdThesis:
            writeInt(&buf, Int32(10))
        
        
        case .proceedings:
            writeInt(&buf, Int32(11))
        
        
        case .techReport:
            writeInt(&buf, Int32(12))
        
        
        case .unpublished:
            writeInt(&buf, Int32(13))
        
        
        case .online:
            writeInt(&buf, Int32(14))
        
        
        case .software:
            writeInt(&buf, Int32(15))
        
        
        case .dataset:
            writeInt(&buf, Int32(16))
        
        
        case .unknown:
            writeInt(&buf, Int32(17))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntryType_lift(_ buf: RustBuffer) throws -> BibTeXEntryType {
    return try FfiConverterTypeBibTeXEntryType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBibTeXEntryType_lower(_ value: BibTeXEntryType) -> RustBuffer {
    return FfiConverterTypeBibTeXEntryType.lower(value)
}



extension BibTeXEntryType: Equatable, Hashable {}




/**
 * Error type for parsing failures
 */
public enum ParseError {

    
    
    case InvalidSyntax
    case UnexpectedToken
    case MissingField
    case InvalidEntryType
    case EncodingError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSyntax
        case 2: return .UnexpectedToken
        case 3: return .MissingField
        case 4: return .InvalidEntryType
        case 5: return .EncodingError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidSyntax:
            writeInt(&buf, Int32(1))
        
        
        case .UnexpectedToken:
            writeInt(&buf, Int32(2))
        
        
        case .MissingField:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidEntryType:
            writeInt(&buf, Int32(4))
        
        
        case .EncodingError:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension ParseError: Equatable, Hashable {}

extension ParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * RIS reference type
 */

public enum RisType {
    
    case abst
    case advs
    case aggr
    case ancient
    case art
    case bill
    case blog
    case book
    case `case`
    case chap
    case chart
    case clswk
    case comp
    case conf
    case cpaper
    case ctlg
    case data
    case dbase
    case dict
    case ebook
    case echap
    case edbook
    case ejour
    case elec
    case encyc
    case equa
    case figure
    case gen
    case govdoc
    case grant
    case hear
    case icomm
    case inpr
    case jfull
    case jour
    case legal
    case manscpt
    case map
    case mgzn
    case mpct
    case multi
    case music
    case news
    case pamp
    case pat
    case pcomm
    case rprt
    case ser
    case slide
    case sound
    case stand
    case stat
    case thes
    case unbill
    case unpb
    case video
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRISType: FfiConverterRustBuffer {
    typealias SwiftType = RisType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RisType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .abst
        
        case 2: return .advs
        
        case 3: return .aggr
        
        case 4: return .ancient
        
        case 5: return .art
        
        case 6: return .bill
        
        case 7: return .blog
        
        case 8: return .book
        
        case 9: return .`case`
        
        case 10: return .chap
        
        case 11: return .chart
        
        case 12: return .clswk
        
        case 13: return .comp
        
        case 14: return .conf
        
        case 15: return .cpaper
        
        case 16: return .ctlg
        
        case 17: return .data
        
        case 18: return .dbase
        
        case 19: return .dict
        
        case 20: return .ebook
        
        case 21: return .echap
        
        case 22: return .edbook
        
        case 23: return .ejour
        
        case 24: return .elec
        
        case 25: return .encyc
        
        case 26: return .equa
        
        case 27: return .figure
        
        case 28: return .gen
        
        case 29: return .govdoc
        
        case 30: return .grant
        
        case 31: return .hear
        
        case 32: return .icomm
        
        case 33: return .inpr
        
        case 34: return .jfull
        
        case 35: return .jour
        
        case 36: return .legal
        
        case 37: return .manscpt
        
        case 38: return .map
        
        case 39: return .mgzn
        
        case 40: return .mpct
        
        case 41: return .multi
        
        case 42: return .music
        
        case 43: return .news
        
        case 44: return .pamp
        
        case 45: return .pat
        
        case 46: return .pcomm
        
        case 47: return .rprt
        
        case 48: return .ser
        
        case 49: return .slide
        
        case 50: return .sound
        
        case 51: return .stand
        
        case 52: return .stat
        
        case 53: return .thes
        
        case 54: return .unbill
        
        case 55: return .unpb
        
        case 56: return .video
        
        case 57: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RisType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .abst:
            writeInt(&buf, Int32(1))
        
        
        case .advs:
            writeInt(&buf, Int32(2))
        
        
        case .aggr:
            writeInt(&buf, Int32(3))
        
        
        case .ancient:
            writeInt(&buf, Int32(4))
        
        
        case .art:
            writeInt(&buf, Int32(5))
        
        
        case .bill:
            writeInt(&buf, Int32(6))
        
        
        case .blog:
            writeInt(&buf, Int32(7))
        
        
        case .book:
            writeInt(&buf, Int32(8))
        
        
        case .`case`:
            writeInt(&buf, Int32(9))
        
        
        case .chap:
            writeInt(&buf, Int32(10))
        
        
        case .chart:
            writeInt(&buf, Int32(11))
        
        
        case .clswk:
            writeInt(&buf, Int32(12))
        
        
        case .comp:
            writeInt(&buf, Int32(13))
        
        
        case .conf:
            writeInt(&buf, Int32(14))
        
        
        case .cpaper:
            writeInt(&buf, Int32(15))
        
        
        case .ctlg:
            writeInt(&buf, Int32(16))
        
        
        case .data:
            writeInt(&buf, Int32(17))
        
        
        case .dbase:
            writeInt(&buf, Int32(18))
        
        
        case .dict:
            writeInt(&buf, Int32(19))
        
        
        case .ebook:
            writeInt(&buf, Int32(20))
        
        
        case .echap:
            writeInt(&buf, Int32(21))
        
        
        case .edbook:
            writeInt(&buf, Int32(22))
        
        
        case .ejour:
            writeInt(&buf, Int32(23))
        
        
        case .elec:
            writeInt(&buf, Int32(24))
        
        
        case .encyc:
            writeInt(&buf, Int32(25))
        
        
        case .equa:
            writeInt(&buf, Int32(26))
        
        
        case .figure:
            writeInt(&buf, Int32(27))
        
        
        case .gen:
            writeInt(&buf, Int32(28))
        
        
        case .govdoc:
            writeInt(&buf, Int32(29))
        
        
        case .grant:
            writeInt(&buf, Int32(30))
        
        
        case .hear:
            writeInt(&buf, Int32(31))
        
        
        case .icomm:
            writeInt(&buf, Int32(32))
        
        
        case .inpr:
            writeInt(&buf, Int32(33))
        
        
        case .jfull:
            writeInt(&buf, Int32(34))
        
        
        case .jour:
            writeInt(&buf, Int32(35))
        
        
        case .legal:
            writeInt(&buf, Int32(36))
        
        
        case .manscpt:
            writeInt(&buf, Int32(37))
        
        
        case .map:
            writeInt(&buf, Int32(38))
        
        
        case .mgzn:
            writeInt(&buf, Int32(39))
        
        
        case .mpct:
            writeInt(&buf, Int32(40))
        
        
        case .multi:
            writeInt(&buf, Int32(41))
        
        
        case .music:
            writeInt(&buf, Int32(42))
        
        
        case .news:
            writeInt(&buf, Int32(43))
        
        
        case .pamp:
            writeInt(&buf, Int32(44))
        
        
        case .pat:
            writeInt(&buf, Int32(45))
        
        
        case .pcomm:
            writeInt(&buf, Int32(46))
        
        
        case .rprt:
            writeInt(&buf, Int32(47))
        
        
        case .ser:
            writeInt(&buf, Int32(48))
        
        
        case .slide:
            writeInt(&buf, Int32(49))
        
        
        case .sound:
            writeInt(&buf, Int32(50))
        
        
        case .stand:
            writeInt(&buf, Int32(51))
        
        
        case .stat:
            writeInt(&buf, Int32(52))
        
        
        case .thes:
            writeInt(&buf, Int32(53))
        
        
        case .unbill:
            writeInt(&buf, Int32(54))
        
        
        case .unpb:
            writeInt(&buf, Int32(55))
        
        
        case .video:
            writeInt(&buf, Int32(56))
        
        
        case .unknown:
            writeInt(&buf, Int32(57))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISType_lift(_ buf: RustBuffer) throws -> RisType {
    return try FfiConverterTypeRISType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRISType_lower(_ value: RisType) -> RustBuffer {
    return FfiConverterTypeRISType.lower(value)
}



extension RisType: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXEntry: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXEntry]

    public static func write(_ value: [BibTeXEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXField: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXField]

    public static func write(_ value: [BibTeXField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXField] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXField.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBibTeXParseError: FfiConverterRustBuffer {
    typealias SwiftType = [BibTeXParseError]

    public static func write(_ value: [BibTeXParseError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBibTeXParseError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BibTeXParseError] {
        let len: Int32 = try readInt(&buf)
        var seq = [BibTeXParseError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBibTeXParseError.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExtractedIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ExtractedIdentifier]

    public static func write(_ value: [ExtractedIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExtractedIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExtractedIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExtractedIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExtractedIdentifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRISEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RisEntry]

    public static func write(_ value: [RisEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRISEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RisEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RisEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRISEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRISTag: FfiConverterRustBuffer {
    typealias SwiftType = [RisTag]

    public static func write(_ value: [RisTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRISTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RisTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [RisTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRISTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
/**
 * Check if author lists have overlap
 */
public func authorsOverlap(authors1: String, authors2: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_authors_overlap(
        FfiConverterString.lower(authors1),
        FfiConverterString.lower(authors2),$0
    )
})
}
public func bibtexFormatEntries(entries: [BibTeXEntry]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bibtex_format_entries(
        FfiConverterSequenceTypeBibTeXEntry.lower(entries),$0
    )
})
}
public func bibtexFormatEntry(entry: BibTeXEntry) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_bibtex_format_entry(
        FfiConverterTypeBibTeXEntry.lower(entry),$0
    )
})
}
public func bibtexParse(input: String)throws  -> BibTeXParseResult {
    return try  FfiConverterTypeBibTeXParseResult.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_imbib_core_fn_func_bibtex_parse(
        FfiConverterString.lower(input),$0
    )
})
}
public func bibtexParseEntry(input: String)throws  -> BibTeXEntry {
    return try  FfiConverterTypeBibTeXEntry.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_imbib_core_fn_func_bibtex_parse_entry(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Calculate similarity score between two BibTeX entries
 */
public func calculateSimilarity(entry1: BibTeXEntry, entry2: BibTeXEntry) -> DeduplicationMatch {
    return try!  FfiConverterTypeDeduplicationMatch.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_calculate_similarity(
        FfiConverterTypeBibTeXEntry.lower(entry1),
        FfiConverterTypeBibTeXEntry.lower(entry2),$0
    )
})
}
/**
 * Extract all identifiers from text
 */
public func extractAll(text: String) -> [ExtractedIdentifier] {
    return try!  FfiConverterSequenceTypeExtractedIdentifier.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_all(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Extract arXiv IDs from text
 */
public func extractArxivIds(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_arxiv_ids(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Extract DOIs from text
 */
public func extractDois(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_dois(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Extract ISBNs from text
 */
public func extractIsbns(text: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_extract_isbns(
        FfiConverterString.lower(text),$0
    )
})
}
/**
 * Generate a cite key from metadata
 *
 * Format: {LastName}{Year}{TitleWord}
 * Examples: Smith2024Machine, Jones2023Deep
 */
public func generateCiteKey(author: String?, year: String?, title: String?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_generate_cite_key(
        FfiConverterOptionString.lower(author),
        FfiConverterOptionString.lower(year),
        FfiConverterOptionString.lower(title),$0
    )
})
}
/**
 * Hello world function to verify FFI setup
 */
public func helloFromRust() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_hello_from_rust($0
    )
})
}
/**
 * Validate an arXiv ID
 */
public func isValidArxivId(arxivId: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_arxiv_id(
        FfiConverterString.lower(arxivId),$0
    )
})
}
/**
 * Validate a DOI
 */
public func isValidDoi(doi: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_doi(
        FfiConverterString.lower(doi),$0
    )
})
}
/**
 * Validate an ISBN (ISBN-10 or ISBN-13)
 */
public func isValidIsbn(isbn: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_is_valid_isbn(
        FfiConverterString.lower(isbn),$0
    )
})
}
/**
 * Normalize an author name for comparison
 *
 * - Converts to lowercase
 * - Removes diacritics
 * - Normalizes name order
 * - Removes titles and suffixes (Dr., Jr., etc.)
 */
public func normalizeAuthor(author: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_author(
        FfiConverterString.lower(author),$0
    )
})
}
/**
 * Normalize a DOI to a canonical form
 */
public func normalizeDoi(doi: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_doi(
        FfiConverterString.lower(doi),$0
    )
})
}
/**
 * Normalize a title for comparison
 *
 * - Converts to lowercase
 * - Removes diacritics
 * - Removes punctuation
 * - Collapses whitespace
 * - Removes common prefixes/suffixes
 */
public func normalizeTitle(title: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_normalize_title(
        FfiConverterString.lower(title),$0
    )
})
}
public func risFormatEntry(entry: RisEntry) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_format_entry(
        FfiConverterTypeRISEntry.lower(entry),$0
    )
})
}
public func risFromBibtex(entry: BibTeXEntry) -> RisEntry {
    return try!  FfiConverterTypeRISEntry.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_from_bibtex(
        FfiConverterTypeBibTeXEntry.lower(entry),$0
    )
})
}
public func risParse(input: String)throws  -> [RisEntry] {
    return try  FfiConverterSequenceTypeRISEntry.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_imbib_core_fn_func_ris_parse(
        FfiConverterString.lower(input),$0
    )
})
}
public func risToBibtex(entry: RisEntry) -> BibTeXEntry {
    return try!  FfiConverterTypeBibTeXEntry.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_ris_to_bibtex(
        FfiConverterTypeRISEntry.lower(entry),$0
    )
})
}
/**
 * Check if two titles are similar
 */
public func titlesMatch(title1: String, title2: String, threshold: Double) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_titles_match(
        FfiConverterString.lower(title1),
        FfiConverterString.lower(title2),
        FfiConverterDouble.lower(threshold),$0
    )
})
}
/**
 * Returns the version of imbib-core
 */
public func version() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_imbib_core_fn_func_version($0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_imbib_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_imbib_core_checksum_func_authors_overlap() != 26271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_format_entries() != 41213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_format_entry() != 22118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_parse() != 46841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_bibtex_parse_entry() != 27696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_calculate_similarity() != 58784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_all() != 54155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_arxiv_ids() != 37927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_dois() != 32442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_extract_isbns() != 22180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_generate_cite_key() != 54936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_hello_from_rust() != 10594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_arxiv_id() != 250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_doi() != 58310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_is_valid_isbn() != 50674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_author() != 6657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_doi() != 45064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_normalize_title() != 40807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_format_entry() != 35878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_from_bibtex() != 56357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_parse() != 57168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_ris_to_bibtex() != 61743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_titles_match() != 50009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_imbib_core_checksum_func_version() != 42387) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all