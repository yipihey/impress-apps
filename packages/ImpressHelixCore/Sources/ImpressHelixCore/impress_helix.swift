// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(impress_helixFFI)
import impress_helixFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_impress_helix_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_impress_helix_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * FFI wrapper for the Helix editor state.
 */
public protocol FfiHelixEditorProtocol : AnyObject {
    
    /**
     * Exit space-mode.
     */
    func exitSpaceMode() 
    
    /**
     * Handle a key press without a text engine.
     *
     * Returns the result indicating what action was taken.
     */
    func handleKey(key: String, modifiers: FfiKeyModifiers)  -> FfiKeyResult
    
    /**
     * Check if awaiting a character input (f/t/r operations).
     */
    func isAwaitingCharacter()  -> Bool
    
    /**
     * Check if awaiting a motion (operator pending, e.g., after pressing 'd').
     */
    func isAwaitingMotion()  -> Bool
    
    /**
     * Check if search mode is active.
     */
    func isSearching()  -> Bool
    
    /**
     * Check if space-mode is active.
     */
    func isSpaceMode()  -> Bool
    
    /**
     * Get the current editing mode.
     */
    func mode()  -> FfiHelixMode
    
    /**
     * Get the register (clipboard) content.
     */
    func registerContent()  -> String
    
    /**
     * Reset the editor to normal mode.
     */
    func reset() 
    
    /**
     * Get the current search query.
     */
    func searchQuery()  -> String
    
    /**
     * Get available keys in the current space-mode menu.
     */
    func spaceModeAvailableKeys()  -> [FfiWhichKeyItem]
    
}

/**
 * FFI wrapper for the Helix editor state.
 */
open class FfiHelixEditor:
    FfiHelixEditorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_impress_helix_fn_clone_ffihelixeditor(self.pointer, $0) }
    }
    /**
     * Create a new Helix editor instance.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_impress_helix_fn_constructor_ffihelixeditor_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_impress_helix_fn_free_ffihelixeditor(pointer, $0) }
    }

    

    
    /**
     * Exit space-mode.
     */
open func exitSpaceMode() {try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_exit_space_mode(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Handle a key press without a text engine.
     *
     * Returns the result indicating what action was taken.
     */
open func handleKey(key: String, modifiers: FfiKeyModifiers) -> FfiKeyResult {
    return try!  FfiConverterTypeFfiKeyResult.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_handle_key(self.uniffiClonePointer(),
        FfiConverterString.lower(key),
        FfiConverterTypeFfiKeyModifiers.lower(modifiers),$0
    )
})
}
    
    /**
     * Check if awaiting a character input (f/t/r operations).
     */
open func isAwaitingCharacter() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_is_awaiting_character(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if awaiting a motion (operator pending, e.g., after pressing 'd').
     */
open func isAwaitingMotion() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_is_awaiting_motion(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if search mode is active.
     */
open func isSearching() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_is_searching(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if space-mode is active.
     */
open func isSpaceMode() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_is_space_mode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the current editing mode.
     */
open func mode() -> FfiHelixMode {
    return try!  FfiConverterTypeFfiHelixMode.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_mode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the register (clipboard) content.
     */
open func registerContent() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_register_content(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Reset the editor to normal mode.
     */
open func reset() {try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_reset(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get the current search query.
     */
open func searchQuery() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_search_query(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get available keys in the current space-mode menu.
     */
open func spaceModeAvailableKeys() -> [FfiWhichKeyItem] {
    return try!  FfiConverterSequenceTypeFfiWhichKeyItem.lift(try! rustCall() {
    uniffi_impress_helix_fn_method_ffihelixeditor_space_mode_available_keys(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiHelixEditor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiHelixEditor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiHelixEditor {
        return FfiHelixEditor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiHelixEditor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiHelixEditor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiHelixEditor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixEditor_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiHelixEditor {
    return try FfiConverterTypeFfiHelixEditor.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixEditor_lower(_ value: FfiHelixEditor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiHelixEditor.lower(value)
}


/**
 * FFI-safe key modifiers.
 */
public struct FfiKeyModifiers {
    public var shift: Bool
    public var control: Bool
    public var alt: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shift: Bool, control: Bool, alt: Bool) {
        self.shift = shift
        self.control = control
        self.alt = alt
    }
}



extension FfiKeyModifiers: Equatable, Hashable {
    public static func ==(lhs: FfiKeyModifiers, rhs: FfiKeyModifiers) -> Bool {
        if lhs.shift != rhs.shift {
            return false
        }
        if lhs.control != rhs.control {
            return false
        }
        if lhs.alt != rhs.alt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shift)
        hasher.combine(control)
        hasher.combine(alt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiKeyModifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiKeyModifiers {
        return
            try FfiKeyModifiers(
                shift: FfiConverterBool.read(from: &buf), 
                control: FfiConverterBool.read(from: &buf), 
                alt: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiKeyModifiers, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.shift, into: &buf)
        FfiConverterBool.write(value.control, into: &buf)
        FfiConverterBool.write(value.alt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyModifiers_lift(_ buf: RustBuffer) throws -> FfiKeyModifiers {
    return try FfiConverterTypeFfiKeyModifiers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyModifiers_lower(_ value: FfiKeyModifiers) -> RustBuffer {
    return FfiConverterTypeFfiKeyModifiers.lower(value)
}


/**
 * Result of a range calculation.
 */
public struct FfiTextRange {
    /**
     * Start byte offset.
     */
    public var start: UInt64
    /**
     * End byte offset.
     */
    public var end: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Start byte offset.
         */start: UInt64, 
        /**
         * End byte offset.
         */end: UInt64) {
        self.start = start
        self.end = end
    }
}



extension FfiTextRange: Equatable, Hashable {
    public static func ==(lhs: FfiTextRange, rhs: FfiTextRange) -> Bool {
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(start)
        hasher.combine(end)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTextRange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTextRange {
        return
            try FfiTextRange(
                start: FfiConverterUInt64.read(from: &buf), 
                end: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTextRange, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.start, into: &buf)
        FfiConverterUInt64.write(value.end, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextRange_lift(_ buf: RustBuffer) throws -> FfiTextRange {
    return try FfiConverterTypeFfiTextRange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextRange_lower(_ value: FfiTextRange) -> RustBuffer {
    return FfiConverterTypeFfiTextRange.lower(value)
}


/**
 * An available key in the space-mode menu.
 */
public struct FfiWhichKeyItem {
    /**
     * The key character.
     */
    public var key: String
    /**
     * Description of what the key does.
     */
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The key character.
         */key: String, 
        /**
         * Description of what the key does.
         */description: String) {
        self.key = key
        self.description = description
    }
}



extension FfiWhichKeyItem: Equatable, Hashable {
    public static func ==(lhs: FfiWhichKeyItem, rhs: FfiWhichKeyItem) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiWhichKeyItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWhichKeyItem {
        return
            try FfiWhichKeyItem(
                key: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiWhichKeyItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWhichKeyItem_lift(_ buf: RustBuffer) throws -> FfiWhichKeyItem {
    return try FfiConverterTypeFfiWhichKeyItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWhichKeyItem_lower(_ value: FfiWhichKeyItem) -> RustBuffer {
    return FfiConverterTypeFfiWhichKeyItem.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe Helix command.
 */

public enum FfiHelixCommand {
    
    case enterInsertMode
    case enterNormalMode
    case enterSelectMode
    case enterSearchMode(backward: Bool
    )
    case moveLeft(count: UInt32
    )
    case moveRight(count: UInt32
    )
    case moveUp(count: UInt32
    )
    case moveDown(count: UInt32
    )
    case wordForward(count: UInt32
    )
    case wordBackward(count: UInt32
    )
    case wordEnd(count: UInt32
    )
    case lineStart
    case lineEnd
    case lineFirstNonBlank
    case documentStart
    case documentEnd
    case findCharacter(char: String, count: UInt32
    )
    case findCharacterBackward(char: String, count: UInt32
    )
    case tillCharacter(char: String, count: UInt32
    )
    case tillCharacterBackward(char: String, count: UInt32
    )
    case repeatFind
    case repeatFindReverse
    case searchNext(count: UInt32
    )
    case searchPrevious(count: UInt32
    )
    case selectLine
    case selectAll
    case appendAfterCursor
    case appendAtLineEnd
    case insertAtLineStart
    case openLineBelow
    case openLineAbove
    case delete
    case yank
    case pasteAfter
    case pasteBefore
    case change
    case substitute
    case joinLines
    case toggleCase
    case indent
    case dedent
    case replaceCharacter(char: String
    )
    case deleteMotion(motion: FfiMotion
    )
    case changeMotion(motion: FfiMotion
    )
    case yankMotion(motion: FfiMotion
    )
    case indentMotion(motion: FfiMotion
    )
    case dedentMotion(motion: FfiMotion
    )
    case deleteTextObject(textObject: FfiTextObject, modifier: FfiTextObjectModifier
    )
    case changeTextObject(textObject: FfiTextObject, modifier: FfiTextObjectModifier
    )
    case yankTextObject(textObject: FfiTextObject, modifier: FfiTextObjectModifier
    )
    case repeatLastChange
    case undo
    case redo
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiHelixCommand: FfiConverterRustBuffer {
    typealias SwiftType = FfiHelixCommand

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiHelixCommand {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .enterInsertMode
        
        case 2: return .enterNormalMode
        
        case 3: return .enterSelectMode
        
        case 4: return .enterSearchMode(backward: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .moveLeft(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 6: return .moveRight(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 7: return .moveUp(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 8: return .moveDown(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 9: return .wordForward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .wordBackward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .wordEnd(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 12: return .lineStart
        
        case 13: return .lineEnd
        
        case 14: return .lineFirstNonBlank
        
        case 15: return .documentStart
        
        case 16: return .documentEnd
        
        case 17: return .findCharacter(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 18: return .findCharacterBackward(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 19: return .tillCharacter(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 20: return .tillCharacterBackward(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 21: return .repeatFind
        
        case 22: return .repeatFindReverse
        
        case 23: return .searchNext(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 24: return .searchPrevious(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 25: return .selectLine
        
        case 26: return .selectAll
        
        case 27: return .appendAfterCursor
        
        case 28: return .appendAtLineEnd
        
        case 29: return .insertAtLineStart
        
        case 30: return .openLineBelow
        
        case 31: return .openLineAbove
        
        case 32: return .delete
        
        case 33: return .yank
        
        case 34: return .pasteAfter
        
        case 35: return .pasteBefore
        
        case 36: return .change
        
        case 37: return .substitute
        
        case 38: return .joinLines
        
        case 39: return .toggleCase
        
        case 40: return .indent
        
        case 41: return .dedent
        
        case 42: return .replaceCharacter(char: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .deleteMotion(motion: try FfiConverterTypeFfiMotion.read(from: &buf)
        )
        
        case 44: return .changeMotion(motion: try FfiConverterTypeFfiMotion.read(from: &buf)
        )
        
        case 45: return .yankMotion(motion: try FfiConverterTypeFfiMotion.read(from: &buf)
        )
        
        case 46: return .indentMotion(motion: try FfiConverterTypeFfiMotion.read(from: &buf)
        )
        
        case 47: return .dedentMotion(motion: try FfiConverterTypeFfiMotion.read(from: &buf)
        )
        
        case 48: return .deleteTextObject(textObject: try FfiConverterTypeFfiTextObject.read(from: &buf), modifier: try FfiConverterTypeFfiTextObjectModifier.read(from: &buf)
        )
        
        case 49: return .changeTextObject(textObject: try FfiConverterTypeFfiTextObject.read(from: &buf), modifier: try FfiConverterTypeFfiTextObjectModifier.read(from: &buf)
        )
        
        case 50: return .yankTextObject(textObject: try FfiConverterTypeFfiTextObject.read(from: &buf), modifier: try FfiConverterTypeFfiTextObjectModifier.read(from: &buf)
        )
        
        case 51: return .repeatLastChange
        
        case 52: return .undo
        
        case 53: return .redo
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiHelixCommand, into buf: inout [UInt8]) {
        switch value {
        
        
        case .enterInsertMode:
            writeInt(&buf, Int32(1))
        
        
        case .enterNormalMode:
            writeInt(&buf, Int32(2))
        
        
        case .enterSelectMode:
            writeInt(&buf, Int32(3))
        
        
        case let .enterSearchMode(backward):
            writeInt(&buf, Int32(4))
            FfiConverterBool.write(backward, into: &buf)
            
        
        case let .moveLeft(count):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .moveRight(count):
            writeInt(&buf, Int32(6))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .moveUp(count):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .moveDown(count):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordForward(count):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordBackward(count):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordEnd(count):
            writeInt(&buf, Int32(11))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case .lineStart:
            writeInt(&buf, Int32(12))
        
        
        case .lineEnd:
            writeInt(&buf, Int32(13))
        
        
        case .lineFirstNonBlank:
            writeInt(&buf, Int32(14))
        
        
        case .documentStart:
            writeInt(&buf, Int32(15))
        
        
        case .documentEnd:
            writeInt(&buf, Int32(16))
        
        
        case let .findCharacter(char,count):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .findCharacterBackward(char,count):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .tillCharacter(char,count):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .tillCharacterBackward(char,count):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case .repeatFind:
            writeInt(&buf, Int32(21))
        
        
        case .repeatFindReverse:
            writeInt(&buf, Int32(22))
        
        
        case let .searchNext(count):
            writeInt(&buf, Int32(23))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .searchPrevious(count):
            writeInt(&buf, Int32(24))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case .selectLine:
            writeInt(&buf, Int32(25))
        
        
        case .selectAll:
            writeInt(&buf, Int32(26))
        
        
        case .appendAfterCursor:
            writeInt(&buf, Int32(27))
        
        
        case .appendAtLineEnd:
            writeInt(&buf, Int32(28))
        
        
        case .insertAtLineStart:
            writeInt(&buf, Int32(29))
        
        
        case .openLineBelow:
            writeInt(&buf, Int32(30))
        
        
        case .openLineAbove:
            writeInt(&buf, Int32(31))
        
        
        case .delete:
            writeInt(&buf, Int32(32))
        
        
        case .yank:
            writeInt(&buf, Int32(33))
        
        
        case .pasteAfter:
            writeInt(&buf, Int32(34))
        
        
        case .pasteBefore:
            writeInt(&buf, Int32(35))
        
        
        case .change:
            writeInt(&buf, Int32(36))
        
        
        case .substitute:
            writeInt(&buf, Int32(37))
        
        
        case .joinLines:
            writeInt(&buf, Int32(38))
        
        
        case .toggleCase:
            writeInt(&buf, Int32(39))
        
        
        case .indent:
            writeInt(&buf, Int32(40))
        
        
        case .dedent:
            writeInt(&buf, Int32(41))
        
        
        case let .replaceCharacter(char):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(char, into: &buf)
            
        
        case let .deleteMotion(motion):
            writeInt(&buf, Int32(43))
            FfiConverterTypeFfiMotion.write(motion, into: &buf)
            
        
        case let .changeMotion(motion):
            writeInt(&buf, Int32(44))
            FfiConverterTypeFfiMotion.write(motion, into: &buf)
            
        
        case let .yankMotion(motion):
            writeInt(&buf, Int32(45))
            FfiConverterTypeFfiMotion.write(motion, into: &buf)
            
        
        case let .indentMotion(motion):
            writeInt(&buf, Int32(46))
            FfiConverterTypeFfiMotion.write(motion, into: &buf)
            
        
        case let .dedentMotion(motion):
            writeInt(&buf, Int32(47))
            FfiConverterTypeFfiMotion.write(motion, into: &buf)
            
        
        case let .deleteTextObject(textObject,modifier):
            writeInt(&buf, Int32(48))
            FfiConverterTypeFfiTextObject.write(textObject, into: &buf)
            FfiConverterTypeFfiTextObjectModifier.write(modifier, into: &buf)
            
        
        case let .changeTextObject(textObject,modifier):
            writeInt(&buf, Int32(49))
            FfiConverterTypeFfiTextObject.write(textObject, into: &buf)
            FfiConverterTypeFfiTextObjectModifier.write(modifier, into: &buf)
            
        
        case let .yankTextObject(textObject,modifier):
            writeInt(&buf, Int32(50))
            FfiConverterTypeFfiTextObject.write(textObject, into: &buf)
            FfiConverterTypeFfiTextObjectModifier.write(modifier, into: &buf)
            
        
        case .repeatLastChange:
            writeInt(&buf, Int32(51))
        
        
        case .undo:
            writeInt(&buf, Int32(52))
        
        
        case .redo:
            writeInt(&buf, Int32(53))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixCommand_lift(_ buf: RustBuffer) throws -> FfiHelixCommand {
    return try FfiConverterTypeFfiHelixCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixCommand_lower(_ value: FfiHelixCommand) -> RustBuffer {
    return FfiConverterTypeFfiHelixCommand.lower(value)
}



extension FfiHelixCommand: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe Helix editing mode.
 */

public enum FfiHelixMode {
    
    /**
     * Normal mode for navigation and commands.
     */
    case normal
    /**
     * Insert mode for text input.
     */
    case insert
    /**
     * Select mode for extending selections.
     */
    case select
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiHelixMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiHelixMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiHelixMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .normal
        
        case 2: return .insert
        
        case 3: return .select
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiHelixMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .normal:
            writeInt(&buf, Int32(1))
        
        
        case .insert:
            writeInt(&buf, Int32(2))
        
        
        case .select:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixMode_lift(_ buf: RustBuffer) throws -> FfiHelixMode {
    return try FfiConverterTypeFfiHelixMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHelixMode_lower(_ value: FfiHelixMode) -> RustBuffer {
    return FfiConverterTypeFfiHelixMode.lower(value)
}



extension FfiHelixMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of handling a key in the FFI wrapper.
 */

public enum FfiKeyResult {
    
    /**
     * Key was handled, editor state updated.
     */
    case handled
    /**
     * Key should be passed through to the text input.
     */
    case passThrough
    /**
     * A space-mode command was triggered.
     */
    case spaceCommand(command: FfiSpaceCommand
    )
    /**
     * Space-mode menu is showing, here are the available keys.
     */
    case spaceModePending(availableKeys: [FfiWhichKeyItem]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiKeyResult: FfiConverterRustBuffer {
    typealias SwiftType = FfiKeyResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiKeyResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .handled
        
        case 2: return .passThrough
        
        case 3: return .spaceCommand(command: try FfiConverterTypeFfiSpaceCommand.read(from: &buf)
        )
        
        case 4: return .spaceModePending(availableKeys: try FfiConverterSequenceTypeFfiWhichKeyItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiKeyResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .handled:
            writeInt(&buf, Int32(1))
        
        
        case .passThrough:
            writeInt(&buf, Int32(2))
        
        
        case let .spaceCommand(command):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiSpaceCommand.write(command, into: &buf)
            
        
        case let .spaceModePending(availableKeys):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeFfiWhichKeyItem.write(availableKeys, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyResult_lift(_ buf: RustBuffer) throws -> FfiKeyResult {
    return try FfiConverterTypeFfiKeyResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyResult_lower(_ value: FfiKeyResult) -> RustBuffer {
    return FfiConverterTypeFfiKeyResult.lower(value)
}



extension FfiKeyResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe motion type.
 */

public enum FfiMotion {
    
    case left(count: UInt32
    )
    case right(count: UInt32
    )
    case up(count: UInt32
    )
    case down(count: UInt32
    )
    case wordForward(count: UInt32
    )
    case wordBackward(count: UInt32
    )
    case wordEnd(count: UInt32
    )
    case bigWordForward(count: UInt32
    )
    case bigWordBackward(count: UInt32
    )
    case bigWordEnd(count: UInt32
    )
    case lineStart
    case lineEnd
    case lineFirstNonBlank
    case documentStart
    case documentEnd
    case gotoLine(line: UInt32
    )
    case paragraphForward(count: UInt32
    )
    case paragraphBackward(count: UInt32
    )
    case findChar(char: String, count: UInt32
    )
    case findCharBackward(char: String, count: UInt32
    )
    case tillChar(char: String, count: UInt32
    )
    case tillCharBackward(char: String, count: UInt32
    )
    case line
    case matchingBracket
    case toLineEnd
    case toLineStart
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMotion: FfiConverterRustBuffer {
    typealias SwiftType = FfiMotion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMotion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .left(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .right(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .up(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 4: return .down(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .wordForward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 6: return .wordBackward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 7: return .wordEnd(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 8: return .bigWordForward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 9: return .bigWordBackward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .bigWordEnd(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .lineStart
        
        case 12: return .lineEnd
        
        case 13: return .lineFirstNonBlank
        
        case 14: return .documentStart
        
        case 15: return .documentEnd
        
        case 16: return .gotoLine(line: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 17: return .paragraphForward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 18: return .paragraphBackward(count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 19: return .findChar(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 20: return .findCharBackward(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 21: return .tillChar(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 22: return .tillCharBackward(char: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 23: return .line
        
        case 24: return .matchingBracket
        
        case 25: return .toLineEnd
        
        case 26: return .toLineStart
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiMotion, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .left(count):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .right(count):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .up(count):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .down(count):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordForward(count):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordBackward(count):
            writeInt(&buf, Int32(6))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .wordEnd(count):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .bigWordForward(count):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .bigWordBackward(count):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .bigWordEnd(count):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case .lineStart:
            writeInt(&buf, Int32(11))
        
        
        case .lineEnd:
            writeInt(&buf, Int32(12))
        
        
        case .lineFirstNonBlank:
            writeInt(&buf, Int32(13))
        
        
        case .documentStart:
            writeInt(&buf, Int32(14))
        
        
        case .documentEnd:
            writeInt(&buf, Int32(15))
        
        
        case let .gotoLine(line):
            writeInt(&buf, Int32(16))
            FfiConverterUInt32.write(line, into: &buf)
            
        
        case let .paragraphForward(count):
            writeInt(&buf, Int32(17))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .paragraphBackward(count):
            writeInt(&buf, Int32(18))
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .findChar(char,count):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .findCharBackward(char,count):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .tillChar(char,count):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case let .tillCharBackward(char,count):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(char, into: &buf)
            FfiConverterUInt32.write(count, into: &buf)
            
        
        case .line:
            writeInt(&buf, Int32(23))
        
        
        case .matchingBracket:
            writeInt(&buf, Int32(24))
        
        
        case .toLineEnd:
            writeInt(&buf, Int32(25))
        
        
        case .toLineStart:
            writeInt(&buf, Int32(26))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMotion_lift(_ buf: RustBuffer) throws -> FfiMotion {
    return try FfiConverterTypeFfiMotion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMotion_lower(_ value: FfiMotion) -> RustBuffer {
    return FfiConverterTypeFfiMotion.lower(value)
}



extension FfiMotion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe space command.
 */

public enum FfiSpaceCommand {
    
    case fileOpen
    case fileRecent
    case fileSave
    case fileSaveAs
    case fileClose
    case fileCloseAll
    case bufferPicker
    case bufferNext
    case bufferPrev
    case bufferClose
    case bufferCloseOthers
    case bufferRevert
    case windowSplitHorizontal
    case windowSplitVertical
    case windowClose
    case windowOnly
    case windowFocusLeft
    case windowFocusDown
    case windowFocusUp
    case windowFocusRight
    case windowSwapLeft
    case windowSwapDown
    case windowSwapUp
    case windowSwapRight
    case symbolPicker
    case workspaceSymbolPicker
    case globalSearch
    case searchInFile
    case gitStatus
    case gitDiff
    case gitBlame
    case gitLog
    case gitStage
    case gitUnstage
    case diagnosticsList
    case diagnosticNext
    case diagnosticPrev
    case codeAction
    case rename
    case format
    case help
    case commandPalette
    case toggleFileTree
    case toggleTerminal
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSpaceCommand: FfiConverterRustBuffer {
    typealias SwiftType = FfiSpaceCommand

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSpaceCommand {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fileOpen
        
        case 2: return .fileRecent
        
        case 3: return .fileSave
        
        case 4: return .fileSaveAs
        
        case 5: return .fileClose
        
        case 6: return .fileCloseAll
        
        case 7: return .bufferPicker
        
        case 8: return .bufferNext
        
        case 9: return .bufferPrev
        
        case 10: return .bufferClose
        
        case 11: return .bufferCloseOthers
        
        case 12: return .bufferRevert
        
        case 13: return .windowSplitHorizontal
        
        case 14: return .windowSplitVertical
        
        case 15: return .windowClose
        
        case 16: return .windowOnly
        
        case 17: return .windowFocusLeft
        
        case 18: return .windowFocusDown
        
        case 19: return .windowFocusUp
        
        case 20: return .windowFocusRight
        
        case 21: return .windowSwapLeft
        
        case 22: return .windowSwapDown
        
        case 23: return .windowSwapUp
        
        case 24: return .windowSwapRight
        
        case 25: return .symbolPicker
        
        case 26: return .workspaceSymbolPicker
        
        case 27: return .globalSearch
        
        case 28: return .searchInFile
        
        case 29: return .gitStatus
        
        case 30: return .gitDiff
        
        case 31: return .gitBlame
        
        case 32: return .gitLog
        
        case 33: return .gitStage
        
        case 34: return .gitUnstage
        
        case 35: return .diagnosticsList
        
        case 36: return .diagnosticNext
        
        case 37: return .diagnosticPrev
        
        case 38: return .codeAction
        
        case 39: return .rename
        
        case 40: return .format
        
        case 41: return .help
        
        case 42: return .commandPalette
        
        case 43: return .toggleFileTree
        
        case 44: return .toggleTerminal
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSpaceCommand, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fileOpen:
            writeInt(&buf, Int32(1))
        
        
        case .fileRecent:
            writeInt(&buf, Int32(2))
        
        
        case .fileSave:
            writeInt(&buf, Int32(3))
        
        
        case .fileSaveAs:
            writeInt(&buf, Int32(4))
        
        
        case .fileClose:
            writeInt(&buf, Int32(5))
        
        
        case .fileCloseAll:
            writeInt(&buf, Int32(6))
        
        
        case .bufferPicker:
            writeInt(&buf, Int32(7))
        
        
        case .bufferNext:
            writeInt(&buf, Int32(8))
        
        
        case .bufferPrev:
            writeInt(&buf, Int32(9))
        
        
        case .bufferClose:
            writeInt(&buf, Int32(10))
        
        
        case .bufferCloseOthers:
            writeInt(&buf, Int32(11))
        
        
        case .bufferRevert:
            writeInt(&buf, Int32(12))
        
        
        case .windowSplitHorizontal:
            writeInt(&buf, Int32(13))
        
        
        case .windowSplitVertical:
            writeInt(&buf, Int32(14))
        
        
        case .windowClose:
            writeInt(&buf, Int32(15))
        
        
        case .windowOnly:
            writeInt(&buf, Int32(16))
        
        
        case .windowFocusLeft:
            writeInt(&buf, Int32(17))
        
        
        case .windowFocusDown:
            writeInt(&buf, Int32(18))
        
        
        case .windowFocusUp:
            writeInt(&buf, Int32(19))
        
        
        case .windowFocusRight:
            writeInt(&buf, Int32(20))
        
        
        case .windowSwapLeft:
            writeInt(&buf, Int32(21))
        
        
        case .windowSwapDown:
            writeInt(&buf, Int32(22))
        
        
        case .windowSwapUp:
            writeInt(&buf, Int32(23))
        
        
        case .windowSwapRight:
            writeInt(&buf, Int32(24))
        
        
        case .symbolPicker:
            writeInt(&buf, Int32(25))
        
        
        case .workspaceSymbolPicker:
            writeInt(&buf, Int32(26))
        
        
        case .globalSearch:
            writeInt(&buf, Int32(27))
        
        
        case .searchInFile:
            writeInt(&buf, Int32(28))
        
        
        case .gitStatus:
            writeInt(&buf, Int32(29))
        
        
        case .gitDiff:
            writeInt(&buf, Int32(30))
        
        
        case .gitBlame:
            writeInt(&buf, Int32(31))
        
        
        case .gitLog:
            writeInt(&buf, Int32(32))
        
        
        case .gitStage:
            writeInt(&buf, Int32(33))
        
        
        case .gitUnstage:
            writeInt(&buf, Int32(34))
        
        
        case .diagnosticsList:
            writeInt(&buf, Int32(35))
        
        
        case .diagnosticNext:
            writeInt(&buf, Int32(36))
        
        
        case .diagnosticPrev:
            writeInt(&buf, Int32(37))
        
        
        case .codeAction:
            writeInt(&buf, Int32(38))
        
        
        case .rename:
            writeInt(&buf, Int32(39))
        
        
        case .format:
            writeInt(&buf, Int32(40))
        
        
        case .help:
            writeInt(&buf, Int32(41))
        
        
        case .commandPalette:
            writeInt(&buf, Int32(42))
        
        
        case .toggleFileTree:
            writeInt(&buf, Int32(43))
        
        
        case .toggleTerminal:
            writeInt(&buf, Int32(44))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSpaceCommand_lift(_ buf: RustBuffer) throws -> FfiSpaceCommand {
    return try FfiConverterTypeFfiSpaceCommand.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSpaceCommand_lower(_ value: FfiSpaceCommand) -> RustBuffer {
    return FfiConverterTypeFfiSpaceCommand.lower(value)
}



extension FfiSpaceCommand: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe text object type.
 */

public enum FfiTextObject {
    
    case word
    case bigWord
    case doubleQuote
    case singleQuote
    case backtickQuote
    case parentheses
    case squareBrackets
    case curlyBraces
    case angleBrackets
    case paragraph
    case sentence
    case function
    case `class`
    case comment
    case argument
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTextObject: FfiConverterRustBuffer {
    typealias SwiftType = FfiTextObject

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTextObject {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .word
        
        case 2: return .bigWord
        
        case 3: return .doubleQuote
        
        case 4: return .singleQuote
        
        case 5: return .backtickQuote
        
        case 6: return .parentheses
        
        case 7: return .squareBrackets
        
        case 8: return .curlyBraces
        
        case 9: return .angleBrackets
        
        case 10: return .paragraph
        
        case 11: return .sentence
        
        case 12: return .function
        
        case 13: return .`class`
        
        case 14: return .comment
        
        case 15: return .argument
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiTextObject, into buf: inout [UInt8]) {
        switch value {
        
        
        case .word:
            writeInt(&buf, Int32(1))
        
        
        case .bigWord:
            writeInt(&buf, Int32(2))
        
        
        case .doubleQuote:
            writeInt(&buf, Int32(3))
        
        
        case .singleQuote:
            writeInt(&buf, Int32(4))
        
        
        case .backtickQuote:
            writeInt(&buf, Int32(5))
        
        
        case .parentheses:
            writeInt(&buf, Int32(6))
        
        
        case .squareBrackets:
            writeInt(&buf, Int32(7))
        
        
        case .curlyBraces:
            writeInt(&buf, Int32(8))
        
        
        case .angleBrackets:
            writeInt(&buf, Int32(9))
        
        
        case .paragraph:
            writeInt(&buf, Int32(10))
        
        
        case .sentence:
            writeInt(&buf, Int32(11))
        
        
        case .function:
            writeInt(&buf, Int32(12))
        
        
        case .`class`:
            writeInt(&buf, Int32(13))
        
        
        case .comment:
            writeInt(&buf, Int32(14))
        
        
        case .argument:
            writeInt(&buf, Int32(15))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextObject_lift(_ buf: RustBuffer) throws -> FfiTextObject {
    return try FfiConverterTypeFfiTextObject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextObject_lower(_ value: FfiTextObject) -> RustBuffer {
    return FfiConverterTypeFfiTextObject.lower(value)
}



extension FfiTextObject: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe text object modifier.
 */

public enum FfiTextObjectModifier {
    
    /**
     * Inner modifier (e.g., `iw` for inner word).
     */
    case inner
    /**
     * Around modifier (e.g., `aw` for around word).
     */
    case around
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTextObjectModifier: FfiConverterRustBuffer {
    typealias SwiftType = FfiTextObjectModifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTextObjectModifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inner
        
        case 2: return .around
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiTextObjectModifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inner:
            writeInt(&buf, Int32(1))
        
        
        case .around:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextObjectModifier_lift(_ buf: RustBuffer) throws -> FfiTextObjectModifier {
    return try FfiConverterTypeFfiTextObjectModifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTextObjectModifier_lower(_ value: FfiTextObjectModifier) -> RustBuffer {
    return FfiConverterTypeFfiTextObjectModifier.lower(value)
}



extension FfiTextObjectModifier: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiTextRange: FfiConverterRustBuffer {
    typealias SwiftType = FfiTextRange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiTextRange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiTextRange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiWhichKeyItem: FfiConverterRustBuffer {
    typealias SwiftType = [FfiWhichKeyItem]

    public static func write(_ value: [FfiWhichKeyItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiWhichKeyItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiWhichKeyItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiWhichKeyItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiWhichKeyItem.read(from: &buf))
        }
        return seq
    }
}
/**
 * Calculate the range affected by a motion.
 *
 * - `text`: The full text content.
 * - `cursor_position`: Current cursor position (byte offset).
 * - `motion`: The motion to calculate range for.
 *
 * Returns the range as (start, end) byte offsets, or None if motion cannot be performed.
 */
public func calculateMotionRange(text: String, cursorPosition: UInt64, motion: FfiMotion) -> FfiTextRange? {
    return try!  FfiConverterOptionTypeFfiTextRange.lift(try! rustCall() {
    uniffi_impress_helix_fn_func_calculate_motion_range(
        FfiConverterString.lower(text),
        FfiConverterUInt64.lower(cursorPosition),
        FfiConverterTypeFfiMotion.lower(motion),$0
    )
})
}
/**
 * Calculate the range affected by a text object.
 *
 * - `text`: The full text content.
 * - `cursor_position`: Current cursor position (byte offset).
 * - `text_object`: The text object type.
 * - `modifier`: Inner or Around modifier.
 *
 * Returns the range as (start, end) byte offsets, or None if text object not found.
 */
public func calculateTextObjectRange(text: String, cursorPosition: UInt64, textObject: FfiTextObject, modifier: FfiTextObjectModifier) -> FfiTextRange? {
    return try!  FfiConverterOptionTypeFfiTextRange.lift(try! rustCall() {
    uniffi_impress_helix_fn_func_calculate_text_object_range(
        FfiConverterString.lower(text),
        FfiConverterUInt64.lower(cursorPosition),
        FfiConverterTypeFfiTextObject.lower(textObject),
        FfiConverterTypeFfiTextObjectModifier.lower(modifier),$0
    )
})
}
/**
 * Check if a motion is inclusive (includes the character at the end).
 */
public func isMotionInclusive(motion: FfiMotion) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_func_is_motion_inclusive(
        FfiConverterTypeFfiMotion.lower(motion),$0
    )
})
}
/**
 * Check if a motion is linewise (affects whole lines).
 */
public func isMotionLinewise(motion: FfiMotion) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_impress_helix_fn_func_is_motion_linewise(
        FfiConverterTypeFfiMotion.lower(motion),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_impress_helix_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_impress_helix_checksum_func_calculate_motion_range() != 63933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_func_calculate_text_object_range() != 46132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_func_is_motion_inclusive() != 46243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_func_is_motion_linewise() != 12540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_exit_space_mode() != 33672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_handle_key() != 40713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_is_awaiting_character() != 33721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_is_awaiting_motion() != 22691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_is_searching() != 45689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_is_space_mode() != 29619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_mode() != 46649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_register_content() != 5289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_reset() != 33173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_search_query() != 9760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_method_ffihelixeditor_space_mode_available_keys() != 26367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_impress_helix_checksum_constructor_ffihelixeditor_new() != 39193) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all