//
//  Exports.swift
//  ImpressLLM
//
//  Re-exports the Rust-generated types for use by ImpressAI and app code.
//
//  All types from impress_llm.swift are automatically public and available
//  when importing ImpressLLM.
//
//  Available types include:
//
//  Request/Response:
//  - LlmRequest: Completion request with provider, model, messages, and parameters
//  - LlmResponse: Completion response with content, token usage, and finish reason
//  - LlmMessage: A message with role and content
//  - LlmRole: Message role (System, User, Assistant)
//
//  Provider Info:
//  - ProviderInfo: Metadata about a provider (id, name, registration URL, etc.)
//  - ModelInfo: Metadata about a model (id, name, context window, etc.)
//
//  Memory Management:
//  - MemoryHandle: Handle to a conversation memory scope
//  - MemoryScope: Type of memory scope (Document, Project, Global)
//  - MemoryState: Serializable memory state for persistence
//
//  Errors:
//  - LlmError: Error types (ProviderNotFound, InvalidApiKey, RateLimited, etc.)
//
//  Functions:
//  - listProviders() -> [ProviderInfo]
//  - listModels(providerId: String) -> [ModelInfo]
//  - getProvider(providerId: String) -> ProviderInfo?
//  - complete(request: LlmRequest) -> LlmResponse
//  - createMemoryScope(scopeId: String?, scope: MemoryScope) -> MemoryHandle
//  - addMessageToMemory(handle: MemoryHandle, message: LlmMessage)
//  - getMessagesFromMemory(handle: MemoryHandle) -> [LlmMessage]
//  - completeWithContext(handle: MemoryHandle, request: LlmRequest) -> LlmResponse
//  - exportMemory(handle: MemoryHandle) -> MemoryState
//  - importMemory(id: String, state: MemoryState) -> MemoryHandle
//  - clearMemory(handle: MemoryHandle)
//  - helloFromImpressLlm() -> String
//  - getImpressLlmVersion() -> String
//

import Foundation

// The impress_llm.swift file generated by UniFFI contains all the Swift types
// and functions. All public types are automatically exported when importing
// the ImpressLLM module.
//
// Note: The generated bindings use synchronous (blocking) calls. When using
// these functions in Swift, wrap them in Task.detached to avoid blocking
// the main thread:
//
// Task.detached {
//     let response = try complete(request: request)
//     // Use response on main thread if needed
// }
